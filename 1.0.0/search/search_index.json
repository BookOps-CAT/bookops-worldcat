{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BookOps-Worldcat","text":"<p>Bookops-Worldcat is a Python wrapper around OCLC's WorldCat Metadata API. The package features methods that enable interactions with each endpoint of the API.</p> <p>The Bookops-Worldcat package simplifies some of the OCLC API boilerplate and ideally lowers the technological threshold for cataloging departments that may not have sufficient programming support to access and utilize the web services. Python, with its gentle learning curve, has the potential to be a perfect vehicle towards this goal.</p> <p>Bookops-Worldcat version 1.0 supports changes released in version 2.0 (May 2023) of the OCLC Metadata API. </p>"},{"location":"#overview","title":"Overview","text":"<p>Requires Python 3.8 and up.</p> <p>Bookops-Worldcat takes advantage of the functionality of the popular Requests library and interactions with OCLC's services are built around 'Requests' sessions. <code>MetadataSession</code> inherits all <code>requests.Session</code> properties. Server responses are <code>requests.Response</code> objects with all of their properties and methods.</p> <p>Authorizing a web service session simply requires passing an access token to <code>MetadataSession</code>. Opening a session allows the user to call specific methods to facilitate communication between the user's script/client and a particular endpoint of the Metadata API. Many of the hurdles related to making valid requests are hidden under the hood of this package, making it as simple as possible.</p> <p>Bookops-Worldcat supports OAuth 2.0 endpoints and flows and uses the Client Credential Grant flow.</p>"},{"location":"#installation","title":"Installation","text":"<p>Use pip to install:</p> <p><code>$ pip -m install bookops-worldcat</code></p>"},{"location":"#interacting-with-the-metadata-api","title":"Interacting with the Metadata API","text":"<p>Users of the WorldCat Metadata API must have OCLC credentials. A web service key, or WSKey, can be obtained via the OCLC Developer Network site. More information about WSKeys is available on the OCLC Developer Network site. </p> <p>Querying the WorldCat Metadata API is a two step process. Users first pass their API credentials to the WorldCat Authorization Server to obtain an Access Token and then use that Access Token to query the Metadata API.</p>"},{"location":"#examples","title":"Examples","text":"<p>Users obtain an Access Token by passing credential parameters into the <code>WorldcatAccessToken</code> object.</p> <p>Authorizing a MetadataSession<pre><code>from bookops_worldcat import WorldcatAccessToken, MetadataSession\n\ntoken = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=\"WorldCatMetadataAPI\",\n)\nprint(token)\n#&gt;\"access_token: 'tk_O4WFpJuidaaXJmb8wPb7aMSfJdYZg5XC9Ovo', expires_at: '2024-03-20 15:25:32Z'\"\nprint(token.is_expired())\n#&gt;False\nsession = MetadataSession(authorization=token)\nprint(session.headers)\n#&gt; {'User-Agent': 'bookops-worldcat/1.0.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Authorization': 'Bearer tk_xS0qvZs5j04ewpJeHUqNxQ1Y4LFprOKLw1ek'}\n</code></pre> Once a <code>MetadataSession</code> is authenticated using a <code>WorldcatAccessToken</code> object, users can search WorldCat for bibliographic resources. Brief bib resources are returned in JSON format which can be parsed using the <code>.json()</code> method. Brief Bib Search<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.brief_bibs_search(\n        q=\"ti:The Power Broker AND au: Caro, Robert\"\n    )\n    print(response.json())\n</code></pre> Brief Bib JSON Response<pre><code>{\n  \"numberOfRecords\": 89,\n  \"briefRecords\": [\n    {\n      \"oclcNumber\": \"1631862\",\n      \"title\": \"The power broker : Robert Moses and the fall of New York\",\n      \"creator\": \"Robert A. Caro\",\n      \"date\": \"1975\",\n      \"machineReadableDate\": \"1975\",\n      \"language\": \"eng\",\n      \"generalFormat\": \"Book\",\n      \"specificFormat\": \"PrintBook\",\n      \"edition\": \"Vintage Books edition\",\n      \"publisher\": \"Vintage Books\",\n      \"publicationPlace\": \"New York\",\n      \"isbns\": [\n        \"0394720245\",\n        \"9780394720241\"\n      ],\n      \"mergedOclcNumbers\": [\n        \"750986288\",\n        \"979848451\",\n        \"1171296546\",\n        \"1200988349\",\n        \"1200988563\",\n        \"1201968774\",\n        \"1202023560\",\n        \"1222888365\",\n        \"1282059511\",\n        \"1376480175\"\n      ],\n      \"catalogingInfo\": {\n        \"catalogingAgency\": \"DLC\",\n        \"catalogingLanguage\": \"eng\",\n        \"levelOfCataloging\": \" \",\n        \"transcribingAgency\": \"DLC\"\n      }\n    }\n  ]\n}\n</code></pre> Users can retrieve full bib records from WorldCat by passing the <code>bib_get</code> method an OCLC Number: Get Full Bib Record<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    result = session.bib_get(\"1631862\")\n    print(result.text) \n</code></pre> Full Bib MARCXML Response<pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt;\n  &lt;record xmlns=\"http://www.loc.gov/MARC21/slim\"&gt;\n    &lt;leader&gt;00000cam a2200000 i 4500&lt;/leader&gt;\n    &lt;controlfield tag=\"001\"&gt;ocm01631862&lt;/controlfield&gt;\n    &lt;controlfield tag=\"003\"&gt;OCoLC&lt;/controlfield&gt;\n    &lt;controlfield tag=\"005\"&gt;20240201163642.4&lt;/controlfield&gt;\n    &lt;controlfield tag=\"008\"&gt;750320t19751974nyuabf   b    001 0beng  &lt;/controlfield&gt;\n    &lt;datafield tag=\"010\" ind1=\" \" ind2=\" \"&gt;\n      &lt;subfield code=\"a\"&gt;   75009557 &lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;!--...--&gt;\n    &lt;datafield tag=\"020\" ind1=\" \" ind2=\" \"&gt;\n      &lt;subfield code=\"a\"&gt;9780394720241&lt;/subfield&gt;\n      &lt;subfield code=\"q\"&gt;(paperback)&lt;/subfield&gt;\n&lt;!--...--&gt;\n    &lt;datafield tag=\"100\" ind1=\"1\" ind2=\" \"&gt;\n      &lt;subfield code=\"a\"&gt;Caro, Robert A.,&lt;/subfield&gt;\n      &lt;subfield code=\"e\"&gt;author.&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"245\" ind1=\"1\" ind2=\"4\"&gt;\n      &lt;subfield code=\"a\"&gt;The power broker :&lt;/subfield&gt;\n      &lt;subfield code=\"b\"&gt;Robert Moses and the fall of New York /&lt;/subfield&gt;\n      &lt;subfield code=\"c\"&gt;by Robert A. Caro.&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"246\" ind1=\"3\" ind2=\"0\"&gt;\n      &lt;subfield code=\"a\"&gt;Robert Moses and the fall of New York&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"250\" ind1=\" \" ind2=\" \"&gt;\n      &lt;subfield code=\"a\"&gt;Vintage Books edition.&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"264\" ind1=\" \" ind2=\"1\"&gt;\n      &lt;subfield code=\"a\"&gt;New York :&lt;/subfield&gt;\n      &lt;subfield code=\"b\"&gt;Vintage Books,&lt;/subfield&gt;\n      &lt;subfield code=\"c\"&gt;1975.&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;!--...--&gt;\n&lt;/record&gt;\n</code></pre> Additional examples and a full outline of the functionality available in Bookops-Worldcat are available in the Get Started section.</p>"},{"location":"#supported-oclc-web-services","title":"Supported OCLC web services","text":"<p>The WorldCat Metadata API is a read-write service for WorldCat. It allows users to add and update records in WorldCat; maintain institution holdings; search WorldCat using the full suite of bibliographic record indexes; retrieve MARC records in MARCXML or MARC21; and work with local bibliographic and holdings data. Access to the Metadata API requires OCLC credentials. The BookOps-Worldcat wrapper supports requests to all endpoints of the WorldCat Metadata API:</p> <ul> <li>Manage Bibliographic Records<ul> <li>Validate bib record <code>/manage/bibs/validate/{validationLevel}</code></li> <li>Get current OCLC number <code>/manage/bibs/current</code></li> <li>Create bib record <code>/manage/bibs</code></li> <li>Retrieve full bib record <code>/manage/bibs/{oclcNumber}</code></li> <li>Replace bib record <code>/manage/bibs/{oclcNumber}</code></li> <li>Find match for a bib record in WorldCat <code>/manage/bibs/match</code></li> </ul> </li> <li>Manage Institution Holdings<ul> <li>Retrieve status of institution holdings <code>/manage/institution/holdings/current</code></li> <li>Set institution holding with OCLC Number <code>/manage/institution/holdings/set/{oclcNumber}/set</code></li> <li>Unset institution holding with OCLC Number <code>/manage/institution/holdings/unset/{oclcNumber}/unset</code></li> <li>Set institution holding with MARC record <code>/manage/institution/holdings</code></li> <li>Unset institution holding with MARC record <code>/manage/institution/holdings</code></li> <li>Retrieve institution holding codes <code>/manage/institution/holdings/current</code></li> </ul> </li> <li>Manage Local Bibliographic Data<ul> <li>Create local bib data record <code>/manage/lbds</code></li> <li>Retrieve local bib data record <code>/manage/lbds/{controlNumber}</code></li> <li>Replace local bib data record <code>/manage/lbds/{controlNumber}</code></li> <li>Delete local bib data record <code>/manage/lbds/{controlNumber}</code></li> </ul> </li> <li>Manage Local Holdings Records<ul> <li>Create local holdings record <code>/manage/lhrs</code></li> <li>Retrieve local holdings record <code>/manage/lhrs/{controlNumber}</code></li> <li>Replace local holdings record <code>/manage/lhrs/{controlNumber}</code></li> <li>Delete local holdings record <code>/manage/lhrs/{controlNumber}</code></li> </ul> </li> <li>Search Member Shared Print Holdings <code>/search/bibs-retained-holdings</code></li> <li>Search Member General Holdings<ul> <li>Get summary of holdings for known items <code>/search/bibs-summary-holdings</code></li> <li>Search and retrieve summary of holdings <code>/search/summary-holdings</code></li> </ul> </li> <li>Search Bibliographic Resources<ul> <li>Search brief bib resources <code>/search/brief-bibs</code></li> <li>Retrieve specific brief bib resource <code>/search/brief-bibs/{oclcNumber}</code></li> <li>Retrieve other editions related to a particular bib resource <code>/search/brief-bibs/{oclcNumber}/other-editions</code></li> <li>Retrieve classification recommendations for an OCLC Number <code>/search/classification-bibs/{oclcNumber}</code></li> </ul> </li> <li>Search Local Holdings Resources<ul> <li>Search shared print local holdings resources <code>/search/retained-holdings</code></li> <li>Retrieve local holdings resource <code>/search/my-holdings/{controlNumber}</code></li> <li>Search local holdings resources <code>/search/my-holdings</code></li> <li>Browse my local holdings resources <code>/browse/my-holdings</code></li> </ul> </li> <li>Search Local Bibliographic Resources<ul> <li>Retrieve local bibliographic resource <code>/search/my-local-bib-data/{controlNumber}</code></li> <li>Search local bibliographic resources <code>/search/my-local-bib-data</code></li> </ul> </li> </ul>"},{"location":"#whats-new-in-bookops-worldcat","title":"What's new in Bookops-Worldcat","text":"<p>See the Changelog page for a full outline of fixes and enhancements with each version.</p>"},{"location":"#features-in-version-10","title":"Features in Version 1.0","text":"<p>New functionality available in version 1.0:</p> <ul> <li>Send requests to all endpoints of WorldCat Metadata API<ul> <li>Match bib records and retrieve bib classification</li> <li>Create, update, and validate bib records</li> <li>Create, retrieve, update, and delete local bib and holdings records</li> </ul> </li> <li>Add automatic retries to failed requests</li> <li>Authenticate and authorize for multiple institutions within <code>MetadataSession</code></li> <li>Support for Python 3.11 and 3.12</li> </ul>"},{"location":"#migration-information","title":"Migration Information","text":"<p>Bookops-Worldcat 1.0 introduces many breaking changes for users of previous versions. Due to a complete refactor of the Metadata API, the methods from Bookops-Worldcat 0.5.0 have been rewritten. Most of the functionality from previous versions of the Metadata API is still available in Version 2.0. For a comparison of the functionality available in Versions 1.0, 1.1, and 2.0 of the Metadata API, see OCLC's documentation and their functionality comparison table. </p> <p>Versions 1.0 and 1.1 of the Metadata API will be sunset after April 30, 2024 at which point tools that rely on Bookops-Worldcat 0.5 will no longer be able to query the Metadata API.</p>"},{"location":"#similar-functionality-new-method-names","title":"Similar functionality, new method names","text":"<p>Certain functionality has been retained from Bookops-Worldcat Version 0.5 but the methods have been renamed. See below for changes:</p> Functionality Bookops-Worldcat 0.5 Bookops-Worldcat 1.0 get brief bib resource <code>get_brief_bib</code> <code>brief_bibs_get</code> get full bib record <code>get_full_bib</code> <code>bib_get</code> get current holdings for record <code>holding_get_status</code> <code>holdings_get_current</code> set holdings on a record <code>holding_set</code> <code>holdings_set</code> unset holdings on a record <code>holding_unset</code> <code>holdings_unset</code> search for brief bibs <code>search_brief_bibs</code> <code>brief_bibs_search</code> get other editions of brief bibs <code>search_brief_bib_other_editions</code> <code>brief_bibs_get_other_editions</code> get current oclc number <code>search_current_control_numbers</code> <code>bib_get_current_oclc_number</code> search member holdings <code>search_general_holdings</code> <code>summary_holdings_search</code> search shared print holdings <code>search_shared_print_holdings</code> <code>shared_print_holdings_search</code>"},{"location":"#deprecated-functionality","title":"Deprecated functionality","text":"<p>Certain functionality has been deprecated within Version 2.0 of the Metadata API in including the following methods from Bookops-Worldcat 0.5:  </p> <ul> <li><code>holdings_set</code> and <code>holdings_unset</code><ul> <li>Users are no longer able to set holdings on multiple records in a single request and should instead send separate requests for each record.</li> </ul> </li> <li><code>holdings_set_multi_institutions</code> and <code>holdings_unset_multi_institutions</code><ul> <li>Users are no longer able to set holdings for multiple institutions with one request.</li> <li>If your WSKey is valid for multiple institutions, see section on Identifying Your Institution for an explanation of how to pass your RegistryID to the OCLC Authentication Server and obtain an Access Token.</li> </ul> </li> </ul>"},{"location":"about/","title":"BookOps","text":"<p>BookOps is a fully consolidated, shared library technical services organization that serves the Brooklyn Public Library (BPL) and the New York Public Library (NYPL).</p> <p>BookOps-Worldcat was glued together by Tomasz Kalata and Charlotte Kostelic with contributions by Miriam Gloger.</p>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#oclc-number-formatting","title":"OCLC Number Formatting","text":"<p><code>MetadataSession</code> accepts OCLC numbers in methods' arguments as integers or strings with or without a prefix (eg. \"ocm\", \"ocn\", or \"on\"). The following are all acceptable:</p> <p>Acceptable oclcNumber arguments<pre><code>session.brief_bibs_get(oclcNumber=\"ocm00012345\")\nsession.brief_bibs_search(oclcNumber=\"00054321\")\nsession.bib_get_classification(oclcNumber=12121)\n</code></pre> The <code>bib_get_current_oclc_number</code> and <code>holdings_get_current</code> methods accept multiple OCLC Numbers passed to the <code>oclcNumbers</code> argument. For these methods OCLC Numbers can be passed as a list of strings and/or integers or a string with the numbers separated by commas. The following are all acceptable:</p> Acceptable oclcNumbers arguments<pre><code>session.holdings_get_current(oclcNumbers=[\"ocm00012345\", \"00012346\", \"12347\"])\nsession.holdings_get_current(oclcNumbers=[\"ocm00012345\", \"00012346\", 12347])\nsession.bib_get_current_oclc_number(oclcNumbers=\"ocm00012345, 00012346, 12347\")\n</code></pre>"},{"location":"advanced/#authentication","title":"Authentication","text":""},{"location":"advanced/#worldcataccesstoken","title":"WorldcatAccessToken","text":"<p>A <code>WorldcatAccessToken</code> object retains the underlying Requests object functionality (<code>requests.Request</code>) which can be accessed via the <code>.server_response</code> attribute:</p> <p>Obtaining an Access Token<pre><code>from bookops_worldcat import WorldcatAccessToken\n\ntoken = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=\"WorldCatMetadataAPI\",\n    agent=\"my_app/version 1.0.0\"\n)\nprint(token.server_response.status_code)\n#&gt;200\nprint(token.server_response.elapsed):\n#&gt;0:00:00.650108\n</code></pre> Detailed information can be accessed using the <code>.json()</code> method. token.server_response.json()<pre><code>{\n  \"access_token\": \"tk_TokenString\", \n  \"expires_at\": \"2024-03-14 19:52:37Z\", \n  \"authenticating_institution_id\": \"00001\", \n  \"principalID\": \"\", \n  \"context_institution_id\": \"00001\", \n  \"scopes\": \"WorldCatMetadataAPI:view_brief_bib\",\n  \"token_type\": \"bearer\", \n  \"expires_in\": 1199, \n  \"principalIDNS\": \"\"\n}\n</code></pre> Users can check if the token has expired by calling the <code>is_expired</code> method: token.is_expired()<pre><code>print(token.is_expired())\n#&gt;False\n</code></pre> A failed token request raises a <code>WorldcatAuthorizationError</code> which provides the error code and detailed message returned by the server.</p> WorldcatAuthorizationError<pre><code>from bookops_worldcat import WorldcatAccessToken\n\ntoken = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=\"MetadataAPI\",\n    agent=\"my_app/version 1.0.0\"\n)\nprint(token)\n#&gt;bookops_worldcat.errors.WorldcatAuthorizationError: b'{\"code\":403,\"message\":\"Invalid scope(s): MetadataAPI (MetadataAPI) [Invalid service specified, Not on key]\"}'\n</code></pre>"},{"location":"advanced/#identifying-your-institution","title":"Identifying your institution","text":"<p>Though uncommon, users can request that OCLC set up their WSKeys to allow them to work on behalf of multiple institutions. The user can then authenticate on behalf of any of the institutions associated with that WSKey. </p> <p>If your WSKey is set up to work on behalf of multiple institutions, you can identify your institution when initiating a <code>WorldcatAccessToken</code> object. Pass the Registry ID for the institution you wish to work on behalf of to the scopes parameter as context.</p> Access Token with Context<pre><code>token = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=\"WorldCatMetadataAPI context:00001\",\n    agent=\"my_app/1.0.0\"\n)\n</code></pre>"},{"location":"advanced/#metadatasession","title":"MetadataSession","text":""},{"location":"advanced/#event-hooks","title":"Event hooks","text":"<p><code>MetadataSession</code> methods support Requests event hooks which can be passed as an argument:</p> Event Hooks<pre><code>def print_url(response, *args, **kwargs):\n    print(response.url)\n\nhooks = {'response': print_url}\nsession.brief_bibs_get(850939579, hooks=hooks)\n#&gt;https://metadata.api.oclc.org/worldcat/search/brief-bibs/850939579\n</code></pre>"},{"location":"advanced/#identifying-your-application","title":"Identifying your application","text":"<p>BookOps-Worldcat provides a default <code>user-agent</code> value in the headers of all requests to OCLC web services: <code>bookops-worldcat/{version}</code>. Users are encouraged to update the <code>user-agent</code> value to properly identify your application to OCLC servers. This will provide a useful piece of information for OCLC staff if they need to assist with any troubleshooting problems that may arise.</p> <p>To set a custom <code>user-agent</code> in a session simply pass it as an argument when initiating the session: Custom user-agent<pre><code>session = MetadataSession(authorization=token, agent=\"my_client_name\")\n</code></pre></p> <p>Alternatively, users can update the <code>.headers</code> attribute after initializing the session: Update MetadataSession headers<pre><code>session.headers.update({\"user-agent\": \"my-app/version 1.0\"})\n</code></pre></p> <p>The <code>user-agent</code> header can be set for an access token request as well. To do that simply pass it as the <code>agent</code> parameter when initiating <code>WorldcatAccessToken</code> object: WorldcatAccessToken with custom agent<pre><code>token = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=\"WorldCatMetadataAPI\",\n    agent=\"my_app/1.0.0\"\n)\n</code></pre></p>"},{"location":"advanced/#automatic-token-refresh","title":"Automatic Token Refresh","text":"<p>All requests made within a <code>MetadataSession</code> have a built-in access token auto-refresh feature. While a session is open, the current token will be checked for expiration before sending a request. If the token has expired, a new token will be obtained and the <code>MetadataSession</code> will continue to send requests.</p>"},{"location":"advanced/#retry-failed-requests","title":"Retry Failed Requests","text":"<p>Users can configure a <code>MetadataSession</code> to automatically retry failed requests. This functionality is customizable with the <code>totalRetries</code>, <code>backoffFactor</code>, <code>statusForcelist</code>, and <code>allowedMethods</code> arguments. </p> <p>Note</p> <p>It is recommended that users only allow for automatic retries on timeouts or other server errors. Users should also keep their automatic retries as low as possible in order to not overburden the web service. Users should not set up automatic retries for authentication (401, 403) or malformed request errors (400).</p> <p>MetadataSession with Retries<pre><code>with MetadataSession(\n    authorization=token,\n    totalRetries=3,\n    backoffFactor=0.1,\n    statusForcelist=[500, 502, 503, 504],\n    allowedMethods=[\"GET\"],\n) as session:\n    session.bib_get(\"12334\")\n</code></pre> Bookops-Worldcat will return a <code>RetryError</code> if a request is attempted up to the value of <code>totalRetries</code> and still fails.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#100-3222024","title":"1.0.0 - (3/22/2024)","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Support for OCLC Metadata API Version 2.0<ul> <li><code>MetadataSession</code> methods to support new functionality released in Metadata API 2.0<ul> <li><code>bib_match</code></li> <li><code>bib_get_classification</code></li> <li><code>holdings_set_with_bib</code> and <code>holdings_unset_with_bib</code></li> </ul> </li> <li>New <code>MetadataSession</code> methods to support existing Metadata API functionality<ul> <li>Bib Record Management and Validation<ul> <li><code>bib_create</code></li> <li><code>bib_replace</code></li> <li><code>bib_validate</code></li> </ul> </li> <li>Local Holdings Records<ul> <li><code>lhr_create</code></li> <li><code>lhr_delete</code></li> <li><code>lhr_get</code></li> <li><code>lhr_replace</code></li> </ul> </li> <li>Local Bibliographic Data<ul> <li><code>lbd_create</code></li> <li><code>lbd_delete</code></li> <li><code>lbd_get</code></li> <li><code>lbd_replace</code></li> </ul> </li> <li>Holdings Management<ul> <li><code>holdings_get_codes</code></li> </ul> </li> </ul> </li> </ul> </li> <li>Support for automatic retries of failed requests</li> <li>Support for multi-institution WSKeys</li> <li>Support for Python 3.11 and 3.12</li> <li>New dev dependencies:<ul> <li>types-requests (2.31.0.20240125)</li> <li>mkdocs-material (9.5.13)</li> </ul> </li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li><code>MetadataSession</code> methods that have been renamed and updated (replacing existing functionality in Bookops-Worldcat): <ul> <li><code>get_brief_bib</code> is now <code>brief_bibs_get</code></li> <li><code>get_full_bib</code> is now <code>bib_get</code></li> <li><code>holding_get_status</code> is now <code>holdings_get_current</code></li> <li><code>holding_set</code> is now <code>holdings_set</code></li> <li><code>holding_unset</code> is now <code>holdings_unset</code></li> <li><code>search_brief_bib_other_editions</code> is now <code>brief_bibs_get_other_editions</code></li> <li><code>search_brief_bibs</code> is now <code>brief_bibs_search</code></li> <li><code>search_current_control_numbers</code> is now <code>bib_get_current_oclc_number</code></li> <li><code>search_general_holdings</code> is now <code>summary_holdings_search</code></li> <li><code>search_shared_print_holdings</code> is now <code>shared_print_holdings_search</code> </li> </ul> </li> <li><code>WorldcatAccessToken</code> <ul> <li><code>scopes</code> arg now only accepts strings. A <code>TypeError</code> is raised if <code>scopes</code> arg is passed a list</li> <li><code>token_expires_at</code> attribute is now an aware <code>datetime</code> object (change made due to <code>datetime.utcnow()</code> deprecation)</li> </ul> </li> <li>Error handling:<ul> <li><code>TypeError</code> and <code>ValueError</code> replace <code>WorldcatAuthorizationError</code> when <code>WorldcatAccessToken</code> is passed an invalid arg.</li> <li><code>MetadataSession</code> now raises <code>InvalidOclcNumber</code> exception when invalid OCLC identifiers are given</li> </ul> </li> <li><code>pytest</code> configuration moved from <code>pytest.ini</code> to <code>pyproject.toml</code></li> <li>Updated and clarified type annotations for <code>MetadataSession</code> methods</li> <li>Updated dependencies:<ul> <li>requests: (2.31)</li> </ul> </li> <li>Updated dev dependencies:<ul> <li>black (23.3.0)</li> <li>mike (2.0.0)</li> <li>mypy (1.0.14)</li> </ul> </li> <li>Documentation on https://bookops-cat.github.io/bookops-worldcat/ has been rewritten and reorganized</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li><code>AttributeError</code> changed to <code>TypeError</code> if arg passed to <code>Query.prepared_request</code> is not a <code>PreparedRequest</code></li> <li>All args for methods within <code>MetadataSession</code> have been changed to camel case to be consisted with Metadata API documentation</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li><code>principalID</code> and <code>principalIDNS</code> as args for <code>WorldcatAccessToken</code></li> <li>Automatic handling of large sets of oclcNumbers<ul> <li><code>_split_into_legal_volume</code> removed from <code>MetadataSession</code>; a <code>ValueError</code> is now raised if a method is passed too many oclcNumbers</li> </ul> </li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li>Support for Python 3.7</li> <li>409 error handling for holdings set/unset requests </li> <li><code>WorldcatSessionError</code> <ul> <li>Replaced with <code>TypeError</code> or <code>ValueError</code> in <code>WorldcatSession</code></li> </ul> </li> </ul>"},{"location":"changelog/#050-3112022","title":"0.5.0 - (3/11/2022)","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>feature to set and unset holdings for individual record for multiple institutions (/ih/institutionlist endpoint)</li> <li><code>__repr__</code> method to <code>WorldcatAccessToken</code> object</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>\"refreshing\" of access tokens moved to <code>_session.WorldcatSession</code> from <code>metadata_api.MetadataSession</code> to allow inheritance of this functionality by future clients</li> <li>refactors some of tests</li> </ul>"},{"location":"changelog/#041-2102022","title":"0.4.1 - (2/10/2022)","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Handling of unexpected 206 HTTP code that is occasionally returned by the MetadataAPI /brief-bibs endpoint</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Introduced a breaking change to exceptions raised on calls to the web service for bibliographic resources: <code>WorldcatSessionError</code> was changed to <code>WorldcatRequestError</code>. </li> <li>Dev dependencies updates (pytest, pytest-cov, pytest-mock, mkdocs, black, mik, mkapi, mypy)</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>requests to OCLC services are now handled by a new <code>query.Query</code> class</li> <li>dependencies update<ul> <li>requests to 2.27.1</li> <li>dev dependencies</li> </ul> </li> </ul>"},{"location":"changelog/#040-6222021","title":"0.4.0 - (6/22/2021)","text":""},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Changes to <code>MetadataSession.search_brief_bibs</code> method due to /brief-bibs endpoint changes:<ul> <li>removed deprecated argument <code>heldBy</code></li> <li>added <code>groupVariantRecord</code> and <code>preferredLanguage</code> argument</li> <li>modified <code>groupRelatedEditions</code> to allow boolean arguments</li> </ul> </li> <li>Changes to <code>MetadataSession.search_general_holdings</code> method due to API changes:<ul> <li>added following arguments: <code>holdingsAllVariantRecords</code>, <code>preferredLanguage</code></li> <li>removed deprecated <code>heldBy</code> argument</li> </ul> </li> <li>Changes to <code>MetadataSession.search_brief_bib_other_editions</code>:<ul> <li>added <code>deweyNumber</code>, <code>datePublished</code>, <code>heldByGroup</code>, <code>heldBySymbol</code>,  <code>heldByInstitutionId</code>, <code>inLanguage</code>, <code>inCatalogLanguage</code>, <code>materialType</code>,  <code>catalogSource</code>, <code>itemType</code>, <code>itemSubType</code>, <code>retentionCommitments</code>,  <code>spProgram</code>, <code>topic</code>, <code>subtopic</code>, <code>audience</code>, <code>content</code>, <code>openAccess</code>,  <code>peerReviewed</code>, <code>facets</code>, <code>groupVariantRecords</code>, <code>preferredLanguage</code>,  and <code>orderBy</code>. </li> </ul> </li> </ul>"},{"location":"changelog/#035-622021","title":"0.3.5 - (6/2/2021)","text":""},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Dependencies update<ul> <li>urllib3 from 1.26.4 to 1.26.5</li> </ul> </li> </ul>"},{"location":"changelog/#034-3222021","title":"0.3.4 - (3/22/2021)","text":""},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Dependencies update<ul> <li>certifi to 2020.12.5</li> <li>chardet to 4.0.0</li> <li>requests to 2.25.1</li> <li>urllib3 to 1.26.4</li> </ul> </li> </ul>"},{"location":"changelog/#033-12282020","title":"0.3.3 - (12/28/2020)","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Type hints</li> <li>Default timeout in the MetadataSession extended to 5 seconds</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Dependencies:<ul> <li>pytest bump to 6.1.2</li> <li>mypy 0.7.8</li> </ul> </li> </ul>"},{"location":"changelog/#032-11252020","title":"0.3.2 - (11/25/2020)","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>MetadataSession timeout parameter correctly passed into every session request</li> </ul>"},{"location":"changelog/#031-11242020","title":"0.3.1 - (11/24/2020)","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Fixed auto refreshing of the access token when expired</li> <li>testing: fixed testing for error messages on exceptions &amp; testing of stale tokens</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Dependencies bump<ul> <li>certifi from 2020.6.20 to 2020.11.8</li> <li>requests from 2.24.0 to 2.25.0</li> <li>urllib3 from 1.25.10 to 1.26.2</li> </ul> </li> </ul>"},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Added Python 3.9 testing to CI</li> </ul>"},{"location":"changelog/#030-10032020","title":"0.3.0 - (10/03/2020)","text":""},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Introduces multiple breaking changes compared to the previous version!</li> <li>Dropped features related to the WorldCat Search API</li> <li>Support for Worldcat Metadata API v.1.1 introduced in May 2020</li> <li>Supported Metadata API endpoints:<ul> <li>/bibs-retained-holdings</li> <li>/bibs-summary-holdings</li> <li>/brief-bibs</li> <li>/brief-bibs/{oclcNumber}</li> <li>/brief-bibs/{oclcNumber}/other-editions</li> <li>/bib/data/{oclcNumber}</li> <li>/bib/checkcontrolnumbers</li> <li>/ih/data (POST|DELETE)</li> <li>/ih/checkholdings</li> <li>/ih/datalist (POST|DELETE)</li> </ul> </li> </ul>"},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>API reference added to docs with mkapi</li> </ul>"},{"location":"changelog/#021-9282020","title":"0.2.1 - (9/28/2020)","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>added functionality for docs versioning with mike</li> </ul>"},{"location":"changelog/#020-04302020","title":"0.2.0 - (04/30/2020)","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Expanded and improved documentation</li> <li>Customizable \"user-agent\" in session header and token request</li> <li><code>TokenRequestError</code> exception added on failed access token request</li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>SRU/CQL query syntax aligned with OCLC specifications</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>fixed hooks info in docstrings in <code>SearchSession</code> and <code>MetadataSession</code></li> </ul>"},{"location":"contributing/","title":"How to Contribute","text":"<p>We welcome collaborators who would like to help expand and improve Bookops-Worldcat. Here are some ways to contribute.</p>"},{"location":"contributing/#report-bugs-or-suggest-enhancements","title":"Report bugs or suggest enhancements","text":"<p>Please use our Github issue tracker to submit bug reports or request new features.</p>"},{"location":"contributing/#contribute-code-or-documentation","title":"Contribute code or documentation","text":"Info <p>This page contains a draft of our contribution guidelines but there is still more for us to add.</p> <p>TO DO:</p> <ul> <li>Add style guide for documentation<ul> <li>docstring style conventions</li> <li>type hints</li> <li>how to build docs after making edits</li> </ul> </li> <li>Add CI/CD info</li> </ul>"},{"location":"contributing/#style-and-requirements","title":"Style and Requirements","text":"<p>For new code contributions, please use the tools and standards in place for Bookops-Worldcat:</p> <ul> <li>Code style:<ul> <li>Formatting with black</li> <li>Linting with flake8</li> <li>Static type checking with mypy</li> </ul> </li> <li>Dependency management and package publishing with Poetry</li> <li>Documentation written in Markdown using MkDocs and plugins<ul> <li>Theme is Material for MkDocs</li> <li>Versioning maintained with Mike</li> <li>API Documentation built with MkAPI</li> </ul> </li> <li>Tests written with pytest</li> </ul> Tip <p>If you use VS Code there are certain extensions which will automate code formatting and support some of our code style requirements which may make your work easier while contributing to Bookops-Worldcat. Similar extensions are available on other IDEs. Those extensions include:</p> <ul> <li>Black Formatter</li> <li>Flake8</li> <li>Mypy Type Checker</li> <li>Markdown All in One</li> </ul> <p>Additions to add to your settings.json file: settings.json for VS Code<pre><code>{\n    \"editor.defaultFormatter\": \"ms-python.black-formatter\",\n    \"editor.formatOnSave\": true,\n    \"flake8.args\": [\n        \"--max-line-length=88\",\n    ],\n}\n</code></pre></p>"},{"location":"contributing/#install-and-setup","title":"Install and Setup","text":"<p>To get started contributing code to Bookops-Worldcat you will need: </p> <ul> <li>Python 3.8 or newer</li> <li><code>git</code></li> <li><code>poetry</code></li> </ul>"},{"location":"contributing/#install-poetry","title":"Install Poetry","text":"<p>Bookops-Worldcat uses <code>poetry</code> to manage virtual environments, dependencies, and publishing workflows. We use <code>pipx</code> to run poetry (if you don't have <code>pipx</code>, see the installation instructions). For other installation options, see the <code>poetry</code> documentation.</p>"},{"location":"contributing/#fork-the-repo","title":"Fork the repo","text":"<p>Fork the repository in GitHub and clone your fork locally <pre><code>git clone https://github.com/&lt;your username&gt;/bookops-worldcat\ncd bookops-worldcat\n</code></pre></p>"},{"location":"contributing/#create-a-new-branch-for-your-changes","title":"Create a new branch for your changes","text":"<pre><code>git checkout -b new-branch\n</code></pre>"},{"location":"contributing/#create-a-virtual-environment-and-install-dependencies","title":"Create a virtual environment and install dependencies","text":"<p>Poetry will create a virtual environment, read the <code>pyproject.toml</code> and <code>poetry.lock</code> files, resolve dependencies, and install them with one command.  <pre><code>poetry install\n</code></pre></p>"},{"location":"contributing/#run-tests","title":"Run tests","text":"<p>Run tests before making changes on your fork.</p> Info <p>Our live tests are designed to look for API credentials in a specific file/directory in a Windows environment. We will need to refactor the live tests to allow contributors to run live tests with their own API credentials and run live tests in a macOS environment.</p> <pre><code># basic usage without webtests\npython -m pytest \"not webtest\"\n# with test coverage and without webtests\npython -m pytest \"not webtest\" --cov=bookops_worldcat/\n</code></pre>"},{"location":"local/","title":"Search and Manage Local Data","text":"<p>New functionality available in Version 1.0 of Bookops-Worldcat allows users to search and manage local bibliographic and holdings data via the Metadata API. </p>"},{"location":"local/#manage-local-bib-records","title":"Manage Local Bib Records","text":"<p>Users can manage local bib records in WorldCat in the same way that they manage WorldCat records (see Managing Bibliographic Records for more information). Records can be retrieved in MARCXML or MARC21 formats. The default format for records is MARCXML.  </p> lbd_createlbd_getlbd_replacelbd_delete <p>lbd_create MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.lbd_create(\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(response.content)\n</code></pre> lbd_create MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000n   a2200000   4500&lt;/leader&gt;\n    &lt;controlfield tag=\"001\"&gt;12345&lt;/controlfield&gt;\n    &lt;controlfield tag=\"004\"&gt;3160&lt;/controlfield&gt;\n    &lt;controlfield tag=\"005\"&gt;20240320120824.8&lt;/controlfield&gt;\n    &lt;datafield tag=\"935\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;MyLSN&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"940\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;NYP&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p> <p>lbd_get MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.lbd_get(\"12345\")\n    print(response.content)\n</code></pre> lbd_get MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000n   a2200000   4500&lt;/leader&gt;\n    &lt;controlfield tag=\"001\"&gt;12345&lt;/controlfield&gt;\n    &lt;controlfield tag=\"004\"&gt;3160&lt;/controlfield&gt;\n    &lt;controlfield tag=\"005\"&gt;20240320120824.8&lt;/controlfield&gt;\n    &lt;datafield tag=\"935\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;MyLSN&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"940\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;NYP&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p> <p>lbd_replace MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.lbd_replace(\n            controlNumber=\"12345\",\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(response.content)\n</code></pre> lbd_replace MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000n   a2200000   4500&lt;/leader&gt;\n    &lt;controlfield tag=\"001\"&gt;12345&lt;/controlfield&gt;\n    &lt;controlfield tag=\"004\"&gt;3160&lt;/controlfield&gt;\n    &lt;controlfield tag=\"005\"&gt;20240320120824.8&lt;/controlfield&gt;\n    &lt;datafield tag=\"935\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;MyLSN&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"940\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;NYP&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p> <p>lbd_delete MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.lbd_delete(\"12345\")\n    print(response.content)\n</code></pre> lbd_delete MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000n   a2200000   4500&lt;/leader&gt;\n    &lt;controlfield tag=\"001\"&gt;12345&lt;/controlfield&gt;\n    &lt;controlfield tag=\"004\"&gt;3160&lt;/controlfield&gt;\n    &lt;controlfield tag=\"005\"&gt;20240320120824.8&lt;/controlfield&gt;\n    &lt;datafield tag=\"935\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;MyLSN&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"940\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;NYP&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p>"},{"location":"local/#search-local-bib-resources","title":"Search Local Bib Resources","text":"<p>Users can search for and retrieve brief local bib resources <code>local_bibs_get</code> and <code>local_bibs_search</code> methods. The response will be in JSON format.</p> local_bibs_getlocal_bibs_search <p>local_bibs_get Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.local_bibs_get(123456789)\n    print(response.json())\n</code></pre> local_bibs_get Response<pre><code>{\n  \"controlNumber\": 123456789,\n  \"oclcNumber\": \"987654321\",\n  \"title\": {\n    \"uniformTitles\": [\n      \"Test Book\"\n      ]\n    },\n  \"contributor\": {\n    \"creators\": [\n      {\n        \"firstName\": {\n          \"text\": \"Test\"\n        },\n        \"secondName\": {\n          \"text\": \"Author\"\n        },\n        \"type\": \"person\"\n      }\n    ]\n  },\n  \"localSystemNumber\": \"System.Supplied@2024-03-20,11:50:40\",\n  \"lastUpdated\": 20240320\n}\n</code></pre></p> <p>local_bibs_search Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.local_bibs_search(q=\"ti: Test Book AND au: Test Author\")\n    print(response.json())\n</code></pre> local_bibs_search Response<pre><code>{\n  \"numberOfRecords\": 1,\n  \"records\": [\n    {\n      \"controlNumber\": 123456789,\n      \"oclcNumber\": \"987654321\",\n      \"title\": {\n        \"uniformTitles\": [\n          \"Test Book\"\n        ]\n      },\n      \"contributor\": {\n      \"creators\": [\n        {\n          \"firstName\": {\n            \"text\": \"Test\"\n          },\n          \"secondName\": {\n            \"text\": \"Author\"\n          },\n          \"type\": \"person\"\n        }\n      ]\n    },\n    \"localSystemNumber\": \"System.Supplied@2024-03-20,11:50:40\",\n    \"lastUpdated\": 20240320\n    }\n  ]\n}\n</code></pre></p>"},{"location":"local/#manage-local-holdings-records","title":"Manage Local Holdings Records","text":"<p>Users can manage local holdings records using Bookops-Worldcat in the same way that they manage local bib records (see above: Managing Local Bib Records for more information).</p> lhr_createlhr_getlhr_replacelhr_delete <p>lhr_create MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.lhr_create(\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(response.content)\n</code></pre> lhr_create MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000nx  a2200000zi 4500&lt;/leader&gt;\n    &lt;controlfield tag='004'&gt;00001&lt;/controlfield&gt;\n    &lt;controlfield tag='005'&gt;20240320085741.4&lt;/controlfield&gt;\n    &lt;controlfield tag='007'&gt;zu&lt;/controlfield&gt;\n    &lt;controlfield tag='008'&gt;2403200p    0   4001uueng0210908&lt;/controlfield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='852'&gt;\n        &lt;subfield code='a'&gt;NYP&lt;/subfield&gt;\n        &lt;subfield code='b'&gt;TEST&lt;/subfield&gt;\n        &lt;subfield code='c'&gt;TEST-STACKS&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='876'&gt;\n        &lt;subfield code='p'&gt;00001&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p> <p>lhr_get MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.lhr_get(\"12345\")\n    print(response.content)\n</code></pre> lhr_get MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000nx  a2200000zi 4500&lt;/leader&gt;\n    &lt;controlfield tag='001'&gt;12345&lt;/controlfield&gt;\n    &lt;controlfield tag='004'&gt;00001&lt;/controlfield&gt;\n    &lt;controlfield tag='005'&gt;20240320085741.4&lt;/controlfield&gt;\n    &lt;controlfield tag='007'&gt;zu&lt;/controlfield&gt;\n    &lt;controlfield tag='008'&gt;2403200p    0   4001uueng0210908&lt;/controlfield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='852'&gt;\n        &lt;subfield code='a'&gt;NYP&lt;/subfield&gt;\n        &lt;subfield code='b'&gt;TEST&lt;/subfield&gt;\n        &lt;subfield code='c'&gt;TEST-STACKS&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='876'&gt;\n        &lt;subfield code='p'&gt;00001&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p> <p>lhr_replace MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = io.BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.lhr_replace(\n            controlNumber=\"12345\",\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(response.content)\n</code></pre> lhr_replace MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000nx  a2200000zi 4500&lt;/leader&gt;\n    &lt;controlfield tag='001'&gt;12345&lt;/controlfield&gt;\n    &lt;controlfield tag='004'&gt;00001&lt;/controlfield&gt;\n    &lt;controlfield tag='005'&gt;20240320085741.4&lt;/controlfield&gt;\n    &lt;controlfield tag='007'&gt;zu&lt;/controlfield&gt;\n    &lt;controlfield tag='008'&gt;2403200p    0   4001uueng0210908&lt;/controlfield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='852'&gt;\n        &lt;subfield code='a'&gt;NYP&lt;/subfield&gt;\n        &lt;subfield code='b'&gt;TEST&lt;/subfield&gt;\n        &lt;subfield code='c'&gt;TEST-STACKS&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='876'&gt;\n        &lt;subfield code='p'&gt;00001&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p> <p>lhr_delete MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.lhr_delete(\"12345\")\n    print(response.content)\n</code></pre> lhr_delete MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000nx  a2200000zi 4500&lt;/leader&gt;\n    &lt;controlfield tag='001'&gt;12345&lt;/controlfield&gt;\n    &lt;controlfield tag='004'&gt;00001&lt;/controlfield&gt;\n    &lt;controlfield tag='005'&gt;20240320085741.4&lt;/controlfield&gt;\n    &lt;controlfield tag='007'&gt;zu&lt;/controlfield&gt;\n    &lt;controlfield tag='008'&gt;2403200p    0   4001uueng0210908&lt;/controlfield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='852'&gt;\n        &lt;subfield code='a'&gt;NYP&lt;/subfield&gt;\n        &lt;subfield code='b'&gt;TEST&lt;/subfield&gt;\n        &lt;subfield code='c'&gt;TEST-STACKS&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='876'&gt;\n        &lt;subfield code='p'&gt;00001&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p>"},{"location":"local/#managing-shared-print-commitments","title":"Managing Shared Print Commitments","text":"<p>Users can manage Shared Print collections using the Metadata API by adding Shared Print flags to their Local Holdings Records. More information on managing Shared Print commitments is available on OCLC's Developer Network Site.</p>"},{"location":"local/#search-local-holdings-resources","title":"Search Local Holdings Resources","text":"<p>Users can browse, search for and retrieve brief local holdings data in JSON format using the <code>local_holdings_get</code>, <code>local_holdings_search</code>, <code>local_holdings_browse</code>, and <code>local_holdings_search_shared_print</code> methods:</p> local_holdings_getlocal_holdings_searchlocal_holdings_browselocal_holdings_search_shared_print <p>local_holdings_get Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.local_holdings_get(controlNumber=\"111111111\")\n    print(response.json())\n</code></pre> local_holdings_get Response<pre><code>{\n  \"numberOfHoldings\": 1,\n  \"detailedHoldings\": [\n    {\n      \"lhrControlNumber\": \"111111111\",\n      \"lhrDateEntered\": \"20240101\",\n      \"lhrLastUpdated\": \"20240201\",\n      \"oclcNumber\": \"123456789\",\n      \"format\": \"zu\",\n      \"location\": {\n        \"holdingLocation\": \"NYP\",\n        \"sublocationCollection\": \"TEST\",\n        \"shelvingLocation\": \"TEST-STACKS\"\n      },\n      \"copyNumber\": \"1\",\n      \"callNumber\": {\n        \"displayCallNumber\": \"TEST\",\n        \"classificationPart\": \"TEST\"\n      },\n      \"hasSharedPrintCommitment\": \"N\",\n      \"summary\": \"Local holdings available.\",\n      \"holdingParts\": [\n        {\n        \"pieceDesignation\": \"TEST12345\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre></p> <p>local_holdings_search Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.local_holdings_search(\n        oclcNumber=\"123456789\", \n        orderBy=\"location\"\n        )\n    print(response.json())\n</code></pre> local_holdings_search Response<pre><code>{\n  \"numberOfHoldings\": 1,\n  \"detailedHoldings\": [\n    {\n      \"lhrControlNumber\": \"111111111\",\n      \"lhrDateEntered\": \"20240101\",\n      \"lhrLastUpdated\": \"20240201\",\n      \"oclcNumber\": \"123456789\",\n      \"format\": \"zu\",\n      \"location\": {\n        \"holdingLocation\": \"NYP\",\n        \"sublocationCollection\": \"TEST\",\n        \"shelvingLocation\": \"TEST-STACKS\"\n      },\n      \"copyNumber\": \"1\",\n      \"callNumber\": {\n        \"displayCallNumber\": \"TEST\",\n        \"classificationPart\": \"TEST\"\n      },\n      \"hasSharedPrintCommitment\": \"N\",\n      \"summary\": \"Local holdings available.\",\n      \"holdingParts\": [\n        {\n        \"pieceDesignation\": \"TEST12345\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre></p> <p>local_holdings_browse Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.local_holdings_browse(\n        callNumber=\"ReCAP-000000\", \n        holdingLocation=\"TEST-LOCATION\",\n        shelvingLocation=\"TEST-STACKS\",\n        )\n    print(response.json())\n</code></pre> local_holdings_browse Response<pre><code>{\n  \"numberOfRecords\": 1,\n  \"entries\": [\n    {\n      \"displayCallNumber\": \"ReCAP-000000\",\n      \"holdingLocation\": \"TEST-LOCATION\",\n      \"shelvingLocation\": \"TEST-STACKS\",\n      \"pieceDesignation\": \"123456789\",\n      \"oclcNumber\": 000000000,\n      \"title\": \"Test\",\n      \"creator\": \"Author, Test\",\n      \"date\": \"2024\",\n      \"language\": \"eng\",\n      \"generalFormat\": \"Book\",\n      \"specificFormat\": \"PrintBook\",\n      \"edition\": \"1st ed.\",\n      \"publisher\": \"Test\",\n      \"publicationPlace\": \"New York :\"\n    },\n  ]\n}\n</code></pre></p> <p>local_holdings_search_shared_print Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.local_holdings_search_shared_print(\n        oclcNumber=\"123456789\", \n        orderBy=\"location\"\n        )\n    print(response.json())\n</code></pre> local_holdings_search_shared_print Response<pre><code>{\n  \"numberOfHoldings\": 1,\n  \"detailedHoldings\": [\n    {\n      \"lhrControlNumber\": \"111111111\",\n      \"lhrDateEntered\": \"20240101\",\n      \"lhrLastUpdated\": \"20240201\",\n      \"oclcNumber\": \"123456789\",\n      \"format\": \"zu\",\n      \"location\": {\n        \"holdingLocation\": \"NYP\",\n        \"sublocationCollection\": \"TEST\",\n        \"shelvingLocation\": \"TEST-STACKS\"\n      },\n      \"copyNumber\": \"1\",\n      \"callNumber\": {\n        \"displayCallNumber\": \"TEST\",\n        \"classificationPart\": \"TEST\"\n      },\n      \"hasSharedPrintCommitment\": \"Y\",\n      \"summary\": \"Local holdings available.\",\n      \"holdingParts\": [\n        {\n        \"pieceDesignation\": \"TEST12345\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre></p>"},{"location":"manage_bibs/","title":"Manage Bibliographic Records","text":"<p>Note</p> <p>Users must have \"WorldCatMetadataAPI:manage_bibs\" in the list of scopes for their WSKeys in order to manage bib records using the Metadata API. To check if your WSKey has access to these endpoints, log into your WSKey Management portal. </p>"},{"location":"manage_bibs/#get-full-marc-records","title":"Get Full MARC Records","text":"<p>Users can retrieve full MARC records from WorldCat by passing the <code>bib_get</code> method an OCLC number. The Metadata API correctly matches OCLC numbers of records that have been merged together and returns the current master record. Records can be retrieved in MARCXML or MARC21 formats. The default format is MARCXML.  </p> bib_get<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.bib_get(\"321339\")\n    print(response.status_code)\n#&gt;200\n    print(response.url)\n#&gt;\"https://metadata.api.oclc.org/worldcat/manage/bibs/321339\"\n</code></pre> <p>To avoid raising a <code>UnicodeEncodeError</code> when requesting full bib records it is recommended that one access the response data using the <code>.content</code> attribute of the response object:</p> MARCXMLMARC21 <p>bib_get MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.bib_get(\"321339\")\n    print(response.content)\n</code></pre> bib_get MARCXML Response<pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt;\n  &lt;record xmlns=\"http://www.loc.gov/MARC21/slim\"&gt;\n    &lt;leader&gt;00000cam a22000001a 4500&lt;/leader&gt;\n    &lt;controlfield tag=\"001\"&gt;ocm00321339&lt;/controlfield&gt;\n    &lt;controlfield tag=\"003\"&gt;OCoLC&lt;/controlfield&gt;\n    &lt;controlfield tag=\"005\"&gt;20240202180208.2&lt;/controlfield&gt;\n    &lt;controlfield tag=\"008\"&gt;711005s1967    nyu           000 f eng  &lt;/controlfield&gt;\n    &lt;datafield tag=\"010\" ind1=\" \" ind2=\" \"&gt;\n      &lt;subfield code=\"a\"&gt;   67022898 &lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;!--...--&gt;\n    &lt;datafield tag=\"100\" ind1=\"1\" ind2=\" \"&gt;\n      &lt;subfield code=\"a\"&gt;Bulgakov, Mikhail,&lt;/subfield&gt;\n      &lt;subfield code=\"d\"&gt;1891-1940.&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"240\" ind1=\"1\" ind2=\"0\"&gt;\n      &lt;subfield code=\"a\"&gt;Master i Margarita.&lt;/subfield&gt;\n      &lt;subfield code=\"l\"&gt;English&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"245\" ind1=\"1\" ind2=\"4\"&gt;\n      &lt;subfield code=\"a\"&gt;The master and Margarita /&lt;/subfield&gt;\n      &lt;subfield code=\"c\"&gt;Mikhail Bulgakov ; translated from the Russian by Michael Glenny.&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;!--...--&gt;\n&lt;/record&gt;\n</code></pre></p> <p>bib_get MARC21 Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.bib_get(\"321339\", responseFormat=\"application/marc\")\n    print(response.content)\n</code></pre> bib_get MARC21 Response<pre><code>04305cam a22007691a 4500001001200000003000600012005001700018008004100035010001700076040024300093016002500336019009500361029002200456029002100478029001800499029002200517035016600539037001700705041001300722043001200735050001900747050002500766055002600791082001700817100003500834240003300869245009800902250001701000260003901017300002701056336002601083337002801109338002701137500001101164500016401175500008201339500003201421520019801453546004501651505080201696583004802498651002702546650001602573650002402589651004702613651003002660651002302690651002502713655002302738655001602761655005802777655004802835655002102883655001802904655002802922655002302950655003002973655002303003655002903026655002203055655002503077700002103102700004003123758015803163776017003321938004403491\\x1eocm00321339\\x1eOCoLC\\x1e20240202180208.2\\x1e711005s1967    nyu           000 f eng  \\x1faBulgakov, Mikhail,\\x1fd1891-1940.\\x1e10\\x1faMaster i Margarita.\\x1flEnglish\\x1e14\\x1faThe master and Margarita /\\x1fcMikhail Bulgakov ; translated from the Russian by Michael Glenny.\n</code></pre></p>"},{"location":"manage_bibs/#get-current-oclc-numbers","title":"Get Current OCLC Numbers","text":"<p>The <code>bib_get_current_oclc_number</code> method allows users to retrieve the current control number of a WorldCat record. Occasionally, records identified as duplicates in WorldCat have been merged and in that case a local control number may not correctly refer to the WorldCat record. </p> <p>bib_get_current_oclc_number Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.bib_get_current_oclc_number(\"992611164\")\n    print(response.json())\n</code></pre> bib_get_current_oclc_number Response<pre><code>{\n  \"controlNumbers\": [\n    {\n      \"requested\": \"992611164\",\n      \"current\": \"321339\"\n    }\n  ]\n}\n</code></pre></p>"},{"location":"manage_bibs/#advanced-bib-record-functionality","title":"Advanced Bib Record Functionality","text":"<p>Several of the <code>/manage/bibs/</code> endpoints take a MARC record in the body of the request. When passing MARC records to any of these endpoints, users should ensure that the format passed in the <code>recordFormat</code> argument matches the format of the data passed in the request body using the <code>record</code> argument.</p>"},{"location":"manage_bibs/#match-bib-records","title":"Match Bib Records","text":"<p>Users can pass a bib record in MARCXML or MARC21 to the <code>bib_match</code> method and the web service will identify the best match for the record in WorldCat. The response will be a brief bib resource in JSON.</p> MARCXMLMARC21 bib_match Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_match(\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(response.json())\n</code></pre> bib_match Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.mrc\",\"rb\") as mrc_file:\n    for r in mrc_file:\n        mrc_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_match(\n            record=mrc_record, \n            recordFormat=\"application/marc\"\n        )\n        print(response.json())\n</code></pre> bib_match Response<pre><code>{\n  \"numberOfRecords\": 1, \n  \"briefRecords\": [\n    {\n      \"oclcNumber\": \"321339\", \n      \"title\": \"The master and Margarita\", \n      \"creator\": \"Mikhail Bulgakov\", \n      \"date\": \"\u00a91967\", \n      \"machineReadableDate\": \"1967\", \n      \"language\": \"eng\", \n      \"generalFormat\": \"Book\", \n      \"specificFormat\": \"PrintBook\", \n      \"edition\": \"1st U.S. ed\", \n      \"publisher\": \"Harper &amp; Row\", \n      \"publicationPlace\": \"New York\", \n      \"isbns\": [], \n      \"issns\": [], \n      \"mergedOclcNumbers\": [\n        \"68172169\", \n        \"977269772\", \n        \"992611164\", \n        \"1053636208\", \n        \"1086334687\", \n        \"1089359174\", \n        \"1126595016\", \n        \"1154557860\"\n      ], \n      \"catalogingInfo\": {\n        \"catalogingAgency\": \"DLC\", \n        \"catalogingLanguage\": \"eng\", \n        \"levelOfCataloging\": \"1\", \n        \"transcribingAgency\": \"DLC\"\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"manage_bibs/#create-bib-records","title":"Create Bib Records","text":"<p>Users can create new WorldCat records using the <code>bib_create</code> method. The web service will check if the record exists in WorldCat and create a new record if it does not. Users should pass passed a valid MARC record in MARCXML or MARC21 format in the body of the request. </p> <p>The response returned by the web service will contain the WorldCat record in the format specified in the <code>responseFormat</code> parameter with its newly added OCLC Number.</p> <p>Note</p> <p>It is recommended that users validate their records before trying to create new records in WorldCat in order to avoid errors. See <code>bib_validate</code> below.</p> MARCXMLMARC21 <p>bib_create Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_create(\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(xml_record)\n        print(response.content)\n</code></pre> bib_create Test Record<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000nam a2200000 a 4500&lt;/leader&gt;\n    &lt;controlfield tag=\"008\"&gt;240320s2024    nyua          000 0 eng d&lt;/controlfield&gt;\n    &lt;datafield tag=\"010\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;   12345678 &lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"040\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;NYP&lt;/subfield&gt;\n        &lt;subfield code=\"b\"&gt;eng&lt;/subfield&gt;\n        &lt;subfield code=\"c\"&gt;NYP&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"100\" ind1=\"0\" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;BookOps&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"245\" ind1=\"1\" ind2=\"0\"&gt;\n        &lt;subfield code=\"a\"&gt;Test Record&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"500\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;BOOKOPS-WORLDCAT DOCUMENTATION&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre> bib_create Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000nam a2200000 a 4500&lt;/leader&gt;\n    &lt;controlfield tag=\"001\"&gt;ocn123456789&lt;/controlfield&gt;\n    &lt;controlfield tag=\"008\"&gt;240320s2024    nyua          000 0 eng d&lt;/controlfield&gt;\n    &lt;datafield tag=\"010\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;   12345678 &lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"040\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;NYP&lt;/subfield&gt;\n        &lt;subfield code=\"b\"&gt;eng&lt;/subfield&gt;\n        &lt;subfield code=\"c\"&gt;NYP&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"100\" ind1=\"0\" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;BookOps&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"245\" ind1=\"1\" ind2=\"0\"&gt;\n        &lt;subfield code=\"a\"&gt;Test Record&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"500\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;BOOKOPS-WORLDCAT DOCUMENTATION&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p> <p>bib_create Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.mrc\",\"rb\") as mrc_file:\n    for r in mrc_file:\n        mrc_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_create(\n            record=mrc_record, \n            recordFormat=\"application/marc\"\n        )\n        print(mrc_record)\n        print(response.text)\n</code></pre> bib_create Test Record<pre><code>00266nam a2200097 a 4500008004100000010001700041040002200058100002700080245001600107500004500123\\u001E240320s2024    nyua          000 0 eng d\\u001E  \\u001Fa   63011276 \\u001E  \\u001FaNYP\\u001Fbeng\\u001FcNYP\\u001E0 \\u001FaBookOps\\u001E10\\u001FaTest Record\\u001E  \\u001FaBOOKOPS-WORLDCAT DOCUMENTATION\\u001E\\u001D    \n</code></pre> bib_create Response<pre><code>00291nam a2200109 a 4500001001300000008004100013010001700054040002200071100002700093245001600120500004500136\\u001Eocn123456789\\u001E240320s2024    nyua          000 0 eng d\\u001E  \\u001Fa   63011276 \\u001E  \\u001FaNYP\\u001Fbeng\\u001FcNYP\\u001E0 \\u001FaBookOps\\u001E10\\u001FaTest Record\\u001E  \\u001FaBOOKOPS-WORLDCAT DOCUMENTATION\\u001E\\u001D \n</code></pre></p>"},{"location":"manage_bibs/#replace-bib-records","title":"Replace Bib Records","text":"<p>The <code>bib_replace</code> method will retrieve a record in WorldCat and replace it with the record it is passed in the request body. If the record does not exist, a new WorldCat record will be created.</p> MARCXMLMARC21 bib_replace Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_replace(\n            oclcNumber=\"123456789\"\n            record=xml_record,\n            recordFormat=\"application/marcxml+xml\",\n        )\n</code></pre> bib_replace Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.mrc\",\"rb\") as mrc_file:\n    for r in mrc_file:\n        mrc_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_replace(\n            record=mrc_record, \n            recordFormat=\"application/marc\"\n        )\n</code></pre>"},{"location":"manage_bibs/#validate-bib-records","title":"Validate Bib Records","text":"<p>Users can first pass their MARC records to the <code>bib_validate</code> method in order to avoid parsing errors when creating or updating WorldCat records. This will check the formatting and quality of the bib record and return either errors identified in the record or a brief JSON response confirming that the record is valid.</p> MARCXMLMARC21 bib_validate Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_validate(\n            record=xml_record,\n            recordFormat=\"application/marcxml+xml\",\n            validationLevel=\"validateFull\",\n        )\n        print(response.json())\n</code></pre> bib_validate Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.mrc\",\"rb\") as mrc_file:\n    for r in mrc_file:\n        mrc_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_validate(\n            record=mrc_record,\n            recordFormat=\"application/marc\",\n            validationLevel=\"validateFull\",\n        )\n        print(response.json())\n</code></pre> bib_validate Response<pre><code>{\n    \"httpStatus\": \"OK\",\n    \"status\": {\n        \"summary\": \"VALID\",\n        \"description\": \"The provided Bib is valid\"\n    }\n}\n</code></pre>"},{"location":"manage_holdings/","title":"Manage Institution Holdings","text":"<p>Server responses are returned in JSON format for requests made to any <code>/manage/holdings/</code> endpoints. These responses can be accessed and parsed with the <code>.json()</code> method.</p>"},{"location":"manage_holdings/#get-institution-holdings-codes","title":"Get Institution Holdings Codes","text":"<p>The <code>holdings_get_codes</code> method retrieves an institution's holdings codes. The web service identifies the institution based on the data passed to the <code>WorldcatAccessToken</code>.</p> <p>holdings_get_codes Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.holdings_get_codes()\n    print(response.json())\n</code></pre> holdings_get_codes Response<pre><code>{\n  \"holdingLibraryCodes\": [\n    {\n      \"code\": \"Rodgers &amp; Hammerstein\",\n      \"name\": \"NYPH\"\n    },\n    {\n      \"code\": \"Schomburg Center\",\n      \"name\": \"NYP3\"\n    },\n    ]\n}\n</code></pre></p>"},{"location":"manage_holdings/#get-current-holdings","title":"Get Current Holdings","text":"<p>The <code>holdings_get_current</code> method retrieves the holding status of a requested record for the authenticated institution.</p> <p>holdings_get_current Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.holdings_get_current(oclcNumbers=123456789)\n    print(response.json())\n</code></pre> holdings_get_current Response<pre><code>{\n  \"holdings\": [\n    {\n      \"requestedControlNumber\": \"123456789\",\n      \"currentControlNumber\": \"123456789\",\n      \"institutionSymbol\": \"NYP\",\n      \"holdingSet\": true\n    }\n  ]\n}\n</code></pre></p>"},{"location":"manage_holdings/#set-and-unset-holdings","title":"Set and Unset Holdings","text":"<p>Users can set and/or unset holdings in WorldCat by passing an OCLC Number to the <code>holdings_set</code> and/or <code>holdings_unset</code> methods. </p> <p>Info</p> <p>In version 2.0 of the Metadata API, users are no longer able to set holdings on multiple records with one request. Users should now pass one OCLC Number per request to <code>holdings_set</code> and <code>holdings_unset</code>.</p> <p>Version 2.0 of the Metadata API provides new functionality to set and unset holdings in WorldCat by passing the Metadata API a MARC record in MARCXML or MARC21 format. The record must have an OCLC number in the 035 or 001 field in order to set holdings in WorldCat.</p> <p>Bookops-Worldcat supports this functionality with the <code>holdings_set_with_bib</code> and <code>holdings_unset_with_bib</code> methods which can be passed a MARC record in the body of the request in the same way that one would pass a record to a method that uses any of the <code>/manage/bibs/</code> endpoints.</p> holdings_setholdings_unsetholdings_set_with_bibholdings_unset_with_bib <p>holdings_set Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.holdings_set(oclcNumber=123456789)\n    print(response.json())\n</code></pre> holdings_set Response<pre><code>{\n  \"controlNumber\": \"123456789\",\n  \"requestedControlNumber\": \"123456789\",\n  \"institutionCode\": \"58122\",\n  \"institutionSymbol\": \"NYP\",\n  \"success\": true,\n  \"message\": \"Holding Updated Successfully\",\n  \"action\": \"Set Holdings\"\n}\n</code></pre></p> <p>holdings_unset Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.holdings_unset(oclcNumber=123456789)\n    print(response.json())\n</code></pre> holdings_unset Response<pre><code>{\n  \"controlNumber\": \"123456789\",\n  \"requestedControlNumber\": \"123456789\",\n  \"institutionCode\": \"58122\",\n  \"institutionSymbol\": \"NYP\",\n  \"success\": true,\n  \"message\": \"Holding Updated Successfully\",\n  \"action\": \"Unset Holdings\"\n}\n</code></pre></p> <p>holdings_set_with_bib Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.holdings_set_with_bib(\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(response.json())\n</code></pre> holdings_set_with_bib Response<pre><code>{\n  \"controlNumber\": \"123456789\",\n  \"requestedControlNumber\": \"123456789\",\n  \"institutionCode\": \"58122\",\n  \"institutionSymbol\": \"NYP\",\n  \"success\": true,\n  \"message\": \"Holding Updated Successfully\",\n  \"action\": \"Set Holdings\"\n}\n</code></pre></p> <p>holdings_unset_with_bib Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.holdings_unset_with_bib(\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(response.json())\n</code></pre> holdings_unset_with_bib Response<pre><code>{\n  \"controlNumber\": \"123456789\",\n  \"requestedControlNumber\": \"123456789\",\n  \"institutionCode\": \"58122\",\n  \"institutionSymbol\": \"NYP\",\n  \"success\": true,\n  \"message\": \"Holding Updated Successfully\",\n  \"action\": \"Unset Holdings\"\n}\n</code></pre></p>"},{"location":"search/","title":"Search WorldCat","text":"<p>Bookops-Worldcat provides functionality that allows users to search WorldCat for brief bibliographic resources, holdings data, and classification recommendations. </p> <p>Requests made to any <code>/search/</code> endpoints return server responses in JSON format. These responses can be accessed and parsed with the <code>.json()</code> method.</p>"},{"location":"search/#brief-bib-resources","title":"Brief Bib Resources","text":""},{"location":"search/#search-brief-bibs","title":"Search Brief Bibs","text":"<p>The <code>brief_bibs_search</code> method allows users to query WorldCat using WorldCat's bibliographic record indexes.</p> <p>The Metadata API many limiters that one can use to restrict query results. A full list of available parameters for the <code>brief_bibs_search</code> method is available in the API Documentation. Additional search examples are also available in the Advanced Search Functionality section of this page.</p> <p>Basic usage: brief_bibs_search Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.brief_bibs_search(\n        q=\"ti: My brilliant friend AND au: Ferrante, Elena\",\n        inCatalogLanguage=\"eng\",\n        itemSubType=\"book-printbook\",\n        orderBy=\"mostWidelyHeld\",\n        )\n    print(response.json())\n</code></pre> brief_bibs_search Response<pre><code>{\n  \"numberOfRecords\": 79, \n  \"briefRecords\": [\n    {\n      \"oclcNumber\": \"778419313\", \n      \"title\": \"My brilliant friend\", \n      \"creator\": \"Elena Ferrante\", \n      \"date\": \"2012\", \n      \"machineReadableDate\": \"2012\", \n      \"language\": \"eng\", \n      \"generalFormat\": \"Book\", \n      \"specificFormat\": \"PrintBook\", \n      \"publisher\": \"Europa Editions\", \n      \"publicationPlace\": \"New York, New York\", \n      \"isbns\": [\n        \"9781609450786\", \n        \"1609450787\"\n      ], \n      \"mergedOclcNumbers\": [\n        \"811639683\", \n        \"818678733\", \n        \"824701856\", \n        \"829903719\", \n        \"830036387\", \n        \"1302347443\"\n      ], \n      \"catalogingInfo\": {\n        \"catalogingAgency\": \"BTCTA\", \n        \"catalogingLanguage\": \"eng\", \n        \"levelOfCataloging\": \" \", \n        \"transcribingAgency\": \"BTCTA\"\n      }\n    },\n  ]\n}\n</code></pre></p>"},{"location":"search/#get-brief-bibs","title":"Get Brief Bibs","text":"<p>Users can retrieve a brief bib resource for a known item by passing the OCLC Number for the resource to the <code>brief_bibs_get</code> method.</p> <p>Basic usage: brief_bibs_get Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.brief_bibs_get(778419313)\n    print(response.json())\n</code></pre> brief_bibs_get Response<pre><code>{\n  \"oclcNumber\": \"778419313\",\n  \"title\": \"My brilliant friend\",\n  \"creator\": \"Elena Ferrante\",\n  \"date\": \"2012\",\n  \"machineReadableDate\": \"2012\",\n  \"language\": \"eng\",\n  \"generalFormat\": \"Book\",\n  \"specificFormat\": \"PrintBook\",\n  \"publisher\": \"Europa Editions\",\n  \"publicationPlace\": \"New York, New York\",\n  \"isbns\": [\n    \"9781609450786\",\n    \"1609450787\"\n  ],\n  \"mergedOclcNumbers\": [\n    \"811639683\",\n    \"818678733\",\n    \"824701856\",\n    \"829903719\",\n    \"830036387\",\n    \"1302347443\"\n  ],\n  \"catalogingInfo\": {\n    \"catalogingAgency\": \"BTCTA\",\n    \"catalogingLanguage\": \"eng\",\n    \"levelOfCataloging\": \" \",\n    \"transcribingAgency\": \"BTCTA\"\n  }\n}\n</code></pre></p>"},{"location":"search/#get-brief-bibs-for-other-editions","title":"Get Brief Bibs for Other Editions","text":"<p>Users can retrieve brief bib resources for other editions of a title by passing an OCLC Number to the <code>brief_bibs_get_other_editions</code> method.</p> <p>Basic usage: brief_bibs_get_other_editions Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.brief_bibs_get_other_editions(\n        oclcNumber=\"321339\", \n        itemSubType=\"book-digital\", \n        inCatalogLanguage=\"eng\", \n        orderBy=\"bestMatch\"\n    )\n    print(response.json())\n</code></pre> brief_bibs_get_other_editions Response<pre><code>{\n  \"numberOfRecords\": 15, \n  \"briefRecords\": [\n    {\n      \"oclcNumber\": \"859323121\", \n      \"title\": \"My brilliant friend. book one : childhood, adolescence\", \n      \"creator\": \"Elena Ferrante\", \n      \"date\": \"2012\", \n      \"machineReadableDate\": \"2012\", \n      \"language\": \"eng\", \n      \"generalFormat\": \"Book\", \n      \"specificFormat\": \"Digital\", \n      \"publisher\": \"Europa Editions\", \n      \"publicationPlace\": \"New York\", \n      \"isbns\": [\n        \"9781609458638\", \n        \"160945863X\", \n        \"9781787701151\", \n        \"1787701158\"\n      ], \n      \"mergedOclcNumbers\": [\n        \"883320518\", \n        \"907236505\", \n        \"1030261956\", \n        \"1031563997\", \n        \"1032076035\", \n        \"1052184907\", \n        \"1124391373\", \n        \"1155208541\", \n        \"1191036210\", \n        \"1196835133\"\n      ], \n      \"catalogingInfo\": {\n        \"catalogingAgency\": \"TEFOD\", \n        \"catalogingLanguage\": \"eng\", \n        \"levelOfCataloging\": \" \", \n        \"transcribingAgency\": \"TEFOD\"\n      }\n    }, \n  ]\n}\n</code></pre></p>"},{"location":"search/#member-holdings","title":"Member Holdings","text":"<p>Users can query WorldCat for holdings data and return holdings summaries using Bookops-Worldcat and the Metadata API. Requests made using the <code>summary_holdings_search</code> and <code>shared_print_holdings_search</code> methods return brief bib resources with the holdings summaries in their responses, while requests made using the <code>summary_holdings_get</code> method only return holdings summaries. </p>"},{"location":"search/#get-holdings-summary","title":"Get Holdings Summary","text":"<p>Users can retrieve a summary of holdings data from WorldCat for a known item by passing an OCLC Number to the <code>summary_holdings_get</code> method. </p> <p>Basic Usage: Basic summary_holdings_get Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.summary_holdings_get(\"778419313\")\n    print(response.json())\n</code></pre> Basic summary_holdings_get Response<pre><code>{\n  \"totalHoldingCount\": 1626,\n  \"totalSharedPrintCount\": 5,\n  \"totalEditions\": 1\n}\n</code></pre> Users can limit their search results to specific institutions, library types, or geographic areas.</p> <p>Limit holdings search by state: summary_holdings_get Request with heldInState limiter<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n  response = session.summary_holdings_get(\"778419313\", heldInState=\"US-NY\")\n  print(response.json())\n</code></pre> summary_holdings_get Response with heldInState limiter<pre><code>{\n  \"totalHoldingCount\": 56,\n  \"totalSharedPrintCount\": 0\n}\n</code></pre></p>"},{"location":"search/#search-general-holdings","title":"Search General Holdings","text":"<p>Users can pass either an OCLC Number, ISBN, or ISSN to the <code>summary_holdings_search</code> method to search for bibliographic resources their holdings.</p> <p>Basic Usage: summary_holdings_search Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.summary_holdings_search(\n        isbn=\"9781609458638\", \n        heldInCountry=\"US\"\n    )\n    print(response.json())\n</code></pre> summary_holdings_search Response<pre><code>{\n  \"numberOfRecords\": 1, \n  \"briefRecords\": [\n    {\n      \"oclcNumber\": \"859323121\", \n      \"title\": \"My brilliant friend. book one : childhood, adolescence\", \n      \"creator\": \"Elena Ferrante\", \n      \"date\": \"2012\", \n      \"machineReadableDate\": \"2012\", \n      \"language\": \"eng\", \n      \"generalFormat\": \"Book\", \n      \"specificFormat\": \"Digital\", \n      \"publisher\": \"Europa Editions\", \n      \"publicationPlace\": \"New York\", \n      \"isbns\": [\n        \"9781609458638\", \n        \"160945863X\", \n        \"9781787701151\", \n        \"1787701158\"\n      ], \n      \"mergedOclcNumbers\": [\n        \"883320518\", \n        \"907236505\", \n        \"1030261956\", \n        \"1031563997\", \n        \"1032076035\", \n        \"1052184907\", \n        \"1124391373\", \n        \"1155208541\", \n        \"1191036210\", \n        \"1196835133\"\n      ], \n      \"catalogingInfo\": {\n        \"catalogingAgency\": \"TEFOD\", \n        \"catalogingLanguage\": \"eng\", \n        \"levelOfCataloging\": \" \", \n        \"transcribingAgency\": \"TEFOD\"\n      }, \n      \"institutionHolding\": {\n        \"totalHoldingCount\": 159\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"search/#search-shared-print-holdings","title":"Search Shared Print Holdings","text":"<p>To search just for holdings with retention commitments, users can pass an OCLC Number, ISBN, or ISSN to the <code>shared_print_holdings_search</code> method. The response includes the brief bib resource, a summary of shared print holdings for that resource, and data about the institutions with retention commitments for the resource.  </p> <p>shared_print_holdings_search Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n  response = session.shared_print_holdings_search(321339)\n  print(response.json())\n</code></pre> shared_print_holdings_search Response<pre><code>{\n  \"numberOfRecords\": 1, \n  \"briefRecords\": [\n    {\n      \"oclcNumber\": \"778419313\", \n      \"title\": \"My brilliant friend\", \n      \"creator\": \"Elena Ferrante\", \n      \"date\": \"2012\", \n      \"machineReadableDate\": \"2012\", \n      \"language\": \"eng\", \n      \"generalFormat\": \"Book\", \n      \"specificFormat\": \"PrintBook\", \n      \"publisher\": \"Europa Editions\", \n      \"publicationPlace\": \"New York, New York\", \n      \"isbns\": [\n        \"9781609450786\", \n        \"1609450787\"\n      ], \n      \"mergedOclcNumbers\": [\n        \"811639683\", \n        \"818678733\", \n        \"824701856\", \n        \"829903719\", \n        \"830036387\", \n        \"1302347443\"\n      ], \n      \"catalogingInfo\": {\n        \"catalogingAgency\": \"BTCTA\", \n        \"catalogingLanguage\": \"eng\", \n        \"levelOfCataloging\": \" \", \n        \"transcribingAgency\": \"BTCTA\"\n      }, \n      \"institutionHolding\": {\n        \"totalHoldingCount\": 5, \n        \"briefHoldings\": [\n          {\n            \"country\": \"US\", \n            \"state\": \"US-ME\", \n            \"oclcSymbol\": \"CBY\", \n            \"registryId\": 1233, \n            \"institutionNumber\": 90, \n            \"institutionName\": \"Colby College\", \n            \"alsoCalled\": \"Miller Library\", \n            \"hasOPACLink\": True, \n            \"self\": \"https://worldcat.org/oclc-config/institution/data/1233\", \n            \"address\": {\n              \"street1\": \"Miller Library\", \n              \"street2\": \"5124 Mayflower Hill\", \n              \"city\": \"Waterville\",\n              \"state\": \"US-ME\",\n              \"postalCode\": \"04901-8851\", \n              \"country\": \"US\", \n              \"lat\": 44.564102, \n              \"lon\": -69.66333\n            }, \n            \"institutionType\": \"ACADEMIC\"\n          }\n        ]\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"search/#classification-recommendations","title":"Classification Recommendations","text":"<p>Version 2.0 of the Metadata API added a new endpoint that users can query to retrieve classification recommendations for known items. With Bookops-Worldcat, users can pass an OCLC Number to the <code>bib_get_classification</code> method and the response will contain the most popular classification for that item in both Dewey and LC. </p> <p>bib_get_classification Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n  response = session.bib_get_classification(\"778419313\")\n  print(response.json())\n</code></pre> bib_get_classification Response<pre><code>{\n  \"dewey\": {\n    \"mostPopular\": [\n      \"853/.92\"\n    ]\n  },\n  \"lc\": {\n    \"mostPopular\": [\n      \"PQ4866.E6345 A8113 2012\"\n    ]\n  }\n}\n</code></pre></p>"},{"location":"search/#advanced-search-functionality","title":"Advanced Search Functionality","text":"<p>Info</p> <p>While most arguments passed to <code>/search/</code> endpoints (such as <code>brief_bibs_search</code>, <code>local_bibs_search</code>, and <code>summary_holdings_search</code>) are joined using the 'AND' operator, when both <code>itemType</code> and <code>itemSubType</code> are used in a query, they are joined using the 'OR' operator. </p>"},{"location":"search/#keyword-and-fielded-queries","title":"Keyword and Fielded Queries","text":"<p>The Metadata API provides robust search functionality for bib resources. In addition to a flexible query string that supports keyword and fielded searches, it is possible to set further limits using various elements such as item type, language, and publishing date. Users can specify the order of returned records by using the <code>orderBy</code> argument. </p> <p>The query syntax is case-insensitive and allows keyword and phrase search (use quotation marks around phrases), boolean operators (AND, OR, NOT), wildcards (# - single character, ? - any number of additional characters), and truncation (use * character).</p>"},{"location":"search/#advanced-search-for-brief-bib-resources","title":"Advanced Search for Brief Bib Resources","text":"<p>More about the query syntax available for brief bib resource searches can be found in OCLC's documentation.</p> <p>Two equivalent <code>brief_bibs_search</code> examples with item type and language limiters:</p> Keyword SearchFielded Search <pre><code>  response = session.brief_bibs_search(\n      q=\"ti=my brilliant friend\",\n        itemType=\"video\",\n        inLanguage=\"eng\",\n        orderBy=\"bestMatch\",\n      )\n  print(response.json())\n</code></pre> <pre><code>  response = session.brief_bibs_search(\n      q='ti=\"my brilliant friend\" AND x0: video AND ln: eng',\n      orderBy=\"bestMatch\"\n      )\n  print(response.json())\n</code></pre> <pre><code>{\n  \"numberOfRecords\": 37, \n  \"briefRecords\": [\n    {\n      \"oclcNumber\": \"1091307669\", \n      \"title\": \"My Brilliant Friend\",\n      \"date\": \"2019\", \n      \"machineReadableDate\": \"2019\", \n      \"language\": \"eng\", \n      \"generalFormat\": \"Video\", \n      \"specificFormat\": \"DVD\", \n      \"edition\": \"Widescreen ed\", \n      \"publisher\": \"Home Box Office\", \n      \"publicationPlace\": \"[United States]\", \n      \"catalogingInfo\": {\n        \"catalogingAgency\": \"CNWPU\", \n        \"catalogingLanguage\": \"eng\", \n        \"levelOfCataloging\": \"M\", \n        \"transcribingAgency\": \"CNWPU\"\n      }\n    },\n  ]\n}\n</code></pre>"},{"location":"search/#advanced-search-for-local-bib-resources","title":"Advanced Search for Local Bib Resources","text":"<p>The <code>local_bibs_search</code> method also allows for fielded queries. The available indexes are slightly different from those available for brief bib resource searches. For more information about the query syntax for local bib resources see OCLC's documentation.</p> <p><code>local_bibs_search</code> with language and date created as MARC limiters: local_bibs_search Fielded Query<pre><code>session.local_bibs_search(q=\"ti=My Local Bib Record AND dc=2024? AND ln=eng\")\n</code></pre></p>"},{"location":"start/","title":"Get Started","text":""},{"location":"start/#authentication-and-authorization","title":"Authentication and Authorization","text":"<p>An Access Token can be obtained by passing credential parameters into the <code>WorldcatAccessToken</code> object. This will authenticate the user against OCLC's Authorization Server and allow the user to send requests to the OCLC Metadata API. </p> Get Access Token<pre><code>from bookops_worldcat import WorldcatAccessToken\ntoken = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=\"WorldCatMetadataAPI\",\n)\nprint(token)\n#&gt;\"access_token: 'tk_Yebz4BpEp9dAsghA7KpWx6dYD1OZKWBlHjqW', expires_at: '2024-01-01 17:19:58Z'\"\nprint(token.is_expired())\n#&gt;False\n</code></pre> <p>This <code>token</code> object can be passed directly into <code>MetadataSession</code> to authorize requests to the Metadata API web service:</p> Open MetadataSession<pre><code>from bookops_worldcat import MetadataSession\n\nsession = MetadataSession(authorization=token)\nsession.brief_bibs_get(\"321339\")\n</code></pre>"},{"location":"start/#metadatasession-as-context-manager","title":"MetadataSession as Context Manager","text":"<p>A <code>MetadataSession</code> can also be used as a context manager. This allows users to use the same parameters and configuration for each request they send to the Metadata API and to ensure that the session is closed after their code has finished running. </p> <p><code>MetadataSession</code> inherits all <code>requests.Session</code> methods and properties (see Advanced Usage &gt; MetadataSession for more information). </p> <p>Metadata Session as Context Manager<pre><code>with MetadataSession(authorization=token) as session:\n    response = session.brief_bibs_get(\"321339\")\n</code></pre> A <code>MetadataSession</code> has methods that allow users to interact with each endpoint of the OCLC Metadata API. See the tabs on the left of this page for more information about <code>MetadataSession</code> methods and examples of their usage.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Work in Progress</p> <p>TBD</p>"},{"location":"api/authorize/","title":"bookops_worldcat.authorize","text":"<p>This module provides means to authenticate and obtain a WorldCat access token.</p>"},{"location":"api/authorize/#bookops_worldcat.authorize.WorldcatAccessToken","title":"WorldcatAccessToken","text":"<pre><code>WorldcatAccessToken(\n    key: str,\n    secret: str,\n    scopes: str,\n    agent: str = \"\",\n    timeout: Optional[\n        Union[\n            int, float, Tuple[int, int], Tuple[float, float]\n        ]\n    ] = None,\n)\n</code></pre> <p>Requests Worldcat access token. Authenticates and authorizes using Client Credentials Grant. Does not support Explicit Authorization Code and Refresh Token flows. Token with correctly bonded scopes can then be passed into a session of particular web service to authorize requests for resources. More on OCLC's client credentials grant: https://www.oclc.org/developer/api/keys/oauth/client-credentials-grant.en.html</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>your WSKey public client_id</p> required <code>secret</code> <code>str</code> <p>your WSKey secret</p> required <code>scopes</code> <code>str</code> <p>request scopes for the access token as a string,                     separate different scopes with space                     users with WSKeys set up to act as multiple institutions                     should provide scope and registryID in the format                     \"{scope} context:{registryID}\"                     examples:                         single institution WSKey:                             \"WorldCatMetadataAPI\"                         multi-institution WSKey:                             \"WorldCatMetadataAPI context:00001\"</p> required <code>agent</code> <code>str</code> <p>\"User-agent\" parameter to be passed in the request                     header; usage strongly encouraged</p> <code>''</code> <code>timeout</code> <code>Optional[Union[int, float, Tuple[int, int], Tuple[float, float]]]</code> <p>how long to wait for server to send data before                     giving up; default value is 3 seconds</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bookops_worldcat import WorldcatAccessToken\n&gt;&gt;&gt; token = WorldcatAccessToken(\n        key=\"my_WSKey_client_id\",\n        secret=\"my_WSKey_secret\",\n        scopes=\"WorldCatMetadataAPI\",\n        agent=\"my_app/1.0.0\")\n&gt;&gt;&gt; token.token_str\n\"tk_Yebz4BpEp9dAsghA7KpWx6dYD1OZKWBlHjqW\"\n&gt;&gt;&gt; token.is_expired()\nFalse\n&gt;&gt;&gt; token.server_response.json()\n{\"token_token\": \"tk_Yebz4BpEp9dAsghA7KpWx6dYD1OZKWBlHjqW\",\n \"token_type\": \"bearer\",\n \"expires_in\": \"1199\",\n \"principalID\": \"\",\n \"principalIDNS\": \"\",\n \"scopes\": \"WorldCatMetadataAPI\",\n \"contextInstitutionId\": \"00001\",\n \"expires_at\": \"2020-08-23 18:45:29Z\"}\n&gt;&gt;&gt; token.server_response.request.headers\n{\"User-Agent\": \"my_app/1.0.0\",\n \"Accept-Encoding\": \"gzip, deflate\",\n \"Accept\": \"application/json\",\n \"Connection\": \"keep-alive\",\n \"Content-Length\": \"67\",\n \"Content-Type\": \"application/x-www-form-urlencoded\",\n \"Authorization\": \"Basic encoded_authorization_here=\"}\n</code></pre> Source code in <code>bookops_worldcat/authorize.py</code> <pre><code>def __init__(\n    self,\n    key: str,\n    secret: str,\n    scopes: str,\n    agent: str = \"\",\n    timeout: Optional[\n        Union[int, float, Tuple[int, int], Tuple[float, float]]\n    ] = None,\n) -&gt; None:\n    \"\"\"Constructor\"\"\"\n\n    self.agent = agent\n    self.grant_type = \"client_credentials\"\n    self.key = key\n    self.oauth_server = \"https://oauth.oclc.org\"\n    self.scopes = scopes\n    self.secret = secret\n    self.server_response: Optional[requests.Response] = None\n    self.timeout = timeout\n    self.token_expires_at: Optional[datetime.datetime] = None\n    self.token_str = \"\"\n    self.token_type = \"\"\n\n    # default bookops-worldcat request header\n    if isinstance(self.agent, str):\n        if not self.agent.strip():\n            self.agent = f\"{__title__}/{__version__}\"\n    else:\n        raise TypeError(\"Argument 'agent' must be a string.\")\n\n    # ensure passed arguments are valid\n    if isinstance(self.key, str):\n        if not self.key.strip():\n            raise ValueError(\"Argument 'key' cannot be an empty string.\")\n    else:\n        raise TypeError(\"Argument 'key' must be a string.\")\n\n    if isinstance(self.secret, str):\n        if not self.secret.strip():\n            raise ValueError(\"Argument 'secret' cannot be an empty string.\")\n    else:\n        raise TypeError(\"Argument 'secret' must be a string.\")\n\n    # validate passed scopes\n    if isinstance(self.scopes, str):\n        if not self.scopes.strip():\n            raise ValueError(\"Argument 'scopes' cannot be an empty string.\")\n    else:\n        raise TypeError(\"Argument 'scopes' must a string.\")\n    self.scopes = self.scopes.strip()\n\n    # assign default value for timout\n    if not self.timeout:\n        self.timeout = (3, 3)\n\n    # initiate request\n    self._request_token()\n</code></pre>"},{"location":"api/authorize/#bookops_worldcat.authorize.WorldcatAccessToken.is_expired","title":"is_expired","text":"<pre><code>is_expired() -&gt; bool\n</code></pre> <p>Checks if the access token is expired.</p> <p>Returns:</p> Type Description <code>bool</code> <p>bool</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.is_expired()\nFalse\n</code></pre> Source code in <code>bookops_worldcat/authorize.py</code> <pre><code>def is_expired(self) -&gt; bool:\n    \"\"\"\n    Checks if the access token is expired.\n\n    Returns:\n        bool\n\n    Examples:\n        &gt;&gt;&gt; token.is_expired()\n        False\n\n    \"\"\"\n    if isinstance(self.token_expires_at, datetime.datetime):\n        if self.token_expires_at &lt; datetime.datetime.now(datetime.timezone.utc):\n            return True\n        else:\n            return False\n    else:\n        raise TypeError(\n            \"Attribute 'WorldcatAccessToken.token_expires_at' is of invalid type. \"\n            \"Expected `datetime.datetime` object.\"\n        )\n</code></pre>"},{"location":"api/errors/","title":"bookops_worldcat.errors","text":"<p>This module contains the set of bookops_worldcat exceptions.</p>"},{"location":"api/errors/#bookops_worldcat.errors.BookopsWorldcatError","title":"BookopsWorldcatError","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for exceptions in this module.</p>"},{"location":"api/errors/#bookops_worldcat.errors.InvalidOclcNumber","title":"InvalidOclcNumber","text":"<p>             Bases: <code>BookopsWorldcatError</code></p> <p>Exception raised when an invalid OCLC record number is encountered</p>"},{"location":"api/errors/#bookops_worldcat.errors.WorldcatAuthorizationError","title":"WorldcatAuthorizationError","text":"<p>             Bases: <code>BookopsWorldcatError</code></p> <p>Exception raised when WorldCat access token is not obtained</p>"},{"location":"api/errors/#bookops_worldcat.errors.WorldcatRequestError","title":"WorldcatRequestError","text":"<p>             Bases: <code>BookopsWorldcatError</code></p> <p>Exceptions raised on HTTP errors returned by web service</p>"},{"location":"api/metadata_api/","title":"bookops_worldcat.metadata_api","text":"<p>This module provides MetadataSession class for requests to WorldCat Metadata API.</p>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession","title":"MetadataSession","text":"<pre><code>MetadataSession(\n    authorization: WorldcatAccessToken,\n    agent: Optional[str] = None,\n    timeout: Union[\n        int,\n        float,\n        Tuple[int, int],\n        Tuple[float, float],\n        None,\n    ] = None,\n    totalRetries: int = 0,\n    backoffFactor: float = 0,\n    statusForcelist: Optional[List[int]] = None,\n    allowedMethods: Optional[List[str]] = None,\n)\n</code></pre> <p>             Bases: <code>WorldcatSession</code></p> <p>OCLC Metadata API wrapper session. Inherits <code>requests.Session</code> methods</p> <p>Parameters:</p> Name Type Description Default <code>authorization</code> <code>WorldcatAccessToken</code> <p>WorldcatAccessToken object</p> required <code>agent</code> <code>Optional[str]</code> <p>\"User-agent\" parameter to be passed in the request                     header; usage strongly encouraged</p> <code>None</code> <code>timeout</code> <code>Union[int, float, Tuple[int, int], Tuple[float, float], None]</code> <p>how long to wait for server to send data before                     giving up; default value is 5 seconds</p> <code>None</code> <code>totalRetries</code> <code>int</code> <p>optional number of times to retry a request that                     failed or timed out. if totalRetries argument is                     not passed, any arguments passed to                     backoffFactor, statusForcelist, and                     allowedMethods will be ignored. default is 0</p> <code>0</code> <code>backoffFactor</code> <code>float</code> <p>if totalRetries is not 0, the backoff                     factor as a float to use to calculate amount of                     time session will sleep before attempting request                     again. default is 0</p> <code>0</code> <code>statusForcelist</code> <code>Optional[List[int]]</code> <p>if totalRetries is not 0, a list of HTTP                     status codes to automatically retry requests on.                     if not specified, failed requests with status codes                     413, 429, and 503 will be retried up to number of                     totalRetries.                     example: [500, 502, 503, 504]</p> <code>None</code> <code>allowedMethods</code> <code>Optional[List[str]]</code> <p>if totalRetries is not 0, set of HTTP methods that                     requests should be retried on. if not specified,                     requests using any HTTP method verbs will be                     retried. example: [\"GET\", \"POST\"]</p> <code>None</code> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def __init__(\n    self,\n    authorization: WorldcatAccessToken,\n    agent: Optional[str] = None,\n    timeout: Union[int, float, Tuple[int, int], Tuple[float, float], None] = None,\n    totalRetries: int = 0,\n    backoffFactor: float = 0,\n    statusForcelist: Optional[List[int]] = None,\n    allowedMethods: Optional[List[str]] = None,\n) -&gt; None:\n    \"\"\"Initializes MetadataSession\n\n    Args:\n        authorization:          WorldcatAccessToken object\n        agent:                  \"User-agent\" parameter to be passed in the request\n                                header; usage strongly encouraged\n        timeout:                how long to wait for server to send data before\n                                giving up; default value is 5 seconds\n        totalRetries:           optional number of times to retry a request that\n                                failed or timed out. if totalRetries argument is\n                                not passed, any arguments passed to\n                                backoffFactor, statusForcelist, and\n                                allowedMethods will be ignored. default is 0\n        backoffFactor:          if totalRetries is not 0, the backoff\n                                factor as a float to use to calculate amount of\n                                time session will sleep before attempting request\n                                again. default is 0\n        statusForcelist:        if totalRetries is not 0, a list of HTTP\n                                status codes to automatically retry requests on.\n                                if not specified, failed requests with status codes\n                                413, 429, and 503 will be retried up to number of\n                                totalRetries.\n                                example: [500, 502, 503, 504]\n        allowedMethods:         if totalRetries is not 0, set of HTTP methods that\n                                requests should be retried on. if not specified,\n                                requests using any HTTP method verbs will be\n                                retried. example: [\"GET\", \"POST\"]\n    \"\"\"\n    super().__init__(\n        authorization,\n        agent=agent,\n        timeout=timeout,\n        totalRetries=totalRetries,\n        backoffFactor=backoffFactor,\n        statusForcelist=statusForcelist,\n        allowedMethods=allowedMethods,\n    )\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.bib_create","title":"bib_create","text":"<pre><code>bib_create(\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Create a bib record in OCLC if it does not already exist. Uses /manage/bibs endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>Union[str, bytes, BinaryIO]</code> <p>MARC record to be created</p> required <code>recordFormat</code> <code>str</code> <p>format of MARC record; options:                     'application/marcxml+xml'; 'application/marc'</p> required <code>responseFormat</code> <code>str</code> <p>format of returned record; options:                     'application/marcxml+xml', 'application/marc'                     default is 'application/marcxml+xml'</p> <code>'application/marcxml+xml'</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def bib_create(\n    self,\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Create a bib record in OCLC if it does not already exist.\n    Uses /manage/bibs endpoint.\n\n    Args:\n        record:                 MARC record to be created\n        recordFormat:           format of MARC record; options:\n                                'application/marcxml+xml'; 'application/marc'\n        responseFormat:         format of returned record; options:\n                                'application/marcxml+xml', 'application/marc'\n                                default is 'application/marcxml+xml'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_bibs_create()\n    header = {\n        \"Accept\": responseFormat,\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"POST\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.bib_get","title":"bib_get","text":"<pre><code>bib_get(\n    oclcNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Send a GET request for a full bibliographic resource. Uses /manage/bibs/{oclcNumber} endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumber</code> <code>Union[int, str]</code> <p>OCLC bibliographic record number; can be an                     integer or string with or without OCLC Number                     prefix</p> required <code>responseFormat</code> <code>str</code> <p>format of returned record, options:                     'application/marcxml+xml', 'application/marc',                     default is 'application/marcxml+xml'</p> <code>'application/marcxml+xml'</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def bib_get(\n    self,\n    oclcNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Send a GET request for a full bibliographic resource.\n    Uses /manage/bibs/{oclcNumber} endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer or string with or without OCLC Number\n                                prefix\n        responseFormat:         format of returned record, options:\n                                'application/marcxml+xml', 'application/marc',\n                                default is 'application/marcxml+xml'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_manage_bibs(oclcNumber)\n    header = {\"Accept\": responseFormat}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.bib_get_classification","title":"bib_get_classification","text":"<pre><code>bib_get_classification(\n    oclcNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given an OCLC number, retrieve classification recommendations for the bib record. Uses /search/classification-bibs/{oclcNumber} endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumber</code> <code>Union[int, str]</code> <p>OCLC bibliographic record number; can be an                     integer or string with or without OCLC Number                     prefix</p> required <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def bib_get_classification(\n    self,\n    oclcNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given an OCLC number, retrieve classification recommendations for the bib\n    record.\n    Uses /search/classification-bibs/{oclcNumber} endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer or string with or without OCLC Number\n                                prefix\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_classification_bibs(oclcNumber)\n    header = {\"Accept\": \"application/json\"}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.bib_get_current_oclc_number","title":"bib_get_current_oclc_number","text":"<pre><code>bib_get_current_oclc_number(\n    oclcNumbers: Union[str, List[Union[str, int]]],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given one or more OCLC Numbers, retrieve current OCLC numbers. Uses /manage/bibs/current endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumbers</code> <code>Union[str, List[Union[str, int]]]</code> <p>string or list containing one or more OCLC numbers                     to be checked; numbers can be integers or strings                     with or without OCLC Number prefix;                     if str, the numbers must be separated by a comma</p> required <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def bib_get_current_oclc_number(\n    self,\n    oclcNumbers: Union[str, List[Union[str, int]]],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given one or more OCLC Numbers, retrieve current OCLC numbers.\n    Uses /manage/bibs/current endpoint.\n\n    Args:\n        oclcNumbers:            string or list containing one or more OCLC numbers\n                                to be checked; numbers can be integers or strings\n                                with or without OCLC Number prefix;\n                                if str, the numbers must be separated by a comma\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n\n    vetted_numbers = verify_oclc_numbers(oclcNumbers)\n\n    header = {\"Accept\": \"application/json\"}\n    url = self._url_manage_bibs_current_oclc_number()\n    payload = {\"oclcNumbers\": \",\".join(vetted_numbers)}\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.bib_match","title":"bib_match","text":"<pre><code>bib_match(\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given a bib record in MARC21 or MARCXML identify the best match in WorldCat. Record must contain at minimum an 008 and 245. Response contains number of potential matches in numberOfRecords and best match in briefRecords. Uses /manage/bibs/match endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>Union[str, bytes, BinaryIO]</code> <p>MARC record to be matched</p> required <code>recordFormat</code> <code>str</code> <p>format of MARC record, options:                     'application/marcxml+xml', 'application/marc'</p> required <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def bib_match(\n    self,\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given a bib record in MARC21 or MARCXML identify the best match in WorldCat.\n    Record must contain at minimum an 008 and 245. Response contains number of\n    potential matches in numberOfRecords and best match in briefRecords.\n    Uses /manage/bibs/match endpoint.\n\n    Args:\n        record:                 MARC record to be matched\n        recordFormat:           format of MARC record, options:\n                                'application/marcxml+xml', 'application/marc'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_bibs_match()\n    header = {\n        \"Accept\": \"application/json\",\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"POST\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.bib_replace","title":"bib_replace","text":"<pre><code>bib_replace(\n    oclcNumber: Union[int, str],\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given an OCLC number and MARC record, find record in WorldCat and replace it. If the record does not exist in WorldCat, a new bib record will be created. Uses /manage/bibs/{oclcNumber} endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumber</code> <code>Union[int, str]</code> <p>OCLC bibliographic record number; can be an                     integer or string with or without OCLC Number                     prefix</p> required <code>record</code> <code>Union[str, bytes, BinaryIO]</code> <p>MARC record to replace existing WorldCat record</p> required <code>recordFormat</code> <code>str</code> <p>format of MARC record, options:                     'application/marcxml+xml', 'application/marc'</p> required <code>responseFormat</code> <code>str</code> <p>format of returned record; options:                     'application/marcxml+xml', 'application/marc'                     default is 'application/marcxml+xml'</p> <code>'application/marcxml+xml'</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def bib_replace(\n    self,\n    oclcNumber: Union[int, str],\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given an OCLC number and MARC record, find record in WorldCat and replace it.\n    If the record does not exist in WorldCat, a new bib record will be created.\n    Uses /manage/bibs/{oclcNumber} endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer or string with or without OCLC Number\n                                prefix\n        record:                 MARC record to replace existing WorldCat record\n        recordFormat:           format of MARC record, options:\n                                'application/marcxml+xml', 'application/marc'\n        responseFormat:         format of returned record; options:\n                                'application/marcxml+xml', 'application/marc'\n                                default is 'application/marcxml+xml'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_manage_bibs(oclcNumber)\n    header = {\n        \"Accept\": responseFormat,\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"PUT\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.bib_validate","title":"bib_validate","text":"<pre><code>bib_validate(\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    validationLevel: str = \"validateFull\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given a bib record, validate that record conforms to MARC standards. Uses /manage/bibs/validate/{validationLevel} endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>Union[str, bytes, BinaryIO]</code> <p>MARC record to be validated</p> required <code>recordFormat</code> <code>str</code> <p>format of MARC record, options:                     'application/marcxml+xml', 'application/marc'</p> required <code>validationLevel</code> <code>str</code> <p>Level at which to validate records                     available values: 'validateFull', 'validateAdd',                     'validateReplace'                     default is 'validateFull'</p> <code>'validateFull'</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def bib_validate(\n    self,\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    validationLevel: str = \"validateFull\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given a bib record, validate that record conforms to MARC standards.\n    Uses /manage/bibs/validate/{validationLevel} endpoint.\n\n    Args:\n        record:                 MARC record to be validated\n        recordFormat:           format of MARC record, options:\n                                'application/marcxml+xml', 'application/marc'\n        validationLevel:        Level at which to validate records\n                                available values: 'validateFull', 'validateAdd',\n                                'validateReplace'\n                                default is 'validateFull'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    if validationLevel not in [\"validateFull\", \"validateAdd\", \"validateReplace\"]:\n        raise ValueError(\n            \"Invalid argument 'validationLevel'.\"\n            \"Must be either 'validateFull', 'validateAdd', or 'validateReplace'\"\n        )\n\n    url = self._url_manage_bibs_validate(validationLevel)\n    header = {\n        \"Accept\": \"application/json\",\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\n        \"POST\",\n        url,\n        data=record,\n        headers=header,\n        hooks=hooks,\n    )\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.brief_bibs_get","title":"brief_bibs_get","text":"<pre><code>brief_bibs_get(\n    oclcNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Retrieve specific brief bibliographic resource. Uses /search/brief-bibs/{oclcNumber} endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumber</code> <code>Union[int, str]</code> <p>OCLC bibliographic record number; can be an                     integer or string with or without OCLC Number                     prefix</p> required <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def brief_bibs_get(\n    self, oclcNumber: Union[int, str], hooks: Optional[Dict[str, Callable]] = None\n) -&gt; Optional[Response]:\n    \"\"\"\n    Retrieve specific brief bibliographic resource.\n    Uses /search/brief-bibs/{oclcNumber} endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer or string with or without OCLC Number\n                                prefix\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_brief_bibs_oclc_number(oclcNumber)\n    header = {\"Accept\": \"application/json\"}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.brief_bibs_get_other_editions","title":"brief_bibs_get_other_editions","text":"<pre><code>brief_bibs_get_other_editions(\n    oclcNumber: Union[int, str],\n    deweyNumber: Optional[Union[str, List[str]]] = None,\n    datePublished: Optional[Union[str, List[str]]] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[Union[str, List[str]]] = None,\n    heldByInstitutionID: Optional[\n        Union[str, int, List[Union[str, int]]]\n    ] = None,\n    inLanguage: Optional[Union[str, List[str]]] = None,\n    inCatalogLanguage: Optional[str] = \"eng\",\n    materialType: Optional[str] = None,\n    catalogSource: Optional[str] = None,\n    itemType: Optional[Union[str, List[str]]] = None,\n    itemSubType: Optional[Union[str, List[str]]] = None,\n    retentionCommitments: bool = False,\n    spProgram: Optional[str] = None,\n    genre: Optional[str] = None,\n    topic: Optional[str] = None,\n    subtopic: Optional[str] = None,\n    audience: Optional[str] = None,\n    content: Optional[Union[str, List[str]]] = None,\n    openAccess: Optional[bool] = None,\n    peerReviewed: Optional[bool] = None,\n    facets: Optional[Union[str, List[str]]] = None,\n    groupVariantRecords: bool = False,\n    preferredLanguage: str = \"eng\",\n    showHoldingsIndicators: bool = False,\n    offset: int = 1,\n    limit: int = 10,\n    orderBy: str = \"publicationDateDesc\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Retrieve other editions related to bibliographic resource with provided OCLC Number. Query may contain only one of: heldByInstitutionID, heldByGroup, heldBySymbol, or spProgram. Uses /brief-bibs/{oclcNumber}/other-editions endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumber</code> <code>Union[int, str]</code> <p>OCLC bibliographic record number; can be an                     integer or string with or without OCLC Number                     prefix</p> required <code>deweyNumber</code> <code>Optional[Union[str, List[str]]]</code> <p>limits the response to the                     specified dewey classification number(s)                     example:                         '794,180'</p> <code>None</code> <code>datePublished</code> <code>Optional[Union[str, List[str]]]</code> <p>restricts the response to one or                     more dates, or to a range,                     examples:                         '2000'                         '2000-2005'                         '2000,2005'</p> <code>None</code> <code>heldByGroup</code> <code>Optional[str]</code> <p>restricts to holdings held by group symbol</p> <code>None</code> <code>heldBySymbol</code> <code>Optional[Union[str, List[str]]]</code> <p>restricts to holdings with specified intitution                     symbol</p> <code>None</code> <code>heldByInstitutionID</code> <code>Optional[Union[str, int, List[Union[str, int]]]]</code> <p>restrict to specified institution registryId</p> <code>None</code> <code>inLanguage</code> <code>Optional[Union[str, List[str]]]</code> <p>restricts the response to the single                     specified language, example: 'fre'</p> <code>None</code> <code>inCatalogLanguage</code> <code>Optional[str]</code> <p>restricts the response to specified                     cataloging language, example: 'eng';                     default 'eng'</p> <code>'eng'</code> <code>materialType</code> <code>Optional[str]</code> <p>restricts responses to specified material type,                     example: 'bks', 'vis'</p> <code>None</code> <code>catalogSource</code> <code>Optional[str]</code> <p>restrict to responses to single OCLC symbol as                     the cataloging source, example: 'DLC'</p> <code>None</code> <code>itemType</code> <code>Optional[Union[str, List[str]]]</code> <p>restricts responses to single specified OCLC                     top-level facet type, example: 'book'</p> <code>None</code> <code>itemSubType</code> <code>Optional[Union[str, List[str]]]</code> <p>restricts responses to single specified OCLC                     sub facet type, example: 'digital'</p> <code>None</code> <code>retentionCommitments</code> <code>bool</code> <p>restricts responses to bibliographic records                     with retention commitment; options: False, True                     (default is False)</p> <code>False</code> <code>spProgram</code> <code>Optional[str]</code> <p>restricts responses to bibliographic records                     associated with particular shared print                     program</p> <code>None</code> <code>genre</code> <code>Optional[str]</code> <p>genre to limit results to</p> <code>None</code> <code>topic</code> <code>Optional[str]</code> <p>topic to limit results to</p> <code>None</code> <code>subtopic</code> <code>Optional[str]</code> <p>subtopic to limit results to</p> <code>None</code> <code>audience</code> <code>Optional[str]</code> <p>audience to limit results to,                     example:                         juv,                         nonJuv</p> <code>None</code> <code>content</code> <code>Optional[Union[str, List[str]]]</code> <p>content to limit results to,                     example:                         fic,                         nonFic,                         fic,bio</p> <code>None</code> <code>openAccess</code> <code>Optional[bool]</code> <p>filter to only open access content, False or True</p> <code>None</code> <code>peerReviewed</code> <code>Optional[bool]</code> <p>filter to only peer reviewed content, False or True</p> <code>None</code> <code>facets</code> <code>Optional[Union[str, List[str]]]</code> <p>list of facets to restrict responses</p> <code>None</code> <code>groupVariantRecords</code> <code>bool</code> <p>whether or not to group variant records.                     options: False, True (default is False)</p> <code>False</code> <code>preferredLanguage</code> <code>str</code> <p>language of metadata description, default is 'eng'</p> <code>'eng'</code> <code>showHoldingsIndicators</code> <code>bool</code> <p>whether or not to show holdings indicators in                     response. options: True, False (default is False)</p> <code>False</code> <code>offset</code> <code>int</code> <p>start position of bibliographic records to                     return; default is 1</p> <code>1</code> <code>limit</code> <code>int</code> <p>maximum number of records to return;                     maximum is 50, default is 10</p> <code>10</code> <code>orderBy</code> <code>str</code> <p>results sort key;                     options:                         'recency'                         'bestMatch'                         'creator'                         'library'                         'publicationDateAsc'                         'publicationDateDesc'                         'mostWidelyHeld'                         'title'                     default is 'publicationDateDesc'</p> <code>'publicationDateDesc'</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def brief_bibs_get_other_editions(\n    self,\n    oclcNumber: Union[int, str],\n    deweyNumber: Optional[Union[str, List[str]]] = None,\n    datePublished: Optional[Union[str, List[str]]] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[Union[str, List[str]]] = None,\n    heldByInstitutionID: Optional[Union[str, int, List[Union[str, int]]]] = None,\n    inLanguage: Optional[Union[str, List[str]]] = None,\n    inCatalogLanguage: Optional[str] = \"eng\",\n    materialType: Optional[str] = None,\n    catalogSource: Optional[str] = None,\n    itemType: Optional[Union[str, List[str]]] = None,\n    itemSubType: Optional[Union[str, List[str]]] = None,\n    retentionCommitments: bool = False,\n    spProgram: Optional[str] = None,\n    genre: Optional[str] = None,\n    topic: Optional[str] = None,\n    subtopic: Optional[str] = None,\n    audience: Optional[str] = None,\n    content: Optional[Union[str, List[str]]] = None,\n    openAccess: Optional[bool] = None,\n    peerReviewed: Optional[bool] = None,\n    facets: Optional[Union[str, List[str]]] = None,\n    groupVariantRecords: bool = False,\n    preferredLanguage: str = \"eng\",\n    showHoldingsIndicators: bool = False,\n    offset: int = 1,\n    limit: int = 10,\n    orderBy: str = \"publicationDateDesc\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Retrieve other editions related to bibliographic resource with provided\n    OCLC Number. Query may contain only one of: heldByInstitutionID,\n    heldByGroup, heldBySymbol, or spProgram.\n    Uses /brief-bibs/{oclcNumber}/other-editions endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer or string with or without OCLC Number\n                                prefix\n        deweyNumber:            limits the response to the\n                                specified dewey classification number(s)\n                                example:\n                                    '794,180'\n        datePublished:          restricts the response to one or\n                                more dates, or to a range,\n                                examples:\n                                    '2000'\n                                    '2000-2005'\n                                    '2000,2005'\n        heldByGroup:            restricts to holdings held by group symbol\n        heldBySymbol:           restricts to holdings with specified intitution\n                                symbol\n        heldByInstitutionID:    restrict to specified institution registryId\n        inLanguage:             restricts the response to the single\n                                specified language, example: 'fre'\n        inCatalogLanguage:      restricts the response to specified\n                                cataloging language, example: 'eng';\n                                default 'eng'\n        materialType:           restricts responses to specified material type,\n                                example: 'bks', 'vis'\n        catalogSource:          restrict to responses to single OCLC symbol as\n                                the cataloging source, example: 'DLC'\n        itemType:               restricts responses to single specified OCLC\n                                top-level facet type, example: 'book'\n        itemSubType:            restricts responses to single specified OCLC\n                                sub facet type, example: 'digital'\n        retentionCommitments:   restricts responses to bibliographic records\n                                with retention commitment; options: False, True\n                                (default is False)\n        spProgram:              restricts responses to bibliographic records\n                                associated with particular shared print\n                                program\n        genre:                  genre to limit results to\n        topic:                  topic to limit results to\n        subtopic:               subtopic to limit results to\n        audience:               audience to limit results to,\n                                example:\n                                    juv,\n                                    nonJuv\n        content:                content to limit results to,\n                                example:\n                                    fic,\n                                    nonFic,\n                                    fic,bio\n        openAccess:             filter to only open access content, False or True\n        peerReviewed:           filter to only peer reviewed content, False or True\n        facets:                 list of facets to restrict responses\n        groupVariantRecords:    whether or not to group variant records.\n                                options: False, True (default is False)\n        preferredLanguage:      language of metadata description, default is 'eng'\n        showHoldingsIndicators: whether or not to show holdings indicators in\n                                response. options: True, False (default is False)\n        offset:                 start position of bibliographic records to\n                                return; default is 1\n        limit:                  maximum number of records to return;\n                                maximum is 50, default is 10\n        orderBy:                results sort key;\n                                options:\n                                    'recency'\n                                    'bestMatch'\n                                    'creator'\n                                    'library'\n                                    'publicationDateAsc'\n                                    'publicationDateDesc'\n                                    'mostWidelyHeld'\n                                    'title'\n                                default is 'publicationDateDesc'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_brief_bibs_other_editions(oclcNumber)\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"deweyNumber\": deweyNumber,\n        \"datePublished\": datePublished,\n        \"heldByGroup\": heldByGroup,\n        \"heldBySymbol\": heldBySymbol,\n        \"heldByInstitutionID\": heldByInstitutionID,\n        \"inLanguage\": inLanguage,\n        \"inCatalogLanguage\": inCatalogLanguage,\n        \"materialType\": materialType,\n        \"catalogSource\": catalogSource,\n        \"itemType\": itemType,\n        \"itemSubType\": itemSubType,\n        \"retentionCommitments\": retentionCommitments,\n        \"spProgram\": spProgram,\n        \"genre\": genre,\n        \"topic\": topic,\n        \"subtopic\": subtopic,\n        \"audience\": audience,\n        \"content\": content,\n        \"openAccess\": openAccess,\n        \"peerReviewed\": peerReviewed,\n        \"facets\": facets,\n        \"groupVariantRecords\": groupVariantRecords,\n        \"preferredLanguage\": preferredLanguage,\n        \"showHoldingsIndicators\": showHoldingsIndicators,\n        \"offset\": offset,\n        \"limit\": limit,\n        \"orderBy\": orderBy,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.brief_bibs_search","title":"brief_bibs_search","text":"<pre><code>brief_bibs_search(\n    q: str,\n    deweyNumber: Optional[Union[str, List[str]]] = None,\n    datePublished: Optional[Union[str, List[str]]] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[Union[str, List[str]]] = None,\n    heldByInstitutionID: Optional[\n        Union[str, int, List[str], List[int]]\n    ] = None,\n    inLanguage: Optional[Union[str, List[str]]] = None,\n    inCatalogLanguage: Optional[str] = \"eng\",\n    materialType: Optional[str] = None,\n    catalogSource: Optional[str] = None,\n    itemType: Optional[Union[str, List[str]]] = None,\n    itemSubType: Optional[Union[str, List[str]]] = None,\n    retentionCommitments: bool = False,\n    spProgram: Optional[str] = None,\n    genre: Optional[str] = None,\n    topic: Optional[str] = None,\n    subtopic: Optional[str] = None,\n    audience: Optional[str] = None,\n    content: Optional[Union[str, List[str]]] = None,\n    openAccess: Optional[bool] = None,\n    peerReviewed: Optional[bool] = None,\n    facets: Optional[Union[str, List[str]]] = None,\n    groupRelatedEditions: bool = False,\n    groupVariantRecords: bool = False,\n    preferredLanguage: str = \"eng\",\n    showHoldingsIndicators: bool = False,\n    lat: Optional[float] = None,\n    lon: Optional[float] = None,\n    distance: Optional[int] = None,\n    unit: str = \"M\",\n    orderBy: str = \"bestMatch\",\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Search for brief bibliographic resources using WorldCat query syntax. See https://help.oclc.org/Librarian_Toolbox/Searching_WorldCat_Indexes/ Bibliographic_records/Bibliographic_record_indexes for more information on available indexes. Request may contain only one of: heldByInstitutionID, heldByGroup, heldBySymbol, or combination of lat and lon. Uses /search/brief-bibs endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>str</code> <p>query in the form of a keyword search or                     fielded search;                     examples:                         ti:Zendegi                         ti:\"Czarne oceany\"                         bn:9781680502404                         kw:python databases                         ti:Zendegi AND au:greg egan                         (au:Okken OR au:Myers) AND su:python</p> required <code>deweyNumber</code> <code>Optional[Union[str, List[str]]]</code> <p>limits the response to the                     specified dewey classification number(s);                     for multiple values repeat the parameter,                     example:                         '794,180'</p> <code>None</code> <code>datePublished</code> <code>Optional[Union[str, List[str]]]</code> <p>restricts the response to one or                     more dates, or to a range,                     examples:                         '2000'                         '2000-2005'                         '2000,2005'</p> <code>None</code> <code>heldByGroup</code> <code>Optional[str]</code> <p>restricts to holdings held by group symbol</p> <code>None</code> <code>heldBySymbol</code> <code>Optional[Union[str, List[str]]]</code> <p>restricts response to holdings held by specified                     institution symbol</p> <code>None</code> <code>heldByInstitutionID</code> <code>Optional[Union[str, int, List[str], List[int]]]</code> <p>restricts response to holdings held by specified                     institution registryId</p> <code>None</code> <code>inLanguage</code> <code>Optional[Union[str, List[str]]]</code> <p>restricts the response to the single                     specified language, example: 'fre'</p> <code>None</code> <code>inCatalogLanguage</code> <code>Optional[str]</code> <p>restricts the response to specified                     cataloging language, example: 'eng';                     default 'eng'</p> <code>'eng'</code> <code>materialType</code> <code>Optional[str]</code> <p>restricts responses to specified material type,                     example: 'bks', 'vis'</p> <code>None</code> <code>catalogSource</code> <code>Optional[str]</code> <p>restrict to responses to single OCLC symbol as                     the cataloging source, example: 'DLC'</p> <code>None</code> <code>itemType</code> <code>Optional[Union[str, List[str]]]</code> <p>restricts responses to single specified OCLC                     top-level facet type, example: 'book'</p> <code>None</code> <code>itemSubType</code> <code>Optional[Union[str, List[str]]]</code> <p>restricts responses to single specified OCLC                     sub facet type, example: 'digital'</p> <code>None</code> <code>retentionCommitments</code> <code>bool</code> <p>restricts responses to bibliographic records                     with retention commitment; options: True, False,                     (default is False)</p> <code>False</code> <code>spProgram</code> <code>Optional[str]</code> <p>restricts responses to bibliographic records                     associated with particular shared print                     program</p> <code>None</code> <code>genre</code> <code>Optional[str]</code> <p>genre to limit results to (ge index)</p> <code>None</code> <code>topic</code> <code>Optional[str]</code> <p>topic to limit results to (s0 index)</p> <code>None</code> <code>subtopic</code> <code>Optional[str]</code> <p>subtopic to limit results to (s1 index)</p> <code>None</code> <code>audience</code> <code>Optional[str]</code> <p>audience to limit results to,                     available values: 'juv', 'nonJuv'</p> <code>None</code> <code>content</code> <code>Optional[Union[str, List[str]]]</code> <p>content to limit results to                     available values: 'fic', 'nonFic', 'bio'</p> <code>None</code> <code>openAccess</code> <code>Optional[bool]</code> <p>restricts response to just open access content</p> <code>None</code> <code>peerReviewed</code> <code>Optional[bool]</code> <p>restricts response to just peer reviewed content</p> <code>None</code> <code>facets</code> <code>Optional[Union[str, List[str]]]</code> <p>list of facets to restrict responses</p> <code>None</code> <code>groupRelatedEditions</code> <code>bool</code> <p>whether or not use FRBR grouping,                     options: False, True (default is False)</p> <code>False</code> <code>groupVariantRecords</code> <code>bool</code> <p>whether or not to group variant records.                     options: False, True (default is False)</p> <code>False</code> <code>preferredLanguage</code> <code>str</code> <p>language of metadata description,                     default value \"eng\" (English)</p> <code>'eng'</code> <code>showHoldingsIndicators</code> <code>bool</code> <p>whether or not to show holdings indicators in                     response. options: True, False, (default is False)</p> <code>False</code> <code>lat</code> <code>Optional[float]</code> <p>limit to latitude, example: 37.502508</p> <code>None</code> <code>lon</code> <code>Optional[float]</code> <p>limit to longitute, example: -122.22702</p> <code>None</code> <code>distance</code> <code>Optional[int]</code> <p>distance from latitude and longitude</p> <code>None</code> <code>unit</code> <code>str</code> <p>unit of distance param; options:                     'M' (miles) or 'K' (kilometers), default is 'M'</p> <code>'M'</code> <code>orderBy</code> <code>str</code> <p>results sort key;                     options:                         'recency'                         'bestMatch'                         'creator'                         'library'                         'publicationDateAsc'                         'publicationDateDesc'                         'mostWidelyHeld'                         'title'                     default is 'bestMatch'</p> <code>'bestMatch'</code> <code>offset</code> <code>int</code> <p>start position of bibliographic records to                     return; default is 1</p> <code>1</code> <code>limit</code> <code>int</code> <p>maximum number of records to return;                     maximum is 50, default is 10</p> <code>10</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def brief_bibs_search(\n    self,\n    q: str,\n    deweyNumber: Optional[Union[str, List[str]]] = None,\n    datePublished: Optional[Union[str, List[str]]] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[Union[str, List[str]]] = None,\n    heldByInstitutionID: Optional[Union[str, int, List[str], List[int]]] = None,\n    inLanguage: Optional[Union[str, List[str]]] = None,\n    inCatalogLanguage: Optional[str] = \"eng\",\n    materialType: Optional[str] = None,\n    catalogSource: Optional[str] = None,\n    itemType: Optional[Union[str, List[str]]] = None,\n    itemSubType: Optional[Union[str, List[str]]] = None,\n    retentionCommitments: bool = False,\n    spProgram: Optional[str] = None,\n    genre: Optional[str] = None,\n    topic: Optional[str] = None,\n    subtopic: Optional[str] = None,\n    audience: Optional[str] = None,\n    content: Optional[Union[str, List[str]]] = None,\n    openAccess: Optional[bool] = None,\n    peerReviewed: Optional[bool] = None,\n    facets: Optional[Union[str, List[str]]] = None,\n    groupRelatedEditions: bool = False,\n    groupVariantRecords: bool = False,\n    preferredLanguage: str = \"eng\",\n    showHoldingsIndicators: bool = False,\n    lat: Optional[float] = None,\n    lon: Optional[float] = None,\n    distance: Optional[int] = None,\n    unit: str = \"M\",\n    orderBy: str = \"bestMatch\",\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Search for brief bibliographic resources using WorldCat query syntax.\n    See https://help.oclc.org/Librarian_Toolbox/Searching_WorldCat_Indexes/\n    Bibliographic_records/Bibliographic_record_indexes for more information on\n    available indexes. Request may contain only one of: heldByInstitutionID,\n    heldByGroup, heldBySymbol, or combination of lat and lon.\n    Uses /search/brief-bibs endpoint.\n\n    Args:\n        q:                      query in the form of a keyword search or\n                                fielded search;\n                                examples:\n                                    ti:Zendegi\n                                    ti:\"Czarne oceany\"\n                                    bn:9781680502404\n                                    kw:python databases\n                                    ti:Zendegi AND au:greg egan\n                                    (au:Okken OR au:Myers) AND su:python\n        deweyNumber:            limits the response to the\n                                specified dewey classification number(s);\n                                for multiple values repeat the parameter,\n                                example:\n                                    '794,180'\n        datePublished:          restricts the response to one or\n                                more dates, or to a range,\n                                examples:\n                                    '2000'\n                                    '2000-2005'\n                                    '2000,2005'\n        heldByGroup:            restricts to holdings held by group symbol\n        heldBySymbol:           restricts response to holdings held by specified\n                                institution symbol\n        heldByInstitutionID:    restricts response to holdings held by specified\n                                institution registryId\n        inLanguage:             restricts the response to the single\n                                specified language, example: 'fre'\n        inCatalogLanguage:      restricts the response to specified\n                                cataloging language, example: 'eng';\n                                default 'eng'\n        materialType:           restricts responses to specified material type,\n                                example: 'bks', 'vis'\n        catalogSource:          restrict to responses to single OCLC symbol as\n                                the cataloging source, example: 'DLC'\n        itemType:               restricts responses to single specified OCLC\n                                top-level facet type, example: 'book'\n        itemSubType:            restricts responses to single specified OCLC\n                                sub facet type, example: 'digital'\n        retentionCommitments:   restricts responses to bibliographic records\n                                with retention commitment; options: True, False,\n                                (default is False)\n        spProgram:              restricts responses to bibliographic records\n                                associated with particular shared print\n                                program\n        genre:                  genre to limit results to (ge index)\n        topic:                  topic to limit results to (s0 index)\n        subtopic:               subtopic to limit results to (s1 index)\n        audience:               audience to limit results to,\n                                available values: 'juv', 'nonJuv'\n        content:                content to limit results to\n                                available values: 'fic', 'nonFic', 'bio'\n        openAccess:             restricts response to just open access content\n        peerReviewed:           restricts response to just peer reviewed content\n        facets:                 list of facets to restrict responses\n        groupRelatedEditions:   whether or not use FRBR grouping,\n                                options: False, True (default is False)\n        groupVariantRecords:    whether or not to group variant records.\n                                options: False, True (default is False)\n        preferredLanguage:      language of metadata description,\n                                default value \"eng\" (English)\n        showHoldingsIndicators: whether or not to show holdings indicators in\n                                response. options: True, False, (default is False)\n        lat:                    limit to latitude, example: 37.502508\n        lon:                    limit to longitute, example: -122.22702\n        distance:               distance from latitude and longitude\n        unit:                   unit of distance param; options:\n                                'M' (miles) or 'K' (kilometers), default is 'M'\n        orderBy:                results sort key;\n                                options:\n                                    'recency'\n                                    'bestMatch'\n                                    'creator'\n                                    'library'\n                                    'publicationDateAsc'\n                                    'publicationDateDesc'\n                                    'mostWidelyHeld'\n                                    'title'\n                                default is 'bestMatch'\n        offset:                 start position of bibliographic records to\n                                return; default is 1\n        limit:                  maximum number of records to return;\n                                maximum is 50, default is 10\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_search_brief_bibs()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"q\": q,\n        \"deweyNumber\": deweyNumber,\n        \"datePublished\": datePublished,\n        \"heldByGroup\": heldByGroup,\n        \"heldBySymbol\": heldBySymbol,\n        \"heldByInstitutionID\": heldByInstitutionID,\n        \"inLanguage\": inLanguage,\n        \"inCatalogLanguage\": inCatalogLanguage,\n        \"materialType\": materialType,\n        \"catalogSource\": catalogSource,\n        \"itemType\": itemType,\n        \"itemSubType\": itemSubType,\n        \"retentionCommitments\": retentionCommitments,\n        \"spProgram\": spProgram,\n        \"genre\": genre,\n        \"topic\": topic,\n        \"subtopic\": subtopic,\n        \"audience\": audience,\n        \"content\": content,\n        \"openAccess\": openAccess,\n        \"peerReviewed\": peerReviewed,\n        \"facets\": facets,\n        \"groupRelatedEditions\": groupRelatedEditions,\n        \"groupVariantRecords\": groupVariantRecords,\n        \"preferredLanguage\": preferredLanguage,\n        \"showHoldingsIndicators\": showHoldingsIndicators,\n        \"lat\": lat,\n        \"lon\": lon,\n        \"distance\": distance,\n        \"unit\": unit,\n        \"orderBy\": orderBy,\n        \"offset\": offset,\n        \"limit\": limit,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_get_codes","title":"holdings_get_codes","text":"<pre><code>holdings_get_codes(\n    hooks: Optional[Dict[str, Callable]] = None\n) -&gt; Optional[Response]\n</code></pre> <p>Retrieve the all holding codes for the authenticated institution. Uses /manage/institution/holding-codes endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:     <code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def holdings_get_codes(\n    self,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Retrieve the all holding codes for the authenticated institution.\n    Uses /manage/institution/holding-codes endpoint.\n\n    Args:\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_ih_codes()\n    header = {\"Accept\": \"application/json\"}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_get_current","title":"holdings_get_current","text":"<pre><code>holdings_get_current(\n    oclcNumbers: Union[str, List[Union[str, int]]],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Retrieves WorldCat holdings status of a record with provided OCLC number. The service automatically recognizes the user's institution based on the issued access token. Uses /manage/institution/holdings/current endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumbers</code> <code>Union[str, List[Union[str, int]]]</code> <p>string or list containing one or more OCLC numbers                     to be checked; numbers can be integers or strings                     with or without OCLC Number prefix;                     if str, the numbers must be separated by a comma</p> required <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def holdings_get_current(\n    self,\n    oclcNumbers: Union[str, List[Union[str, int]]],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Retrieves WorldCat holdings status of a record with provided OCLC number.\n    The service automatically recognizes the user's institution based on the\n    issued access token.\n    Uses /manage/institution/holdings/current endpoint.\n\n    Args:\n        oclcNumbers:            string or list containing one or more OCLC numbers\n                                to be checked; numbers can be integers or strings\n                                with or without OCLC Number prefix;\n                                if str, the numbers must be separated by a comma\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    vetted_numbers = verify_oclc_numbers(oclcNumbers)\n\n    # check that no more than 10 oclc numbers were passed\n    if len(vetted_numbers) &gt; 10:\n        raise ValueError(\"Too many OCLC Numbers passed to 'oclcNumbers' argument.\")\n\n    url = self._url_manage_ih_current()\n    header = {\"Accept\": \"application/json\"}\n\n    payload = {\"oclcNumbers\": vetted_numbers}\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_set","title":"holdings_set","text":"<pre><code>holdings_set(\n    oclcNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Sets institution's WorldCat holdings on an individual record. Uses /manage/institions/holdings/{oclcNumber}/set endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumber</code> <code>Union[int, str]</code> <p>OCLC bibliographic record number; can be an                     integer or string with or without OCLC Number                     prefix</p> required <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def holdings_set(\n    self,\n    oclcNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Sets institution's WorldCat holdings on an individual record.\n    Uses /manage/institions/holdings/{oclcNumber}/set endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer or string with or without OCLC Number\n                                prefix\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_manage_ih_set(oclcNumber)\n    header = {\"Accept\": \"application/json\"}\n\n    # prep request\n    req = Request(\"POST\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_set_with_bib","title":"holdings_set_with_bib","text":"<pre><code>holdings_set_with_bib(\n    record: str,\n    recordFormat: str,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given a MARC record in MARC XML or MARC21, set institution holdings on the record. MARC record must contain OCLC number in 001 or 035 subfield a. Only one MARC record is allowed in the request body. Uses /manage/institution/holdings/set endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>str</code> <p>MARC record on which to set holdings</p> required <code>recordFormat</code> <code>str</code> <p>format of MARC record, options:                     'application/marcxml+xml', 'application/marc'</p> required <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def holdings_set_with_bib(\n    self,\n    record: str,\n    recordFormat: str,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given a MARC record in MARC XML or MARC21, set institution holdings on the\n    record. MARC record must contain OCLC number in 001 or 035 subfield a.\n    Only one MARC record is allowed in the request body.\n    Uses /manage/institution/holdings/set endpoint.\n\n    Args:\n        record:                 MARC record on which to set holdings\n        recordFormat:           format of MARC record, options:\n                                'application/marcxml+xml', 'application/marc'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_ih_set_with_bib()\n    header = {\n        \"Accept\": \"application/json\",\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"POST\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_unset","title":"holdings_unset","text":"<pre><code>holdings_unset(\n    oclcNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Unsets institution's WorldCat holdings on an individual record. Uses /manage/institions/holdings/{oclcNumber}/unset endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumber</code> <code>Union[int, str]</code> <p>OCLC bibliographic record number; can be an                     integer or string with or without OCLC Number                     prefix</p> required <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def holdings_unset(\n    self,\n    oclcNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Unsets institution's WorldCat holdings on an individual record.\n    Uses /manage/institions/holdings/{oclcNumber}/unset endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer or string with or without OCLC Number\n                                prefix\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_manage_ih_unset(oclcNumber)\n    header = {\"Accept\": \"application/json\"}\n\n    # prep request\n    req = Request(\"POST\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_unset_with_bib","title":"holdings_unset_with_bib","text":"<pre><code>holdings_unset_with_bib(\n    record: str,\n    recordFormat: str,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given a MARC record in MARC XML or MARC21, unset institution holdings on the record. MARC record must contain OCLC number in 001 or 035 subfield a. Only one MARC record is allowed in the request body. Uses /manage/institution/holdings/unset endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>str</code> <p>MARC record on which to unset holdings</p> required <code>recordFormat</code> <code>str</code> <p>format of MARC record, options:                     'application/marcxml+xml', 'application/marc'</p> required <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def holdings_unset_with_bib(\n    self,\n    record: str,\n    recordFormat: str,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given a MARC record in MARC XML or MARC21, unset institution holdings on the\n    record. MARC record must contain OCLC number in 001 or 035 subfield a.\n    Only one MARC record is allowed in the request body.\n    Uses /manage/institution/holdings/unset endpoint.\n\n    Args:\n        record:                 MARC record on which to unset holdings\n        recordFormat:           format of MARC record, options:\n                                'application/marcxml+xml', 'application/marc'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_ih_unset_with_bib()\n    header = {\n        \"Accept\": \"application/json\",\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"POST\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lbd_create","title":"lbd_create","text":"<pre><code>lbd_create(\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given a local bibliographic data record, create it in WorldCat. Uses /manage/lbds endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>str</code> <p>MARC record to be created</p> required <code>recordFormat</code> <code>str</code> <p>format of MARC record, options:                     'application/marcxml+xml', 'application/marc'</p> required <code>responseFormat</code> <code>str</code> <p>format of returned record; options:                     'application/marcxml+xml', 'application/marc'                     default is 'application/marcxml+xml'</p> <code>'application/marcxml+xml'</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def lbd_create(\n    self,\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given a local bibliographic data record, create it in WorldCat.\n    Uses /manage/lbds endpoint.\n\n    Args:\n        record:                 MARC record to be created\n        recordFormat:           format of MARC record, options:\n                                'application/marcxml+xml', 'application/marc'\n        responseFormat:         format of returned record; options:\n                                'application/marcxml+xml', 'application/marc'\n                                default is 'application/marcxml+xml'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lbd_create()\n    header = {\n        \"Accept\": responseFormat,\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"POST\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lbd_delete","title":"lbd_delete","text":"<pre><code>lbd_delete(\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given a control number, delete the associated Local Bibliographic Data record. Uses /manage/lbds/{controlNumber} endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>controlNumber</code> <code>Union[int, str]</code> <p>control number associated with Local Bibliographic                     Data record; can be an integer or string</p> required <code>responseFormat</code> <code>str</code> <p>format of returned record, options:                     'application/marcxml+xml', 'application/marc',                     default is 'application/marcxml+xml'</p> <code>'application/marcxml+xml'</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def lbd_delete(\n    self,\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given a control number, delete the associated Local Bibliographic Data record.\n    Uses /manage/lbds/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:          control number associated with Local Bibliographic\n                                Data record; can be an integer or string\n        responseFormat:         format of returned record, options:\n                                'application/marcxml+xml', 'application/marc',\n                                default is 'application/marcxml+xml'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lbd(controlNumber)\n    header = {\"Accept\": responseFormat}\n\n    # prep request\n    req = Request(\"DELETE\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lbd_get","title":"lbd_get","text":"<pre><code>lbd_get(\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given a Control Number, retrieve a Local Bibliographic Data record. Uses /manage/lbds/{controlNumber} endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>controlNumber</code> <code>Union[int, str]</code> <p>control number associated with Local Bibliographic                     Data record; can be an integer or string</p> required <code>responseFormat</code> <code>str</code> <p>format of returned record, options:                     'application/marcxml+xml', 'application/marc',                     default is 'application/marcxml+xml'</p> <code>'application/marcxml+xml'</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def lbd_get(\n    self,\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given a Control Number, retrieve a Local Bibliographic Data record.\n    Uses /manage/lbds/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:          control number associated with Local Bibliographic\n                                Data record; can be an integer or string\n        responseFormat:         format of returned record, options:\n                                'application/marcxml+xml', 'application/marc',\n                                default is 'application/marcxml+xml'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lbd(controlNumber)\n    header = {\"Accept\": responseFormat}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lbd_replace","title":"lbd_replace","text":"<pre><code>lbd_replace(\n    controlNumber: Union[int, str],\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given a Control Number, find the associated Local Bibliographic Data Record and replace it. If the Control Number is not found in WorldCat, then the provided Local Bibliographic Data Record will be created. Uses /manage/lbds/{controlNumber} endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>controlNumber</code> <code>Union[int, str]</code> <p>control number associated with Local Bibliographic                     Data record; can be an integer or string</p> required <code>record</code> <code>str</code> <p>MARC record to replace existing local                     bibliographic record</p> required <code>recordFormat</code> <code>str</code> <p>format of MARC record, options:                     'application/marcxml+xml', 'application/marc'</p> required <code>responseFormat</code> <code>str</code> <p>format of returned record; options:                     'application/marcxml+xml', 'application/marc'                     default is 'application/marcxml+xml'</p> <code>'application/marcxml+xml'</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def lbd_replace(\n    self,\n    controlNumber: Union[int, str],\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given a Control Number, find the associated Local Bibliographic Data\n    Record and replace it. If the Control Number is not found in\n    WorldCat, then the provided Local Bibliographic Data Record will be created.\n    Uses /manage/lbds/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:          control number associated with Local Bibliographic\n                                Data record; can be an integer or string\n        record:                 MARC record to replace existing local\n                                bibliographic record\n        recordFormat:           format of MARC record, options:\n                                'application/marcxml+xml', 'application/marc'\n        responseFormat:         format of returned record; options:\n                                'application/marcxml+xml', 'application/marc'\n                                default is 'application/marcxml+xml'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lbd(controlNumber)\n    header = {\n        \"Accept\": responseFormat,\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"PUT\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lhr_create","title":"lhr_create","text":"<pre><code>lhr_create(\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given a local holdings record, create it in WorldCat Uses /manage/lhrs endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>str</code> <p>MARC holdings record to be created</p> required <code>recordFormat</code> <code>str</code> <p>format of MARC holdings record, options:                     'application/marcxml+xml', 'application/marc'</p> required <code>responseFormat</code> <code>str</code> <p>format of returned record; options:                     'application/marcxml+xml', 'application/marc'                     default is 'application/marcxml+xml'</p> <code>'application/marcxml+xml'</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def lhr_create(\n    self,\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given a local holdings record, create it in WorldCat\n    Uses /manage/lhrs endpoint.\n\n    Args:\n        record:                 MARC holdings record to be created\n        recordFormat:           format of MARC holdings record, options:\n                                'application/marcxml+xml', 'application/marc'\n        responseFormat:         format of returned record; options:\n                                'application/marcxml+xml', 'application/marc'\n                                default is 'application/marcxml+xml'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lhr_create()\n    header = {\n        \"Accept\": responseFormat,\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"POST\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lhr_delete","title":"lhr_delete","text":"<pre><code>lhr_delete(\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given a control number, delete a Local Holdings record. Uses /manage/lhrs/{controlNumber} endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>controlNumber</code> <code>Union[int, str]</code> <p>control number associated with Local Holdings                     record; can be an integer or string</p> required <code>responseFormat</code> <code>str</code> <p>format of returned record, options:                     'application/marcxml+xml', 'application/marc',                     default is 'application/marcxml+xml'</p> <code>'application/marcxml+xml'</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def lhr_delete(\n    self,\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given a control number, delete a Local Holdings record.\n    Uses /manage/lhrs/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:          control number associated with Local Holdings\n                                record; can be an integer or string\n        responseFormat:         format of returned record, options:\n                                'application/marcxml+xml', 'application/marc',\n                                default is 'application/marcxml+xml'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lhr(controlNumber)\n    header = {\"Accept\": responseFormat}\n\n    # prep request\n    req = Request(\"DELETE\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lhr_get","title":"lhr_get","text":"<pre><code>lhr_get(\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Send a GET request for a local holdings record Uses /manage/lhrs/{controlNumber} endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>controlNumber</code> <code>Union[int, str]</code> <p>control number associated with Local Holdings                     record; can be an integer or string</p> required <code>responseFormat</code> <code>str</code> <p>format of returned record, options:                     'application/marcxml+xml', 'application/marc',                     default is 'application/marcxml+xml'</p> <code>'application/marcxml+xml'</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def lhr_get(\n    self,\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Send a GET request for a local holdings record\n    Uses /manage/lhrs/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:          control number associated with Local Holdings\n                                record; can be an integer or string\n        responseFormat:         format of returned record, options:\n                                'application/marcxml+xml', 'application/marc',\n                                default is 'application/marcxml+xml'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lhr(controlNumber)\n    header = {\"Accept\": responseFormat}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lhr_replace","title":"lhr_replace","text":"<pre><code>lhr_replace(\n    controlNumber: Union[int, str],\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given a Control Number, find the associated Local Holdings Record and replace it. If the Control Number is not found in WorldCat, then the provided Local Holdings Record will be created. Uses /manage/lhrs/{controlNumber} endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>controlNumber</code> <code>Union[int, str]</code> <p>control number associated with Local Holdings                     record; can be an integer or string</p> required <code>record</code> <code>str</code> <p>MARC holdings record to replace existing local                     holdings record</p> required <code>recordFormat</code> <code>str</code> <p>format of MARC holdings record, options:                     'application/marcxml+xml', 'application/marc'</p> required <code>responseFormat</code> <code>str</code> <p>format of returned record; options:                     'application/marcxml+xml', 'application/marc'                     default is 'application/marcxml+xml'</p> <code>'application/marcxml+xml'</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def lhr_replace(\n    self,\n    controlNumber: Union[int, str],\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given a Control Number, find the associated Local Holdings\n    Record and replace it. If the Control Number is not found in\n    WorldCat, then the provided Local Holdings Record will be created.\n    Uses /manage/lhrs/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:          control number associated with Local Holdings\n                                record; can be an integer or string\n        record:                 MARC holdings record to replace existing local\n                                holdings record\n        recordFormat:           format of MARC holdings record, options:\n                                'application/marcxml+xml', 'application/marc'\n        responseFormat:         format of returned record; options:\n                                'application/marcxml+xml', 'application/marc'\n                                default is 'application/marcxml+xml'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lhr(controlNumber)\n    header = {\n        \"Accept\": responseFormat,\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"PUT\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.local_bibs_get","title":"local_bibs_get","text":"<pre><code>local_bibs_get(\n    controlNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Retrieve LBD Resource. Uses /search/my-local-bib-data/{controlNumber} endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>controlNumber</code> <code>Union[int, str]</code> <p>control number associated with Local Bibliographic                     Data record; can be an integer or string</p> required <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def local_bibs_get(\n    self,\n    controlNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Retrieve LBD Resource.\n    Uses /search/my-local-bib-data/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:          control number associated with Local Bibliographic\n                                Data record; can be an integer or string\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_search_lbd_control_number(controlNumber)\n    header = {\"Accept\": \"application/json\"}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.local_bibs_search","title":"local_bibs_search","text":"<pre><code>local_bibs_search(\n    q: str,\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Search LBD Resources using WorldCat query syntax. See https://help.oclc.org/Librarian_Toolbox/Searching_WorldCat_Indexes/ Local_bibliographic_data_records/Local_bibliographic_data_record_indexes_A-Z for more information on available indexes. Uses /search/my-local-bib-data endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>str</code> <p>query in the form of a keyword search or                     fielded search;                     examples:                         ti:Zendegi                         ti:\"Czarne oceany\"                         bn:9781680502404                         kw:python databases                         ti:Zendegi AND au:greg egan                         (au:Okken OR au:Myers) AND su:python</p> required <code>offset</code> <code>int</code> <p>start position of bibliographic records to                     return; default is 1</p> <code>1</code> <code>limit</code> <code>int</code> <p>maximum number of records to return;                     maximum is 50, default is 10</p> <code>10</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def local_bibs_search(\n    self,\n    q: str,\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Search LBD Resources using WorldCat query syntax.\n    See https://help.oclc.org/Librarian_Toolbox/Searching_WorldCat_Indexes/\n    Local_bibliographic_data_records/Local_bibliographic_data_record_indexes_A-Z\n    for more information on available indexes.\n    Uses /search/my-local-bib-data endpoint.\n\n    Args:\n        q:                      query in the form of a keyword search or\n                                fielded search;\n                                examples:\n                                    ti:Zendegi\n                                    ti:\"Czarne oceany\"\n                                    bn:9781680502404\n                                    kw:python databases\n                                    ti:Zendegi AND au:greg egan\n                                    (au:Okken OR au:Myers) AND su:python\n        offset:                 start position of bibliographic records to\n                                return; default is 1\n        limit:                  maximum number of records to return;\n                                maximum is 50, default is 10\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_search_lbd()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\"q\": q, \"offset\": offset, \"limit\": limit}\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.local_holdings_browse","title":"local_holdings_browse","text":"<pre><code>local_holdings_browse(\n    holdingLocation: str,\n    shelvingLocation: str,\n    callNumber: str,\n    oclcNumber: Optional[Union[int, str]] = None,\n    browsePosition: int = 0,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Browse local holdings. Uses /browse/my-holdings endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>holdingLocation</code> <code>str</code> <p>holding location for item</p> required <code>shelvingLocation</code> <code>str</code> <p>shelving location for item</p> required <code>callNumber</code> <code>str</code> <p>call number for item</p> required <code>oclcNumber</code> <code>Optional[Union[int, str]]</code> <p>OCLC bibliographic record number; can be an                     integer or string with or without OCLC Number                     prefix</p> <code>None</code> <code>browsePosition</code> <code>int</code> <p>position within browse list where the matching                     record should be, default is 0</p> <code>0</code> <code>limit</code> <code>int</code> <p>maximum number of records to return;                     maximum is 50, default is 10</p> <code>10</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def local_holdings_browse(\n    self,\n    holdingLocation: str,\n    shelvingLocation: str,\n    callNumber: str,\n    oclcNumber: Optional[Union[int, str]] = None,\n    browsePosition: int = 0,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Browse local holdings.\n    Uses /browse/my-holdings endpoint.\n\n    Args:\n        holdingLocation:        holding location for item\n        shelvingLocation:       shelving location for item\n        callNumber:             call number for item\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer or string with or without OCLC Number\n                                prefix\n        browsePosition:         position within browse list where the matching\n                                record should be, default is 0\n        limit:                  maximum number of records to return;\n                                maximum is 50, default is 10\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    if oclcNumber is not None:\n        oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_browse_lhr()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"callNumber\": callNumber,\n        \"oclcNumber\": oclcNumber,\n        \"holdingLocation\": holdingLocation,\n        \"shelvingLocation\": shelvingLocation,\n        \"browsePosition\": browsePosition,\n        \"limit\": limit,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.local_holdings_get","title":"local_holdings_get","text":"<pre><code>local_holdings_get(\n    controlNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Retrieve LHR Resource. Uses /search/my-holdings/{controlNumber} endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>controlNumber</code> <code>Union[int, str]</code> <p>control number associated with Local Holdings                     record; can be an integer or string</p> required <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def local_holdings_get(\n    self,\n    controlNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Retrieve LHR Resource.\n    Uses /search/my-holdings/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:          control number associated with Local Holdings\n                                record; can be an integer or string\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_search_lhr_control_number(controlNumber)\n    header = {\"Accept\": \"application/json\"}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.local_holdings_search","title":"local_holdings_search","text":"<pre><code>local_holdings_search(\n    oclcNumber: Optional[Union[int, str]] = None,\n    barcode: Optional[str] = None,\n    orderBy: str = \"oclcSymbol\",\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Search LHR Resources. Query must contain, at minimum, either an OCLC Number or barcode. Uses /search/my-holdings endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumber</code> <code>Optional[Union[int, str]]</code> <p>OCLC bibliographic record number; can be an                     integer or string with or without OCLC Number                     prefix</p> <code>None</code> <code>barcode</code> <code>Optional[str]</code> <p>barcode as a string,</p> <code>None</code> <code>orderBy</code> <code>str</code> <p>results sort key;                     options:                         'commitmentExpirationDate'                         'location'                         'oclcSymbol'                     default is 'oclcSymbol'</p> <code>'oclcSymbol'</code> <code>offset</code> <code>int</code> <p>start position of bibliographic records to                     return; default is 1</p> <code>1</code> <code>limit</code> <code>int</code> <p>maximum number of records to return;                     maximum is 50, default is 10</p> <code>10</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def local_holdings_search(\n    self,\n    oclcNumber: Optional[Union[int, str]] = None,\n    barcode: Optional[str] = None,\n    orderBy: str = \"oclcSymbol\",\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Search LHR Resources. Query must contain, at minimum, either an\n    OCLC Number or barcode.\n    Uses /search/my-holdings endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer or string with or without OCLC Number\n                                prefix\n        barcode:                barcode as a string,\n        orderBy:                results sort key;\n                                options:\n                                    'commitmentExpirationDate'\n                                    'location'\n                                    'oclcSymbol'\n                                default is 'oclcSymbol'\n        offset:                 start position of bibliographic records to\n                                return; default is 1\n        limit:                  maximum number of records to return;\n                                maximum is 50, default is 10\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    if oclcNumber is not None:\n        oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_lhr()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"barcode\": barcode,\n        \"orderBy\": orderBy,\n        \"offset\": offset,\n        \"limit\": limit,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.local_holdings_search_shared_print","title":"local_holdings_search_shared_print","text":"<pre><code>local_holdings_search_shared_print(\n    oclcNumber: Optional[Union[int, str]] = None,\n    barcode: Optional[str] = None,\n    heldBySymbol: Optional[List[str]] = None,\n    heldByInstitutionID: Optional[List[int]] = None,\n    spProgram: Optional[List[str]] = None,\n    orderBy: str = \"oclcSymbol\",\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Search for shared print LHR Resources. Query must contain, at minimum, either an OCLC Number or barcode and a value for either heldBySymbol, heldByInstitutionID or spProgram. Uses /search/retained-holdings endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumber</code> <code>Optional[Union[int, str]]</code> <p>OCLC bibliographic record number; can be an                     integer or string with or without OCLC Number                     prefix</p> <code>None</code> <code>barcode</code> <code>Optional[str]</code> <p>barcode as a string,</p> <code>None</code> <code>heldBySymbol</code> <code>Optional[List[str]]</code> <p>restricts to holdings with specified institution                     symbol</p> <code>None</code> <code>heldByInstitutionID</code> <code>Optional[List[int]]</code> <p>restrict to specified institution registryId</p> <code>None</code> <code>spProgram</code> <code>Optional[List[str]]</code> <p>restricts responses to bibliographic records                     associated with particular shared print program</p> <code>None</code> <code>orderBy</code> <code>str</code> <p>results sort key;                     options:                         'commitmentExpirationDate'                         'location'                         'oclcSymbol'                     default is 'oclcSymbol'</p> <code>'oclcSymbol'</code> <code>offset</code> <code>int</code> <p>start position of bibliographic records to                     return; default is 1</p> <code>1</code> <code>limit</code> <code>int</code> <p>maximum number of records to return;                     maximum is 50, default is 10</p> <code>10</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def local_holdings_search_shared_print(\n    self,\n    oclcNumber: Optional[Union[int, str]] = None,\n    barcode: Optional[str] = None,\n    heldBySymbol: Optional[List[str]] = None,\n    heldByInstitutionID: Optional[List[int]] = None,\n    spProgram: Optional[List[str]] = None,\n    orderBy: str = \"oclcSymbol\",\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Search for shared print LHR Resources. Query must contain, at minimum,\n    either an OCLC Number or barcode and a value for either heldBySymbol,\n    heldByInstitutionID or spProgram.\n    Uses /search/retained-holdings endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer or string with or without OCLC Number\n                                prefix\n        barcode:                barcode as a string,\n        heldBySymbol:           restricts to holdings with specified institution\n                                symbol\n        heldByInstitutionID:    restrict to specified institution registryId\n        spProgram:              restricts responses to bibliographic records\n                                associated with particular shared print program\n        orderBy:                results sort key;\n                                options:\n                                    'commitmentExpirationDate'\n                                    'location'\n                                    'oclcSymbol'\n                                default is 'oclcSymbol'\n        offset:                 start position of bibliographic records to\n                                return; default is 1\n        limit:                  maximum number of records to return;\n                                maximum is 50, default is 10\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    if oclcNumber is not None:\n        oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_lhr_shared_print()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"barcode\": barcode,\n        \"heldBySymbol\": heldBySymbol,\n        \"heldByInstitutionID\": heldByInstitutionID,\n        \"spProgram\": spProgram,\n        \"orderBy\": orderBy,\n        \"offset\": offset,\n        \"limit\": limit,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.shared_print_holdings_search","title":"shared_print_holdings_search","text":"<pre><code>shared_print_holdings_search(\n    oclcNumber: Optional[Union[int, str]] = None,\n    isbn: Optional[str] = None,\n    issn: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldInState: Optional[str] = None,\n    itemType: Optional[List[str]] = None,\n    itemSubType: Optional[List[str]] = None,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Finds member shared print holdings for specified item. Query must contain, at minimum, either an OCLC Number, ISBN, or ISSN. Uses /search/bibs-retained-holdings endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumber</code> <code>Optional[Union[int, str]]</code> <p>OCLC bibliographic record number; can be an                     integer or string with or without OCLC Number                     prefix</p> <code>None</code> <code>isbn</code> <code>Optional[str]</code> <p>ISBN without any dashes, example: '978149191646x'</p> <code>None</code> <code>issn</code> <code>Optional[str]</code> <p>ISSN hyphenated, example: '0099-1234'</p> <code>None</code> <code>heldByGroup</code> <code>Optional[str]</code> <p>restricts to holdings held by group symbol</p> <code>None</code> <code>heldInState</code> <code>Optional[str]</code> <p>restricts to holdings held by institutions                     in requested state, example: \"NY\"</p> <code>None</code> <code>itemType</code> <code>Optional[List[str]]</code> <p>restricts results to specified item type (example                     'book' or 'vis')</p> <code>None</code> <code>itemSubType</code> <code>Optional[List[str]]</code> <p>restricts results to specified item sub type                     examples: 'book-digital' or 'audiobook-cd'</p> <code>None</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used for                     signal event handling. For more information see the                     Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def shared_print_holdings_search(\n    self,\n    oclcNumber: Optional[Union[int, str]] = None,\n    isbn: Optional[str] = None,\n    issn: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldInState: Optional[str] = None,\n    itemType: Optional[List[str]] = None,\n    itemSubType: Optional[List[str]] = None,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Finds member shared print holdings for specified item. Query must\n    contain, at minimum, either an OCLC Number, ISBN, or ISSN.\n    Uses /search/bibs-retained-holdings endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer or string with or without OCLC Number\n                                prefix\n        isbn:                   ISBN without any dashes, example: '978149191646x'\n        issn:                   ISSN hyphenated, example: '0099-1234'\n        heldByGroup:            restricts to holdings held by group symbol\n        heldInState:            restricts to holdings held by institutions\n                                in requested state, example: \"NY\"\n        itemType:               restricts results to specified item type (example\n                                'book' or 'vis')\n        itemSubType:            restricts results to specified item sub type\n                                examples: 'book-digital' or 'audiobook-cd'\n        hooks:                  Requests library hook system that can be used for\n                                signal event handling. For more information see the\n                                [Requests docs](https://requests.readthedocs.io/en/\n                                master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    if oclcNumber is not None:\n        oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_shared_print_holdings()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"isbn\": isbn,\n        \"issn\": issn,\n        \"heldByGroup\": heldByGroup,\n        \"heldInState\": heldInState,\n        \"itemType\": itemType,\n        \"itemSubType\": itemSubType,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.summary_holdings_get","title":"summary_holdings_get","text":"<pre><code>summary_holdings_get(\n    oclcNumber: Union[int, str],\n    holdingsAllEditions: Optional[bool] = None,\n    holdingsAllVariantRecords: Optional[bool] = None,\n    holdingsFilterFormat: Optional[List[str]] = None,\n    heldInCountry: Optional[str] = None,\n    heldInState: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[List[str]] = None,\n    heldByInstitutionID: Optional[List[int]] = None,\n    heldByLibraryType: Optional[List[str]] = None,\n    lat: Optional[float] = None,\n    lon: Optional[float] = None,\n    distance: Optional[int] = None,\n    unit: str = \"M\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given an OCLC number, get summary of holdings. Query may contain only one of: heldByInstitutionId, heldByGroup, heldBySymbol, heldInCountry, heldInState or combination of lat, lon and distance. If using lat/lon arguments, query must contain a valid distance argument. Uses /search/summary-holdings endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumber</code> <code>Union[int, str]</code> <p>OCLC bibliographic record number; can be an                         integer or string with or without OCLC Number                         prefix</p> required <code>holdingsAllEditions</code> <code>Optional[bool]</code> <p>get holdings for all editions;                         options: True, False</p> <code>None</code> <code>holdingsAllVariantRecords</code> <code>Optional[bool]</code> <p>get holdings for specific edition across                         all variant records; options: True, False</p> <code>None</code> <code>holdingsFilterFormat</code> <code>Optional[List[str]]</code> <p>get holdings for specific itemSubType,                         example: book-digital</p> <code>None</code> <code>heldInCountry</code> <code>Optional[str]</code> <p>limits to holdings held by institutions                         in requested country</p> <code>None</code> <code>heldInState</code> <code>Optional[str]</code> <p>limits to holdings held by institutions                         in requested state, example: 'US-NY'</p> <code>None</code> <code>heldByGroup</code> <code>Optional[str]</code> <p>limits to holdings held by institutions                         indicated by group symbol</p> <code>None</code> <code>heldBySymbol</code> <code>Optional[List[str]]</code> <p>limits to holdings held by institutions                         indicated by institution symbol</p> <code>None</code> <code>heldByInstitutionID</code> <code>Optional[List[int]]</code> <p>limits to holdings held by institutions                         indicated by institution registryID</p> <code>None</code> <code>heldByLibraryType</code> <code>Optional[List[str]]</code> <p>limits to holdings held by library type,                         options: 'PUBLIC', 'ALL'</p> <code>None</code> <code>lat</code> <code>Optional[float]</code> <p>limit to latitude, example: 37.502508</p> <code>None</code> <code>lon</code> <code>Optional[float]</code> <p>limit to longitute, example: -122.22702</p> <code>None</code> <code>distance</code> <code>Optional[int]</code> <p>distance from latitude and longitude</p> <code>None</code> <code>unit</code> <code>str</code> <p>unit of distance param; options:                         'M' (miles) or 'K' (kilometers), default is 'M'</p> <code>'M'</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used                         for signal event handling. For more information                         see the Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def summary_holdings_get(\n    self,\n    oclcNumber: Union[int, str],\n    holdingsAllEditions: Optional[bool] = None,\n    holdingsAllVariantRecords: Optional[bool] = None,\n    holdingsFilterFormat: Optional[List[str]] = None,\n    heldInCountry: Optional[str] = None,\n    heldInState: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[List[str]] = None,\n    heldByInstitutionID: Optional[List[int]] = None,\n    heldByLibraryType: Optional[List[str]] = None,\n    lat: Optional[float] = None,\n    lon: Optional[float] = None,\n    distance: Optional[int] = None,\n    unit: str = \"M\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given an OCLC number, get summary of holdings. Query may contain\n    only one of: heldByInstitutionId, heldByGroup, heldBySymbol, heldInCountry,\n    heldInState or combination of lat, lon and distance. If using lat/lon\n    arguments, query must contain a valid distance argument.\n    Uses /search/summary-holdings endpoint.\n\n    Args:\n        oclcNumber:                 OCLC bibliographic record number; can be an\n                                    integer or string with or without OCLC Number\n                                    prefix\n        holdingsAllEditions:        get holdings for all editions;\n                                    options: True, False\n        holdingsAllVariantRecords:  get holdings for specific edition across\n                                    all variant records; options: True, False\n        holdingsFilterFormat:       get holdings for specific itemSubType,\n                                    example: book-digital\n        heldInCountry:              limits to holdings held by institutions\n                                    in requested country\n        heldInState:                limits to holdings held by institutions\n                                    in requested state, example: 'US-NY'\n        heldByGroup:                limits to holdings held by institutions\n                                    indicated by group symbol\n        heldBySymbol:               limits to holdings held by institutions\n                                    indicated by institution symbol\n        heldByInstitutionID:        limits to holdings held by institutions\n                                    indicated by institution registryID\n        heldByLibraryType:          limits to holdings held by library type,\n                                    options: 'PUBLIC', 'ALL'\n        lat:                        limit to latitude, example: 37.502508\n        lon:                        limit to longitute, example: -122.22702\n        distance:                   distance from latitude and longitude\n        unit:                       unit of distance param; options:\n                                    'M' (miles) or 'K' (kilometers), default is 'M'\n        hooks:                      Requests library hook system that can be used\n                                    for signal event handling. For more information\n                                    see the [Requests docs](https://requests.\n                                    readthedocs.io/en/master/user/advanced/\n                                    #event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_general_holdings_summary()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"holdingsAllEditions\": holdingsAllEditions,\n        \"holdingsAllVariantRecords\": holdingsAllVariantRecords,\n        \"holdingsFilterFormat\": holdingsFilterFormat,\n        \"heldInCountry\": heldInCountry,\n        \"heldInState\": heldInState,\n        \"heldByGroup\": heldByGroup,\n        \"heldBySymbol\": heldBySymbol,\n        \"heldByInstitutionID\": heldByInstitutionID,\n        \"heldByLibraryType\": heldByLibraryType,\n        \"lat\": lat,\n        \"lon\": lon,\n        \"distance\": distance,\n        \"unit\": unit,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.summary_holdings_search","title":"summary_holdings_search","text":"<pre><code>summary_holdings_search(\n    oclcNumber: Optional[Union[int, str]] = None,\n    isbn: Optional[str] = None,\n    issn: Optional[str] = None,\n    holdingsAllEditions: Optional[bool] = None,\n    holdingsAllVariantRecords: Optional[bool] = None,\n    preferredLanguage: str = \"eng\",\n    holdingsFilterFormat: Optional[List[str]] = None,\n    heldInCountry: Optional[str] = None,\n    heldInState: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[List[str]] = None,\n    heldByInstitutionID: Optional[List[int]] = None,\n    heldByLibraryType: Optional[List[str]] = None,\n    lat: Optional[float] = None,\n    lon: Optional[float] = None,\n    distance: Optional[int] = None,\n    unit: str = \"M\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]\n</code></pre> <p>Given a known item, get summary of holdings and brief bib record. Query must contain, at minimum, either an OCLC Number, ISBN, or ISSN. Query may contain only one of: heldByInstitutionId, heldByGroup, heldBySymbol, heldInCountry, heldInState or combination of lat, lon and distance. If using lat/lon arguments, query must contain a valid distance argument. Uses /search/bibs-summary-holdings endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumber</code> <code>Optional[Union[int, str]]</code> <p>OCLC bibliographic record number; can be an                         integer or string with or without OCLC Number                         prefix</p> <code>None</code> <code>isbn</code> <code>Optional[str]</code> <p>ISBN without any dashes,                         example: '978149191646x'</p> <code>None</code> <code>issn</code> <code>Optional[str]</code> <p>ISSN (hyphenated, example: '0099-1234')</p> <code>None</code> <code>holdingsAllEditions</code> <code>Optional[bool]</code> <p>get holdings for all editions;                         options: True or False</p> <code>None</code> <code>holdingsAllVariantRecords</code> <code>Optional[bool]</code> <p>get holdings for specific edition across                         variant records; options: False, True</p> <code>None</code> <code>preferredLanguage</code> <code>str</code> <p>language of metadata description;                         default 'eng' (English)</p> <code>'eng'</code> <code>holdingsFilterFormat</code> <code>Optional[List[str]]</code> <p>get holdings for specific itemSubType,                         example: book-digital</p> <code>None</code> <code>heldInCountry</code> <code>Optional[str]</code> <p>restricts to holdings held by institutions                         in requested country</p> <code>None</code> <code>heldInState</code> <code>Optional[str]</code> <p>limits to holdings held by institutions                         in requested state, example: 'US-NY'</p> <code>None</code> <code>heldByGroup</code> <code>Optional[str]</code> <p>limits to holdings held by indicated by                         symbol group</p> <code>None</code> <code>heldBySymbol</code> <code>Optional[List[str]]</code> <p>limits to holdings held by institutions                         indicated by institution symbol</p> <code>None</code> <code>heldByInstitutionID</code> <code>Optional[List[int]]</code> <p>limits to holdings held by institutions                         indicated by institution registryID</p> <code>None</code> <code>heldByLibraryType</code> <code>Optional[List[str]]</code> <p>limits to holdings held by library type,                         options: 'PUBLIC', 'ALL'</p> <code>None</code> <code>lat</code> <code>Optional[float]</code> <p>limit to latitude, example: 37.502508,</p> <code>None</code> <code>lon</code> <code>Optional[float]</code> <p>limit to longitute, example: -122.22702</p> <code>None</code> <code>distance</code> <code>Optional[int]</code> <p>distance from latitude and longitude</p> <code>None</code> <code>unit</code> <code>str</code> <p>unit of distance param; options:                         'M' (miles) or 'K' (kilometers), default is 'M'</p> <code>'M'</code> <code>hooks</code> <code>Optional[Dict[str, Callable]]</code> <p>Requests library hook system that can be used                         for signal event handling. For more information                         see the Requests docs</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Response]</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat/metadata_api.py</code> <pre><code>def summary_holdings_search(\n    self,\n    oclcNumber: Optional[Union[int, str]] = None,\n    isbn: Optional[str] = None,\n    issn: Optional[str] = None,\n    holdingsAllEditions: Optional[bool] = None,\n    holdingsAllVariantRecords: Optional[bool] = None,\n    preferredLanguage: str = \"eng\",\n    holdingsFilterFormat: Optional[List[str]] = None,\n    heldInCountry: Optional[str] = None,\n    heldInState: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[List[str]] = None,\n    heldByInstitutionID: Optional[List[int]] = None,\n    heldByLibraryType: Optional[List[str]] = None,\n    lat: Optional[float] = None,\n    lon: Optional[float] = None,\n    distance: Optional[int] = None,\n    unit: str = \"M\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Optional[Response]:\n    \"\"\"\n    Given a known item, get summary of holdings and brief bib record. Query must\n    contain, at minimum, either an OCLC Number, ISBN, or ISSN. Query may contain\n    only one of: heldByInstitutionId, heldByGroup, heldBySymbol, heldInCountry,\n    heldInState or combination of lat, lon and distance. If using lat/lon\n    arguments, query must contain a valid distance argument.\n    Uses /search/bibs-summary-holdings endpoint.\n\n    Args:\n        oclcNumber:                 OCLC bibliographic record number; can be an\n                                    integer or string with or without OCLC Number\n                                    prefix\n        isbn:                       ISBN without any dashes,\n                                    example: '978149191646x'\n        issn:                       ISSN (hyphenated, example: '0099-1234')\n        holdingsAllEditions:        get holdings for all editions;\n                                    options: True or False\n        holdingsAllVariantRecords:  get holdings for specific edition across\n                                    variant records; options: False, True\n        preferredLanguage:          language of metadata description;\n                                    default 'eng' (English)\n        holdingsFilterFormat:       get holdings for specific itemSubType,\n                                    example: book-digital\n        heldInCountry:              restricts to holdings held by institutions\n                                    in requested country\n        heldInState:                limits to holdings held by institutions\n                                    in requested state, example: 'US-NY'\n        heldByGroup:                limits to holdings held by indicated by\n                                    symbol group\n        heldBySymbol:               limits to holdings held by institutions\n                                    indicated by institution symbol\n        heldByInstitutionID:        limits to holdings held by institutions\n                                    indicated by institution registryID\n        heldByLibraryType:          limits to holdings held by library type,\n                                    options: 'PUBLIC', 'ALL'\n        lat:                        limit to latitude, example: 37.502508,\n        lon:                        limit to longitute, example: -122.22702\n        distance:                   distance from latitude and longitude\n        unit:                       unit of distance param; options:\n                                    'M' (miles) or 'K' (kilometers), default is 'M'\n        hooks:                      Requests library hook system that can be used\n                                    for signal event handling. For more information\n                                    see the [Requests docs](https://requests.\n                                    readthedocs.io/en/master/user/advanced/\n                                    #event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    if oclcNumber is not None:\n        oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_general_holdings()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"isbn\": isbn,\n        \"issn\": issn,\n        \"holdingsAllEditions\": holdingsAllEditions,\n        \"holdingsAllVariantRecords\": holdingsAllVariantRecords,\n        \"preferredLanguage\": preferredLanguage,\n        \"holdingsFilterFormat\": holdingsFilterFormat,\n        \"heldInCountry\": heldInCountry,\n        \"heldInState\": heldInState,\n        \"heldByGroup\": heldByGroup,\n        \"heldBySymbol\": heldBySymbol,\n        \"heldByInstitutionID\": heldByInstitutionID,\n        \"heldByLibraryType\": heldByLibraryType,\n        \"lat\": lat,\n        \"lon\": lon,\n        \"distance\": distance,\n        \"unit\": unit,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/query/","title":"bookops_worldcat.query","text":"<p>Handles actual requests to OCLC services</p>"},{"location":"api/query/#bookops_worldcat.query.Query","title":"Query","text":"<pre><code>Query(\n    session: MetadataSession,\n    prepared_request: PreparedRequest,\n    timeout: Optional[\n        Union[\n            int, float, Tuple[int, int], Tuple[float, float]\n        ]\n    ] = None,\n)\n</code></pre> <p>Sends a request to OCLC service and unifies exceptions. Query object handles refreshing expired token before request is made to the web service.</p> <p><code>Query.response</code> attribute is <code>requests.Response</code> instance that can be parsed to extract information received from the web service.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>MetadataSession</code> <p><code>metadata_api.MetadataSession</code> instance</p> required <code>prepared_request</code> <code>PreparedRequest</code> <p><code>requests.models.PreparedRequest</code> instance</p> required <code>timeout</code> <code>Optional[Union[int, float, Tuple[int, int], Tuple[float, float]]]</code> <p>how long to wait for server to send data                             before giving up</p> <code>None</code> <p>Raises:</p> Type Description <code>WorldcatRequestError</code> <p>If the request encounters an error</p> Source code in <code>bookops_worldcat/query.py</code> <pre><code>def __init__(\n    self,\n    session: MetadataSession,\n    prepared_request: PreparedRequest,\n    timeout: Optional[\n        Union[int, float, Tuple[int, int], Tuple[float, float]]\n    ] = None,\n) -&gt; None:\n    \"\"\"Initializes Query object.\n\n    Args:\n        session:                        `metadata_api.MetadataSession` instance\n        prepared_request:               `requests.models.PreparedRequest` instance\n        timeout:                        how long to wait for server to send data\n                                        before giving up\n\n\n    Raises:\n        WorldcatRequestError: If the request encounters an error\n    \"\"\"\n    if not isinstance(prepared_request, PreparedRequest):\n        raise TypeError(\"Invalid type for argument 'prepared_request'.\")\n\n    # make sure access token is still valid and if not request a new one\n    if session.authorization.is_expired():\n        session._get_new_access_token()\n\n    try:\n        self.response = session.send(prepared_request, timeout=timeout)\n        self.response.raise_for_status()\n\n    except HTTPError as exc:\n        raise WorldcatRequestError(\n            f\"{exc}. Server response: \"  # type: ignore\n            f\"{self.response.content.decode('utf-8')}\"\n        )\n    except (Timeout, ConnectionError, RetryError):\n        raise WorldcatRequestError(f\"Connection Error: {sys.exc_info()[0]}\")\n\n    except Exception:\n        raise WorldcatRequestError(f\"Unexpected request error: {sys.exc_info()[0]}\")\n</code></pre>"},{"location":"api/utils/","title":"bookops_worldcat.utils","text":"<p>Shared utilities module.</p>"},{"location":"api/utils/#bookops_worldcat.utils.prep_oclc_number_str","title":"prep_oclc_number_str","text":"<pre><code>prep_oclc_number_str(oclcNumber: str) -&gt; str\n</code></pre> <p>Checks for OCLC prefixes and removes them.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumber</code> <code>str</code> <p>OCLC record as string</p> required <p>Returns:</p> Type Description <code>str</code> <p>oclcNumber as str</p> Source code in <code>bookops_worldcat/utils.py</code> <pre><code>def prep_oclc_number_str(oclcNumber: str) -&gt; str:\n    \"\"\"\n    Checks for OCLC prefixes and removes them.\n\n    Args:\n        oclcNumber:                OCLC record as string\n\n    Returns:\n        oclcNumber as str\n    \"\"\"\n\n    if oclcNumber.strip().startswith(\"ocm\") or oclcNumber.strip().startswith(\"ocn\"):\n        oclcNumber = oclcNumber.strip()[3:]\n    elif oclcNumber.strip().startswith(\"on\"):\n        oclcNumber = oclcNumber.strip()[2:]\n\n    try:\n        oclcNumber = str(int(oclcNumber))\n        return oclcNumber\n    except ValueError:\n        raise InvalidOclcNumber(\"Argument 'oclcNumber' does not look like real OCLC #.\")\n</code></pre>"},{"location":"api/utils/#bookops_worldcat.utils.verify_oclc_number","title":"verify_oclc_number","text":"<pre><code>verify_oclc_number(oclcNumber: Union[int, str]) -&gt; str\n</code></pre> <p>Verifies a valid looking OCLC number is passed and normalize it as integer.</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumber</code> <code>Union[int, str]</code> <p>OCLC record number</p> required <p>Returns:</p> Type Description <code>str</code> <p>oclcNumber as str</p> Source code in <code>bookops_worldcat/utils.py</code> <pre><code>def verify_oclc_number(oclcNumber: Union[int, str]) -&gt; str:\n    \"\"\"\n    Verifies a valid looking OCLC number is passed and normalize it as integer.\n\n    Args:\n        oclcNumber:                OCLC record number\n\n    Returns:\n        oclcNumber as str\n\n    \"\"\"\n    if not oclcNumber:\n        raise InvalidOclcNumber(\"Argument 'oclcNumber' is missing.\")\n\n    elif isinstance(oclcNumber, int):\n        return str(oclcNumber)\n\n    elif isinstance(oclcNumber, str):\n        return prep_oclc_number_str(oclcNumber)\n\n    else:\n        raise InvalidOclcNumber(\"Argument 'oclcNumber' is of invalid type.\")\n</code></pre>"},{"location":"api/utils/#bookops_worldcat.utils.verify_oclc_numbers","title":"verify_oclc_numbers","text":"<pre><code>verify_oclc_numbers(\n    oclcNumbers: Union[str, List[Union[str, int]]]\n) -&gt; List[str]\n</code></pre> <p>Parses and verifies list of oclcNumbers</p> <p>Parameters:</p> Name Type Description Default <code>oclcNumbers</code> <code>Union[str, List[Union[str, int]]]</code> <p>list of OCLC control numbers for which holdings                     should be set;                     they can be integers or strings with or without                     OCLC # prefix;                     if str the numbers must be separated by comma</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>vetted_numbers as list</p> Source code in <code>bookops_worldcat/utils.py</code> <pre><code>def verify_oclc_numbers(oclcNumbers: Union[str, List[Union[str, int]]]) -&gt; List[str]:\n    \"\"\"\n    Parses and verifies list of oclcNumbers\n\n    Args:\n        oclcNumbers:            list of OCLC control numbers for which holdings\n                                should be set;\n                                they can be integers or strings with or without\n                                OCLC # prefix;\n                                if str the numbers must be separated by comma\n\n    Returns:\n        vetted_numbers as list\n\n    \"\"\"\n    if isinstance(oclcNumbers, str):\n        oclcNumbers_lst = _str2list(oclcNumbers)\n    elif isinstance(oclcNumbers, list):\n        oclcNumbers_lst = oclcNumbers  # type: ignore\n    else:\n        raise InvalidOclcNumber(\n            \"Argument 'oclcNumbers' must be a list or comma separated string \"\n            \"of valid OCLC #s.\"\n        )\n    if not oclcNumbers_lst:\n        raise InvalidOclcNumber(\n            \"Argument 'oclcNumbers' must be a list or comma separated string \"\n            \"of valid OCLC #s.\"\n        )\n\n    vetted_numbers = [verify_oclc_number(n) for n in oclcNumbers_lst]\n    return vetted_numbers\n</code></pre>"}]}