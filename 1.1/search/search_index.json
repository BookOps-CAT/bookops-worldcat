{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BookOps-Worldcat","text":"<p>Bookops-Worldcat is a Python wrapper around OCLC's WorldCat Metadata API. The package features methods that enable interactions with each endpoint of the API.</p> <p>The Bookops-Worldcat package simplifies some of the OCLC API boilerplate and ideally lowers the technological threshold for cataloging departments that may not have sufficient programming support to access and utilize the web services. Python, with its gentle learning curve, has the potential to be a perfect vehicle towards this goal.</p> <p>Bookops-Worldcat version 1.0 supports changes released in version 2.0 (May 2023) of the OCLC Metadata API. </p>"},{"location":"#overview","title":"Overview","text":"<p>Requires Python 3.8 and up.</p> <p>Bookops-Worldcat takes advantage of the functionality of the popular Requests library and interactions with OCLC's services are built around 'Requests' sessions. <code>MetadataSession</code> inherits all <code>requests.Session</code> properties. Server responses are <code>requests.Response</code> objects with all of their properties and methods.</p> <p>Authorizing a web service session simply requires passing an access token to <code>MetadataSession</code>. Opening a session allows the user to call specific methods to facilitate communication between the user's script/client and a particular endpoint of the Metadata API. Many of the hurdles related to making valid requests are hidden under the hood of this package, making it as simple as possible.</p> <p>Bookops-Worldcat supports OAuth 2.0 endpoints and flows and uses the Client Credential Grant flow.</p>"},{"location":"#installation","title":"Installation","text":"<p>Use pip to install:</p> <p><code>$ pip -m install bookops-worldcat</code></p>"},{"location":"#interacting-with-the-metadata-api","title":"Interacting with the Metadata API","text":"<p>Users of the WorldCat Metadata API must have OCLC credentials. A web service key, or WSKey, can be obtained via the OCLC Developer Network site. More information about WSKeys is available on the OCLC Developer Network site. </p> <p>Querying the WorldCat Metadata API is a two step process. Users first pass their API credentials to the WorldCat Authorization Server to obtain an Access Token and then use that Access Token to query the Metadata API.</p>"},{"location":"#examples","title":"Examples","text":"<p>Users obtain an Access Token by passing credential parameters into the <code>WorldcatAccessToken</code> object.</p> <p>Authorizing a MetadataSession<pre><code>from bookops_worldcat import WorldcatAccessToken, MetadataSession\n\ntoken = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=\"WorldCatMetadataAPI\",\n)\nprint(token)\n#&gt;\"access_token: 'tk_O4WFpJuidaaXJmb8wPb7aMSfJdYZg5XC9Ovo', expires_at: '2024-03-20 15:25:32Z'\"\nprint(token.is_expired())\n#&gt;False\nsession = MetadataSession(authorization=token)\nprint(session.headers)\n#&gt; {'User-Agent': 'bookops-worldcat/1.0.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Authorization': 'Bearer tk_xS0qvZs5j04ewpJeHUqNxQ1Y4LFprOKLw1ek'}\n</code></pre> Once a <code>MetadataSession</code> is authenticated using a <code>WorldcatAccessToken</code> object, users can search WorldCat for bibliographic resources. Brief bib resources are returned in JSON format which can be parsed using the <code>.json()</code> method. Brief Bib Search<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.brief_bibs_search(\n        q=\"ti:The Power Broker AND au: Caro, Robert\"\n    )\n    print(response.json())\n</code></pre> Brief Bib JSON Response<pre><code>{\n  \"numberOfRecords\": 89,\n  \"briefRecords\": [\n    {\n      \"oclcNumber\": \"1631862\",\n      \"title\": \"The power broker : Robert Moses and the fall of New York\",\n      \"creator\": \"Robert A. Caro\",\n      \"date\": \"1975\",\n      \"machineReadableDate\": \"1975\",\n      \"language\": \"eng\",\n      \"generalFormat\": \"Book\",\n      \"specificFormat\": \"PrintBook\",\n      \"edition\": \"Vintage Books edition\",\n      \"publisher\": \"Vintage Books\",\n      \"publicationPlace\": \"New York\",\n      \"isbns\": [\n        \"0394720245\",\n        \"9780394720241\"\n      ],\n      \"mergedOclcNumbers\": [\n        \"750986288\",\n        \"979848451\",\n        \"1171296546\",\n        \"1200988349\",\n        \"1200988563\",\n        \"1201968774\",\n        \"1202023560\",\n        \"1222888365\",\n        \"1282059511\",\n        \"1376480175\"\n      ],\n      \"catalogingInfo\": {\n        \"catalogingAgency\": \"DLC\",\n        \"catalogingLanguage\": \"eng\",\n        \"levelOfCataloging\": \" \",\n        \"transcribingAgency\": \"DLC\"\n      }\n    }\n  ]\n}\n</code></pre> Users can retrieve full bib records from WorldCat by passing the <code>bib_get</code> method an OCLC Number: Get Full Bib Record<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    result = session.bib_get(\"1631862\")\n    print(result.text) \n</code></pre> Full Bib MARCXML Response<pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt;\n  &lt;record xmlns=\"http://www.loc.gov/MARC21/slim\"&gt;\n    &lt;leader&gt;00000cam a2200000 i 4500&lt;/leader&gt;\n    &lt;controlfield tag=\"001\"&gt;ocm01631862&lt;/controlfield&gt;\n    &lt;controlfield tag=\"003\"&gt;OCoLC&lt;/controlfield&gt;\n    &lt;controlfield tag=\"005\"&gt;20240201163642.4&lt;/controlfield&gt;\n    &lt;controlfield tag=\"008\"&gt;750320t19751974nyuabf   b    001 0beng  &lt;/controlfield&gt;\n    &lt;datafield tag=\"010\" ind1=\" \" ind2=\" \"&gt;\n      &lt;subfield code=\"a\"&gt;   75009557 &lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;!--...--&gt;\n    &lt;datafield tag=\"020\" ind1=\" \" ind2=\" \"&gt;\n      &lt;subfield code=\"a\"&gt;9780394720241&lt;/subfield&gt;\n      &lt;subfield code=\"q\"&gt;(paperback)&lt;/subfield&gt;\n&lt;!--...--&gt;\n    &lt;datafield tag=\"100\" ind1=\"1\" ind2=\" \"&gt;\n      &lt;subfield code=\"a\"&gt;Caro, Robert A.,&lt;/subfield&gt;\n      &lt;subfield code=\"e\"&gt;author.&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"245\" ind1=\"1\" ind2=\"4\"&gt;\n      &lt;subfield code=\"a\"&gt;The power broker :&lt;/subfield&gt;\n      &lt;subfield code=\"b\"&gt;Robert Moses and the fall of New York /&lt;/subfield&gt;\n      &lt;subfield code=\"c\"&gt;by Robert A. Caro.&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"246\" ind1=\"3\" ind2=\"0\"&gt;\n      &lt;subfield code=\"a\"&gt;Robert Moses and the fall of New York&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"250\" ind1=\" \" ind2=\" \"&gt;\n      &lt;subfield code=\"a\"&gt;Vintage Books edition.&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"264\" ind1=\" \" ind2=\"1\"&gt;\n      &lt;subfield code=\"a\"&gt;New York :&lt;/subfield&gt;\n      &lt;subfield code=\"b\"&gt;Vintage Books,&lt;/subfield&gt;\n      &lt;subfield code=\"c\"&gt;1975.&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;!--...--&gt;\n&lt;/record&gt;\n</code></pre> Additional examples and a full outline of the functionality available in Bookops-Worldcat are available in the Get Started section.</p>"},{"location":"#supported-oclc-web-services","title":"Supported OCLC web services","text":"<p>The WorldCat Metadata API is a read-write service for WorldCat. It allows users to add and update records in WorldCat; maintain institution holdings; search WorldCat using the full suite of bibliographic record indexes; retrieve MARC records in MARCXML or MARC21; and work with local bibliographic and holdings data. Access to the Metadata API requires OCLC credentials. The BookOps-Worldcat wrapper supports requests to all endpoints of the WorldCat Metadata API:</p> <ul> <li>Manage Bibliographic Records<ul> <li>Validate bib record <code>/manage/bibs/validate/{validationLevel}</code></li> <li>Get current OCLC number <code>/manage/bibs/current</code></li> <li>Create bib record <code>/manage/bibs</code></li> <li>Retrieve full bib record <code>/manage/bibs/{oclcNumber}</code></li> <li>Replace bib record <code>/manage/bibs/{oclcNumber}</code></li> <li>Find match for a bib record in WorldCat <code>/manage/bibs/match</code></li> </ul> </li> <li>Manage Institution Holdings<ul> <li>Retrieve status of institution holdings <code>/manage/institution/holdings/current</code></li> <li>Set institution holding with OCLC Number <code>/manage/institution/holdings/set/{oclcNumber}/set</code></li> <li>Unset institution holding with OCLC Number <code>/manage/institution/holdings/unset/{oclcNumber}/unset</code></li> <li>Set institution holding with MARC record <code>/manage/institution/holdings</code></li> <li>Unset institution holding with MARC record <code>/manage/institution/holdings</code></li> <li>Retrieve institution holding codes <code>/manage/institution/holdings/current</code></li> </ul> </li> <li>Manage Local Bibliographic Data<ul> <li>Create local bib data record <code>/manage/lbds</code></li> <li>Retrieve local bib data record <code>/manage/lbds/{controlNumber}</code></li> <li>Replace local bib data record <code>/manage/lbds/{controlNumber}</code></li> <li>Delete local bib data record <code>/manage/lbds/{controlNumber}</code></li> </ul> </li> <li>Manage Local Holdings Records<ul> <li>Create local holdings record <code>/manage/lhrs</code></li> <li>Retrieve local holdings record <code>/manage/lhrs/{controlNumber}</code></li> <li>Replace local holdings record <code>/manage/lhrs/{controlNumber}</code></li> <li>Delete local holdings record <code>/manage/lhrs/{controlNumber}</code></li> </ul> </li> <li>Search Member Shared Print Holdings <code>/search/bibs-retained-holdings</code></li> <li>Search Member General Holdings<ul> <li>Get summary of holdings for known items <code>/search/bibs-summary-holdings</code></li> <li>Search and retrieve summary of holdings <code>/search/summary-holdings</code></li> </ul> </li> <li>Search Bibliographic Resources<ul> <li>Search brief bib resources <code>/search/brief-bibs</code></li> <li>Retrieve specific brief bib resource <code>/search/brief-bibs/{oclcNumber}</code></li> <li>Retrieve other editions related to a particular bib resource <code>/search/brief-bibs/{oclcNumber}/other-editions</code></li> <li>Retrieve classification recommendations for an OCLC Number <code>/search/classification-bibs/{oclcNumber}</code></li> </ul> </li> <li>Search Local Holdings Resources<ul> <li>Search shared print local holdings resources <code>/search/retained-holdings</code></li> <li>Retrieve local holdings resource <code>/search/my-holdings/{controlNumber}</code></li> <li>Search local holdings resources <code>/search/my-holdings</code></li> <li>Browse my local holdings resources <code>/browse/my-holdings</code></li> </ul> </li> <li>Search Local Bibliographic Resources<ul> <li>Retrieve local bibliographic resource <code>/search/my-local-bib-data/{controlNumber}</code></li> <li>Search local bibliographic resources <code>/search/my-local-bib-data</code></li> </ul> </li> </ul>"},{"location":"#whats-new-in-bookops-worldcat","title":"What's new in Bookops-Worldcat","text":"<p>See the Changelog page for a full outline of fixes and enhancements with each version.</p>"},{"location":"#features-in-version-10","title":"Features in Version 1.0","text":"<p>New functionality available in version 1.0:</p> <ul> <li>Send requests to all endpoints of WorldCat Metadata API<ul> <li>Match bib records and retrieve bib classification</li> <li>Create, update, and validate bib records</li> <li>Create, retrieve, update, and delete local bib and holdings records</li> </ul> </li> <li>Add automatic retries to failed requests</li> <li>Authenticate and authorize for multiple institutions within <code>MetadataSession</code></li> <li>Support for Python 3.11 and 3.12</li> </ul>"},{"location":"#migration-information","title":"Migration Information","text":"<p>Bookops-Worldcat 1.0 introduces many breaking changes for users of previous versions. Due to a complete refactor of the Metadata API, the methods from Bookops-Worldcat 0.5.0 have been rewritten. Most of the functionality from previous versions of the Metadata API is still available in Version 2.0. For a comparison of the functionality available in Versions 1.0, 1.1, and 2.0 of the Metadata API, see OCLC's documentation and their functionality comparison table. </p> <p>Versions 1.0 and 1.1 of the Metadata API will be sunset after April 30, 2024 at which point tools that rely on Bookops-Worldcat 0.5 will no longer be able to query the Metadata API.</p>"},{"location":"#similar-functionality-new-method-names","title":"Similar functionality, new method names","text":"<p>Certain functionality has been retained from Bookops-Worldcat Version 0.5 but the methods have been renamed. See below for changes:</p> Functionality Bookops-Worldcat 0.5 Bookops-Worldcat 1.0 get brief bib resource <code>get_brief_bib</code> <code>brief_bibs_get</code> get full bib record <code>get_full_bib</code> <code>bib_get</code> get current holdings for record <code>holding_get_status</code> <code>holdings_get_current</code> set holdings on a record <code>holding_set</code> <code>holdings_set</code> unset holdings on a record <code>holding_unset</code> <code>holdings_unset</code> search for brief bibs <code>search_brief_bibs</code> <code>brief_bibs_search</code> get other editions of brief bibs <code>search_brief_bib_other_editions</code> <code>brief_bibs_get_other_editions</code> get current oclc number <code>search_current_control_numbers</code> <code>bib_get_current_oclc_number</code> search member holdings <code>search_general_holdings</code> <code>summary_holdings_search</code> search shared print holdings <code>search_shared_print_holdings</code> <code>shared_print_holdings_search</code>"},{"location":"#deprecated-functionality","title":"Deprecated functionality","text":"<p>Certain functionality has been deprecated within Version 2.0 of the Metadata API in including the following methods from Bookops-Worldcat 0.5:  </p> <ul> <li><code>holdings_set</code> and <code>holdings_unset</code><ul> <li>Users are no longer able to set holdings on multiple records in a single request and should instead send separate requests for each record.</li> </ul> </li> <li><code>holdings_set_multi_institutions</code> and <code>holdings_unset_multi_institutions</code><ul> <li>Users are no longer able to set holdings for multiple institutions with one request.</li> <li>If your WSKey is valid for multiple institutions, see section on Identifying Your Institution for an explanation of how to pass your RegistryID to the OCLC Authentication Server and obtain an Access Token.</li> </ul> </li> </ul>"},{"location":"about/","title":"BookOps","text":"<p>BookOps is a fully consolidated, shared library technical services organization that serves the Brooklyn Public Library (BPL) and the New York Public Library (NYPL).</p> <p>BookOps-Worldcat was glued together by Tomasz Kalata and Charlotte Kostelic with contributions by Miriam Gloger.</p>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#oclc-number-formatting","title":"OCLC Number Formatting","text":"<p><code>MetadataSession</code> accepts OCLC numbers in methods' arguments as integers or strings. OCLC numbers will be parsed with or without a prefix (eg. \"(OCoLC)\", \"ocm\", \"ocn\", or \"on\") to ensure they correspond to OCLC's formatting rules for OCLC control numbers. The following are all acceptable:</p> <p>Acceptable oclcNumber arguments<pre><code>session.brief_bibs_get(oclcNumber=\"ocm00012345\")\nsession.brief_bibs_search(oclcNumber=\"00054321\")\nsession.bib_get_classification(oclcNumber=12121)\nsession.brief_bibs_search(oclcNumber=\"(OCoLC)00054321\")\n</code></pre> The <code>bib_get_current_oclc_number</code> and <code>holdings_get_current</code> methods accept multiple OCLC Numbers passed to the <code>oclcNumbers</code> argument. For these methods OCLC Numbers can be passed as a list of strings and/or integers or a string with the numbers separated by commas. The <code>oclcNumbers</code> argument will also accept a single integer as a valid arguement. The following are all acceptable:</p> Acceptable oclcNumbers arguments<pre><code>session.holdings_get_current(oclcNumbers=[\"ocm00012345\", \"00012346\", \"12347\"])\nsession.holdings_get_current(oclcNumbers=[\"ocm00012345\", \"00012346\", 12347])\nsession.bib_get_current_oclc_number(oclcNumbers=\"ocm00012345, 00012346, 12347\")\nsession.bib_get_current_oclc_number(oclcNumbers=12347)\n</code></pre>"},{"location":"advanced/#authentication","title":"Authentication","text":""},{"location":"advanced/#worldcataccesstoken","title":"WorldcatAccessToken","text":"<p>A <code>WorldcatAccessToken</code> object retains the underlying Requests object functionality (<code>requests.Request</code>) which can be accessed via the <code>.server_response</code> attribute:</p> <p>Obtaining an Access Token<pre><code>from bookops_worldcat import WorldcatAccessToken\n\ntoken = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=\"WorldCatMetadataAPI\",\n    agent=\"my_app/version 1.0.0\"\n)\nprint(token.server_response.status_code)\n#&gt;200\nprint(token.server_response.elapsed):\n#&gt;0:00:00.650108\n</code></pre> Detailed information can be accessed using the <code>.json()</code> method. token.server_response.json()<pre><code>{\n  \"access_token\": \"tk_TokenString\", \n  \"expires_at\": \"2024-03-14 19:52:37Z\", \n  \"authenticating_institution_id\": \"00001\", \n  \"principalID\": \"\", \n  \"context_institution_id\": \"00001\",\n  \"scope\": \"WorldCatMetadataAPI:view_brief_bib\",  \n  \"scopes\": \"WorldCatMetadataAPI:view_brief_bib\",\n  \"token_type\": \"bearer\", \n  \"expires_in\": 1199, \n  \"principalIDNS\": \"\"\n}\n</code></pre> Users can check if the token has expired by calling the <code>is_expired</code> method: token.is_expired()<pre><code>print(token.is_expired())\n#&gt;False\n</code></pre> A failed token request raises a <code>WorldcatAuthorizationError</code> which provides the error code and detailed message returned by the server.</p> WorldcatAuthorizationError<pre><code>from bookops_worldcat import WorldcatAccessToken\n\ntoken = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=\"MetadataAPI\",\n    agent=\"my_app/version 1.0.0\"\n)\nprint(token)\n#&gt;bookops_worldcat.errors.WorldcatAuthorizationError: b'{\"code\":403,\"message\":\"Invalid scope(s): MetadataAPI (MetadataAPI) [Invalid service specified, Not on key]\"}'\n</code></pre>"},{"location":"advanced/#identifying-your-institution","title":"Identifying your institution","text":"<p>Though uncommon, users can request that OCLC set up their WSKeys to allow them to work on behalf of multiple institutions. The user can then authenticate on behalf of any of the institutions associated with that WSKey. </p> <p>If your WSKey is set up to work on behalf of multiple institutions, you can identify your institution when initiating a <code>WorldcatAccessToken</code> object. Pass the Registry ID for the institution you wish to work on behalf of to the scopes parameter as context.</p> Access Token with Context<pre><code>token = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=\"WorldCatMetadataAPI context:00001\",\n    agent=\"my_app/1.0.0\"\n)\n</code></pre>"},{"location":"advanced/#metadatasession","title":"MetadataSession","text":""},{"location":"advanced/#event-hooks","title":"Event hooks","text":"<p><code>MetadataSession</code> methods support Requests event hooks which can be passed as an argument:</p> Event Hooks<pre><code>def print_url(response, *args, **kwargs):\n    print(response.url)\n\nhooks = {'response': print_url}\nsession.brief_bibs_get(850939579, hooks=hooks)\n#&gt;https://metadata.api.oclc.org/worldcat/search/brief-bibs/850939579\n</code></pre>"},{"location":"advanced/#identifying-your-application","title":"Identifying your application","text":"<p>BookOps-Worldcat provides a default <code>user-agent</code> value in the headers of all requests to OCLC web services: <code>bookops-worldcat/{version}</code>. Users are encouraged to update the <code>user-agent</code> value to properly identify your application to OCLC servers. This will provide a useful piece of information for OCLC staff if they need to assist with any troubleshooting problems that may arise.</p> <p>To set a custom <code>user-agent</code> in a session simply pass it as an argument when initiating the session: Custom user-agent<pre><code>session = MetadataSession(authorization=token, agent=\"my_client_name\")\n</code></pre></p> <p>Alternatively, users can update the <code>.headers</code> attribute after initializing the session: Update MetadataSession headers<pre><code>session.headers.update({\"user-agent\": \"my-app/version 1.0\"})\n</code></pre></p> <p>The <code>user-agent</code> header can be set for an access token request as well. To do that simply pass it as the <code>agent</code> parameter when initiating <code>WorldcatAccessToken</code> object: WorldcatAccessToken with custom agent<pre><code>token = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=\"WorldCatMetadataAPI\",\n    agent=\"my_app/1.0.0\"\n)\n</code></pre></p>"},{"location":"advanced/#automatic-token-refresh","title":"Automatic Token Refresh","text":"<p>All requests made within a <code>MetadataSession</code> have a built-in access token auto-refresh feature. While a session is open, the current token will be checked for expiration before sending a request. If the token has expired, a new token will be obtained and the <code>MetadataSession</code> will continue to send requests.</p>"},{"location":"advanced/#retry-failed-requests","title":"Retry Failed Requests","text":"<p>Users can configure a <code>MetadataSession</code> to automatically retry failed requests. This functionality is customizable with the <code>totalRetries</code>, <code>backoffFactor</code>, <code>statusForcelist</code>, and <code>allowedMethods</code> arguments. </p> <p>Note</p> <p>It is recommended that users only allow for automatic retries on timeouts or other server errors. Users should also keep their automatic retries as low as possible in order to not overburden the web service. Users should not set up automatic retries for authentication (401, 403) or malformed request errors (400).</p> <p>MetadataSession with Retries<pre><code>with MetadataSession(\n    authorization=token,\n    totalRetries=3,\n    backoffFactor=0.1,\n    statusForcelist=[500, 502, 503, 504],\n    allowedMethods=[\"GET\"],\n) as session:\n    session.bib_get(\"12334\")\n</code></pre> Bookops-Worldcat will return a <code>RetryError</code> if a request is attempted up to the value of <code>totalRetries</code> and still fails.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#110-11152024","title":"1.1.0 - (11/15/2024)","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Support for new Metadata API functionality:</li> <li><code>bib_search</code> method within <code>MetadataSession</code> class allows users to retrieve full MARC records in JSON format with the new <code>/worldcat/search/bibs/{oclcNumber}</code></li> <li><code>cascadeDelete</code> arg added to <code>holdings_unset</code> and <code>holdings_unset_with_bib</code> methods. LHR and LBD records will be deleted when unsetting holdings on a record in WorldCat. This default functionality can be changed by setting <code>cascadeDelete</code> to <code>False</code></li> <li>Monthly live tests running via GitHub Actions</li> <li>Tests will check whether changes have been made to the Metadata API</li> <li>Python 3.13 added to unit tests</li> <li>Type annotations added to fixtures in <code>conftest.py</code></li> <li><code>scope</code> added as a return value in <code>WorldcatAccessToken</code> tests and documentation</li> <li>OCLC's Authorization Server now accepts and returns <code>scope</code> as a parameter but it appears to be interchangeable with <code>scopes</code>. It is listed in the tests and documentation for <code>WorldcatAccessToken</code> but is not included as an attribute for the class.</li> <li>Dev dependencies:</li> <li><code>types-pyyaml</code> (6.0.12)</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Moved live tests to separate files within <code>tests/webtests</code> directory</li> <li>Moved fixtures for live tests to <code>tests/webtests/conftest.py</code></li> <li>Minor edits to tests due to changes in responses from Metadata API</li> <li>Updated dependencies:</li> <li><code>certifi</code> (2024.8.30)</li> <li><code>charset-normalizer</code> (3.4.0)</li> <li><code>idna</code> (3.10)</li> <li><code>requests</code> (2.32.3)</li> <li><code>urllib3</code> (2.2.3)</li> <li>Updated dev dependencies:</li> <li><code>babel</code> (2.16.0)</li> <li><code>black</code> (24.8.0)</li> <li><code>coverage</code> (7.6.1)</li> <li><code>exceptiongroup</code> (1.2.2)</li> <li><code>griffe</code> (1.4.0)</li> <li><code>importlib-metadata</code> (8.5.0)</li> <li><code>importlib-resources</code> (6.4.5)</li> <li><code>jinja2</code> (3.1.4)</li> <li><code>markdown</code> (3.7)</li> <li><code>mike</code> (2.1.3)</li> <li><code>mkdocs-autorefs</code> (1.2.0)</li> <li><code>mkdocs-get-deps</code> (0.2.0)</li> <li><code>mkdocs-material</code> (9.5.46)</li> <li><code>mkdocs</code> (1.6.1)</li> <li><code>mkdocstrings-python</code> (1.11.1)</li> <li><code>mkdocstrings</code> (0.26.1)</li> <li><code>mypy</code> (1.13.0)</li> <li><code>packaging</code> (24.2)</li> <li><code>paginate</code> (0.5.7)</li> <li><code>platformdirs</code> (4.3.6)</li> <li><code>pluggy</code> (1.5.0)</li> <li><code>pygments</code> (2.18.0)</li> <li><code>pymdown-extensions</code> (10.12)</li> <li><code>pyparsing</code> (3.1.4)</li> <li><code>pytest-mock</code> (3.14.0)</li> <li><code>python-dateutil</code> (2.9.0.post0)</li> <li><code>pytz</code> (2024.2)</li> <li><code>pyyaml</code> (6.0.2)</li> <li><code>regex</code> (2024.11.6)</li> <li><code>tomli</code> (2.1.0)</li> <li><code>types-requests</code> (2.32.0.20241016)</li> <li><code>typing-extensions</code> (4.12.2)</li> <li><code>urllib3</code> (2.2.3)</li> <li><code>watchdog</code> (4.0.2)</li> <li><code>wheel</code> (0.45.1)</li> <li><code>zipp</code> (3.20.2)</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Return type for all <code>MetadataSession</code> methods is now <code>requests.Response</code> not <code>Optional[requests.Response]</code></li> <li>Typos and incorrect import statements</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Redundant/unused fixtures for mock 400 and 409 responses from <code>conftest.py</code></li> <li>Changed <code>stub_marc21</code> fixture to return <code>bytes</code> and removed <code>test.mrc</code> file</li> </ul>"},{"location":"changelog/#101-512024","title":"1.0.1 - (5/1/2024)","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Inconsistent default values for <code>timeout</code> arg for <code>MetadataSession</code>, <code>WorldcatAccessToken</code> and <code>Query</code> objects</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Updated dev dependencies:</li> <li>black (24.3.0)</li> <li>Updated dependencies:</li> <li>idna (3.7)</li> <li>Reformatted docstrings for better readability on https://bookops-cat.github.io/bookops-worldcat/</li> <li>Fixed typos</li> <li><code>prep_oclc_number_str</code> now parses OCLC Numbers with \"(OCoLC)\" prefix. Parsing rules match OCLC documentation</li> </ul>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Tutorials to <code>tutorials.md</code></li> </ul>"},{"location":"changelog/#100-3222024","title":"1.0.0 - (3/22/2024)","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Support for OCLC Metadata API Version 2.0<ul> <li><code>MetadataSession</code> methods to support new functionality released in Metadata API 2.0<ul> <li><code>bib_match</code></li> <li><code>bib_get_classification</code></li> <li><code>holdings_set_with_bib</code> and <code>holdings_unset_with_bib</code></li> </ul> </li> <li>New <code>MetadataSession</code> methods to support existing Metadata API functionality<ul> <li>Bib Record Management and Validation<ul> <li><code>bib_create</code></li> <li><code>bib_replace</code></li> <li><code>bib_validate</code></li> </ul> </li> <li>Local Holdings Records<ul> <li><code>lhr_create</code></li> <li><code>lhr_delete</code></li> <li><code>lhr_get</code></li> <li><code>lhr_replace</code></li> </ul> </li> <li>Local Bibliographic Data<ul> <li><code>lbd_create</code></li> <li><code>lbd_delete</code></li> <li><code>lbd_get</code></li> <li><code>lbd_replace</code></li> </ul> </li> <li>Holdings Management<ul> <li><code>holdings_get_codes</code></li> </ul> </li> </ul> </li> </ul> </li> <li>Support for automatic retries of failed requests</li> <li>Support for multi-institution WSKeys</li> <li>Support for Python 3.11 and 3.12</li> <li>New dev dependencies:<ul> <li>types-requests (2.31.0.20240125)</li> <li>mkdocs-material (9.5.13)</li> </ul> </li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li><code>MetadataSession</code> methods that have been renamed and updated (replacing existing functionality in Bookops-Worldcat): <ul> <li><code>get_brief_bib</code> is now <code>brief_bibs_get</code></li> <li><code>get_full_bib</code> is now <code>bib_get</code></li> <li><code>holding_get_status</code> is now <code>holdings_get_current</code></li> <li><code>holding_set</code> is now <code>holdings_set</code></li> <li><code>holding_unset</code> is now <code>holdings_unset</code></li> <li><code>search_brief_bib_other_editions</code> is now <code>brief_bibs_get_other_editions</code></li> <li><code>search_brief_bibs</code> is now <code>brief_bibs_search</code></li> <li><code>search_current_control_numbers</code> is now <code>bib_get_current_oclc_number</code></li> <li><code>search_general_holdings</code> is now <code>summary_holdings_search</code></li> <li><code>search_shared_print_holdings</code> is now <code>shared_print_holdings_search</code> </li> </ul> </li> <li><code>WorldcatAccessToken</code> <ul> <li><code>scopes</code> arg now only accepts strings. A <code>TypeError</code> is raised if <code>scopes</code> arg is passed a list</li> <li><code>token_expires_at</code> attribute is now an aware <code>datetime</code> object (change made due to <code>datetime.utcnow()</code> deprecation)</li> </ul> </li> <li>Error handling:<ul> <li><code>TypeError</code> and <code>ValueError</code> replace <code>WorldcatAuthorizationError</code> when <code>WorldcatAccessToken</code> is passed an invalid arg.</li> <li><code>MetadataSession</code> now raises <code>InvalidOclcNumber</code> exception when invalid OCLC identifiers are given</li> </ul> </li> <li><code>pytest</code> configuration moved from <code>pytest.ini</code> to <code>pyproject.toml</code></li> <li>Updated and clarified type annotations for <code>MetadataSession</code> methods</li> <li>Updated dependencies:<ul> <li>requests: (2.31)</li> </ul> </li> <li>Updated dev dependencies:<ul> <li>black (23.3.0)</li> <li>mike (2.0.0)</li> <li>mypy (1.0.14)</li> </ul> </li> <li>Documentation on https://bookops-cat.github.io/bookops-worldcat/ has been rewritten and reorganized</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li><code>AttributeError</code> changed to <code>TypeError</code> if arg passed to <code>Query.prepared_request</code> is not a <code>PreparedRequest</code></li> <li>All args for methods within <code>MetadataSession</code> have been changed to camel case to be consisted with Metadata API documentation</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li><code>principalID</code> and <code>principalIDNS</code> as args for <code>WorldcatAccessToken</code></li> <li>Automatic handling of large sets of oclcNumbers<ul> <li><code>_split_into_legal_volume</code> removed from <code>MetadataSession</code>; a <code>ValueError</code> is now raised if a method is passed too many oclcNumbers</li> </ul> </li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li>Support for Python 3.7</li> <li>409 error handling for holdings set/unset requests </li> <li><code>WorldcatSessionError</code> <ul> <li>Replaced with <code>TypeError</code> or <code>ValueError</code> in <code>WorldcatSession</code></li> </ul> </li> </ul>"},{"location":"changelog/#050-3112022","title":"0.5.0 - (3/11/2022)","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>feature to set and unset holdings for individual record for multiple institutions (/ih/institutionlist endpoint)</li> <li><code>__repr__</code> method to <code>WorldcatAccessToken</code> object</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>\"refreshing\" of access tokens moved to <code>_session.WorldcatSession</code> from <code>metadata_api.MetadataSession</code> to allow inheritance of this functionality by future clients</li> <li>refactors some of tests</li> </ul>"},{"location":"changelog/#041-2102022","title":"0.4.1 - (2/10/2022)","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Handling of unexpected 206 HTTP code that is occasionally returned by the MetadataAPI /brief-bibs endpoint</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Introduced a breaking change to exceptions raised on calls to the web service for bibliographic resources: <code>WorldcatSessionError</code> was changed to <code>WorldcatRequestError</code>. </li> <li>Dev dependencies updates (pytest, pytest-cov, pytest-mock, mkdocs, black, mik, mkapi, mypy)</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>requests to OCLC services are now handled by a new <code>query.Query</code> class</li> <li>dependencies update<ul> <li>requests to 2.27.1</li> <li>dev dependencies</li> </ul> </li> </ul>"},{"location":"changelog/#040-6222021","title":"0.4.0 - (6/22/2021)","text":""},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Changes to <code>MetadataSession.search_brief_bibs</code> method due to /brief-bibs endpoint changes:<ul> <li>removed deprecated argument <code>heldBy</code></li> <li>added <code>groupVariantRecord</code> and <code>preferredLanguage</code> argument</li> <li>modified <code>groupRelatedEditions</code> to allow boolean arguments</li> </ul> </li> <li>Changes to <code>MetadataSession.search_general_holdings</code> method due to API changes:<ul> <li>added following arguments: <code>holdingsAllVariantRecords</code>, <code>preferredLanguage</code></li> <li>removed deprecated <code>heldBy</code> argument</li> </ul> </li> <li>Changes to <code>MetadataSession.search_brief_bib_other_editions</code>:<ul> <li>added <code>deweyNumber</code>, <code>datePublished</code>, <code>heldByGroup</code>, <code>heldBySymbol</code>,  <code>heldByInstitutionId</code>, <code>inLanguage</code>, <code>inCatalogLanguage</code>, <code>materialType</code>,  <code>catalogSource</code>, <code>itemType</code>, <code>itemSubType</code>, <code>retentionCommitments</code>,  <code>spProgram</code>, <code>topic</code>, <code>subtopic</code>, <code>audience</code>, <code>content</code>, <code>openAccess</code>,  <code>peerReviewed</code>, <code>facets</code>, <code>groupVariantRecords</code>, <code>preferredLanguage</code>,  and <code>orderBy</code>. </li> </ul> </li> </ul>"},{"location":"changelog/#035-622021","title":"0.3.5 - (6/2/2021)","text":""},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Dependencies update<ul> <li>urllib3 from 1.26.4 to 1.26.5</li> </ul> </li> </ul>"},{"location":"changelog/#034-3222021","title":"0.3.4 - (3/22/2021)","text":""},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Dependencies update<ul> <li>certifi to 2020.12.5</li> <li>chardet to 4.0.0</li> <li>requests to 2.25.1</li> <li>urllib3 to 1.26.4</li> </ul> </li> </ul>"},{"location":"changelog/#033-12282020","title":"0.3.3 - (12/28/2020)","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Type hints</li> <li>Default timeout in the MetadataSession extended to 5 seconds</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Dependencies:<ul> <li>pytest bump to 6.1.2</li> <li>mypy 0.7.8</li> </ul> </li> </ul>"},{"location":"changelog/#032-11252020","title":"0.3.2 - (11/25/2020)","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>MetadataSession timeout parameter correctly passed into every session request</li> </ul>"},{"location":"changelog/#031-11242020","title":"0.3.1 - (11/24/2020)","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Fixed auto refreshing of the access token when expired</li> <li>testing: fixed testing for error messages on exceptions &amp; testing of stale tokens</li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>Dependencies bump<ul> <li>certifi from 2020.6.20 to 2020.11.8</li> <li>requests from 2.24.0 to 2.25.0</li> <li>urllib3 from 1.25.10 to 1.26.2</li> </ul> </li> </ul>"},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Added Python 3.9 testing to CI</li> </ul>"},{"location":"changelog/#030-10032020","title":"0.3.0 - (10/03/2020)","text":""},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>Introduces multiple breaking changes compared to the previous version!</li> <li>Dropped features related to the WorldCat Search API</li> <li>Support for Worldcat Metadata API v.1.1 introduced in May 2020</li> <li>Supported Metadata API endpoints:<ul> <li>/bibs-retained-holdings</li> <li>/bibs-summary-holdings</li> <li>/brief-bibs</li> <li>/brief-bibs/{oclcNumber}</li> <li>/brief-bibs/{oclcNumber}/other-editions</li> <li>/bib/data/{oclcNumber}</li> <li>/bib/checkcontrolnumbers</li> <li>/ih/data (POST|DELETE)</li> <li>/ih/checkholdings</li> <li>/ih/datalist (POST|DELETE)</li> </ul> </li> </ul>"},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>API reference added to docs with mkapi</li> </ul>"},{"location":"changelog/#021-9282020","title":"0.2.1 - (9/28/2020)","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>added functionality for docs versioning with mike</li> </ul>"},{"location":"changelog/#020-04302020","title":"0.2.0 - (04/30/2020)","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Expanded and improved documentation</li> <li>Customizable \"user-agent\" in session header and token request</li> <li><code>TokenRequestError</code> exception added on failed access token request</li> </ul>"},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>SRU/CQL query syntax aligned with OCLC specifications</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>fixed hooks info in docstrings in <code>SearchSession</code> and <code>MetadataSession</code></li> </ul>"},{"location":"contributing/","title":"How to Contribute","text":"<p>We welcome collaborators who would like to help expand and improve Bookops-Worldcat. Here are some ways to contribute.</p>"},{"location":"contributing/#report-bugs-or-suggest-enhancements","title":"Report bugs or suggest enhancements","text":"<p>Please use our Github issue tracker to submit bug reports or request new features.</p>"},{"location":"contributing/#contribute-code-or-documentation","title":"Contribute code or documentation","text":"Info <p>This page contains a draft of our contribution guidelines but there is still more for us to add.</p> <p>TO DO:</p> <ul> <li>Add style guide for documentation<ul> <li>docstring style conventions</li> <li>type hints</li> <li>how to build docs after making edits</li> </ul> </li> <li>Add CI/CD info</li> </ul>"},{"location":"contributing/#style-and-requirements","title":"Style and Requirements","text":"<p>For new code contributions, please use the tools and standards in place for Bookops-Worldcat:</p> <ul> <li>Code style:<ul> <li>Formatting with black</li> <li>Linting with flake8</li> <li>Static type checking with mypy</li> </ul> </li> <li>Dependency management and package publishing with Poetry</li> <li>Documentation written in Markdown using MkDocs and plugins<ul> <li>Theme is Material for MkDocs</li> <li>Versioning maintained with Mike</li> <li>API Documentation built with MkAPI</li> </ul> </li> <li>Tests written with pytest</li> </ul> Tip <p>If you use VS Code there are certain extensions which will automate code formatting and support some of our code style requirements which may make your work easier while contributing to Bookops-Worldcat. Similar extensions are available on other IDEs. Those extensions include:</p> <ul> <li>Black Formatter</li> <li>Flake8</li> <li>Mypy Type Checker</li> <li>Markdown All in One</li> </ul> <p>Additions to add to your settings.json file: settings.json for VS Code<pre><code>{\n    \"editor.defaultFormatter\": \"ms-python.black-formatter\",\n    \"editor.formatOnSave\": true,\n    \"flake8.args\": [\n        \"--max-line-length=88\",\n    ],\n}\n</code></pre></p>"},{"location":"contributing/#install-and-setup","title":"Install and Setup","text":"<p>To get started contributing code to Bookops-Worldcat you will need: </p> <ul> <li>Python 3.8 or newer</li> <li><code>git</code></li> <li><code>poetry</code></li> </ul>"},{"location":"contributing/#install-poetry","title":"Install Poetry","text":"<p>Bookops-Worldcat uses <code>poetry</code> to manage virtual environments, dependencies, and publishing workflows. We use <code>pipx</code> to run poetry (if you don't have <code>pipx</code>, see the installation instructions). For other installation options, see the <code>poetry</code> documentation.</p>"},{"location":"contributing/#fork-the-repo","title":"Fork the repo","text":"<p>Fork the repository in GitHub and clone your fork locally <pre><code>git clone https://github.com/&lt;your username&gt;/bookops-worldcat\ncd bookops-worldcat\n</code></pre></p>"},{"location":"contributing/#create-a-new-branch-for-your-changes","title":"Create a new branch for your changes","text":"<pre><code>git checkout -b new-branch\n</code></pre>"},{"location":"contributing/#create-a-virtual-environment-and-install-dependencies","title":"Create a virtual environment and install dependencies","text":"<p>Poetry will create a virtual environment, read the <code>pyproject.toml</code> and <code>poetry.lock</code> files, resolve dependencies, and install them with one command.  <pre><code>poetry install\n</code></pre></p>"},{"location":"contributing/#run-tests","title":"Run tests","text":"<p>Run tests before making changes on your fork.</p> Info <p>Our live tests are designed to look for API credentials in a specific file/directory when running webtests locally. Live tests are also run on a monthly basis in GitHub Actions using credentials saved in the repository's secrets. Pull requests from public forks will not run live webtests and we will need to refactor the <code>live_keys</code> fixture if a contributor wishes to run live webtests locally using their own API credentials.</p> <pre><code># basic usage without webtests\npython -m pytest \"not webtest\"\n# with test coverage and without webtests\npython -m pytest \"not webtest\" --cov=bookops_worldcat/\n</code></pre>"},{"location":"contributing/#release-checklist","title":"Release Checklist","text":"<p>Any major or minor updates should get a new release in GitHub. Use the following checklist when getting a new update ready for release. For patch updates/bug fixes, follow steps 1-4.</p> <ol> <li>Verify <code>poetry.lock</code>, <code>pyproject.toml</code>, <code>requirements.txt</code>, and <code>dev-requirements.txt</code> files are up-to-date<ul> <li><code>poetry check</code> to check that <code>poetry.lock</code> and <code>pyproject.toml</code> files are in sync </li> <li><code>poetry update</code> to update all packages </li> <li>or <code>poetry update [package1] [ package2]</code> to update packages individually</li> <li><code>poetry install</code> to install all versions of packages listed in the <code>pyproject.toml</code> file</li> <li>Export <code>requirements.txt</code> files with poetry-plugin-export</li> </ul> </li> <li>Update documentation<ul> <li>Update changelog: include version, date, and descriptions of changes</li> <li>Update links within docs if OCLC has made any changes</li> </ul> </li> <li>Commit changes to repo<ul> <li>Merge all changes into <code>release/v[version]</code> branch</li> <li>Ensure tests have run and passed within GitHub Actions</li> </ul> </li> <li>Rebuild docs using mike:<ul> <li><code>mike --rebase</code> to fetch remote version of docs to your local branch (optional)</li> <li><code>mike deploy [version] [alias] --push</code> to deploy docs</li> <li><code>mike set-default [version]</code> to set new version to default</li> </ul> </li> <li>Create a new github release<ul> <li>At minimum, include information from changelog in release. Include additional details about changes as appropriate.</li> </ul> </li> <li>Build package in poetry<ul> <li><code>poetry build</code></li> </ul> </li> <li>Publish to PyPI<ul> <li><code>poetry publish</code></li> </ul> </li> </ol>"},{"location":"local/","title":"Search and Manage Local Data","text":"<p>New functionality available in Version 1.0 of Bookops-Worldcat allows users to search and manage local bibliographic and holdings data via the Metadata API. </p> <p>Users can also manage local bibliographic and holdings data when managing institution holdings. When unsetting holdings on a record in OCLC, users can remove associated LBDs and/or LHRs. SeeManage Institution Holdings &gt; Set and Unset Holdings for more information.</p>"},{"location":"local/#manage-local-bib-records","title":"Manage Local Bib Records","text":"<p>Users can manage local bib records in WorldCat in the same way that they manage WorldCat records (see Managing Bibliographic Records for more information). Records can be retrieved in MARCXML or MARC21 formats. The default format for records is MARCXML.  </p> lbd_createlbd_getlbd_replacelbd_delete <p>lbd_create MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.lbd_create(\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(response.content)\n</code></pre> lbd_create MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000n   a2200000   4500&lt;/leader&gt;\n    &lt;controlfield tag=\"001\"&gt;12345&lt;/controlfield&gt;\n    &lt;controlfield tag=\"004\"&gt;3160&lt;/controlfield&gt;\n    &lt;controlfield tag=\"005\"&gt;20240320120824.8&lt;/controlfield&gt;\n    &lt;datafield tag=\"935\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;MyLSN&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"940\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;NYP&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p> <p>lbd_get MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.lbd_get(\"12345\")\n    print(response.content)\n</code></pre> lbd_get MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000n   a2200000   4500&lt;/leader&gt;\n    &lt;controlfield tag=\"001\"&gt;12345&lt;/controlfield&gt;\n    &lt;controlfield tag=\"004\"&gt;3160&lt;/controlfield&gt;\n    &lt;controlfield tag=\"005\"&gt;20240320120824.8&lt;/controlfield&gt;\n    &lt;datafield tag=\"935\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;MyLSN&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"940\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;NYP&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p> <p>lbd_replace MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.lbd_replace(\n            controlNumber=\"12345\",\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(response.content)\n</code></pre> lbd_replace MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000n   a2200000   4500&lt;/leader&gt;\n    &lt;controlfield tag=\"001\"&gt;12345&lt;/controlfield&gt;\n    &lt;controlfield tag=\"004\"&gt;3160&lt;/controlfield&gt;\n    &lt;controlfield tag=\"005\"&gt;20240320120824.8&lt;/controlfield&gt;\n    &lt;datafield tag=\"935\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;MyLSN&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"940\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;NYP&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p> <p>lbd_delete MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.lbd_delete(\"12345\")\n    print(response.content)\n</code></pre> lbd_delete MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000n   a2200000   4500&lt;/leader&gt;\n    &lt;controlfield tag=\"001\"&gt;12345&lt;/controlfield&gt;\n    &lt;controlfield tag=\"004\"&gt;3160&lt;/controlfield&gt;\n    &lt;controlfield tag=\"005\"&gt;20240320120824.8&lt;/controlfield&gt;\n    &lt;datafield tag=\"935\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;MyLSN&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"940\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;NYP&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p>"},{"location":"local/#search-local-bib-resources","title":"Search Local Bib Resources","text":"<p>Users can search for and retrieve brief local bib resources <code>local_bibs_get</code> and <code>local_bibs_search</code> methods. The response will be in JSON format.</p> local_bibs_getlocal_bibs_search <p>local_bibs_get Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.local_bibs_get(123456789)\n    print(response.json())\n</code></pre> local_bibs_get Response<pre><code>{\n  \"controlNumber\": 123456789,\n  \"oclcNumber\": \"987654321\",\n  \"title\": {\n    \"uniformTitles\": [\n      \"Test Book\"\n      ]\n    },\n  \"contributor\": {\n    \"creators\": [\n      {\n        \"firstName\": {\n          \"text\": \"Test\"\n        },\n        \"secondName\": {\n          \"text\": \"Author\"\n        },\n        \"type\": \"person\"\n      }\n    ]\n  },\n  \"localSystemNumber\": \"System.Supplied@2024-03-20,11:50:40\",\n  \"lastUpdated\": 20240320\n}\n</code></pre></p> <p>local_bibs_search Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.local_bibs_search(q=\"ti: Test Book AND au: Test Author\")\n    print(response.json())\n</code></pre> local_bibs_search Response<pre><code>{\n  \"numberOfRecords\": 1,\n  \"records\": [\n    {\n      \"controlNumber\": 123456789,\n      \"oclcNumber\": \"987654321\",\n      \"title\": {\n        \"uniformTitles\": [\n          \"Test Book\"\n        ]\n      },\n      \"contributor\": {\n      \"creators\": [\n        {\n          \"firstName\": {\n            \"text\": \"Test\"\n          },\n          \"secondName\": {\n            \"text\": \"Author\"\n          },\n          \"type\": \"person\"\n        }\n      ]\n    },\n    \"localSystemNumber\": \"System.Supplied@2024-03-20,11:50:40\",\n    \"lastUpdated\": 20240320\n    }\n  ]\n}\n</code></pre></p>"},{"location":"local/#manage-local-holdings-records","title":"Manage Local Holdings Records","text":"<p>Users can manage local holdings records using Bookops-Worldcat in the same way that they manage local bib records (see above: Managing Local Bib Records for more information).</p> lhr_createlhr_getlhr_replacelhr_delete <p>lhr_create MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.lhr_create(\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(response.content)\n</code></pre> lhr_create MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000nx  a2200000zi 4500&lt;/leader&gt;\n    &lt;controlfield tag='004'&gt;00001&lt;/controlfield&gt;\n    &lt;controlfield tag='005'&gt;20240320085741.4&lt;/controlfield&gt;\n    &lt;controlfield tag='007'&gt;zu&lt;/controlfield&gt;\n    &lt;controlfield tag='008'&gt;2403200p    0   4001uueng0210908&lt;/controlfield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='852'&gt;\n        &lt;subfield code='a'&gt;NYP&lt;/subfield&gt;\n        &lt;subfield code='b'&gt;TEST&lt;/subfield&gt;\n        &lt;subfield code='c'&gt;TEST-STACKS&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='876'&gt;\n        &lt;subfield code='p'&gt;00001&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p> <p>lhr_get MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.lhr_get(\"12345\")\n    print(response.content)\n</code></pre> lhr_get MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000nx  a2200000zi 4500&lt;/leader&gt;\n    &lt;controlfield tag='001'&gt;12345&lt;/controlfield&gt;\n    &lt;controlfield tag='004'&gt;00001&lt;/controlfield&gt;\n    &lt;controlfield tag='005'&gt;20240320085741.4&lt;/controlfield&gt;\n    &lt;controlfield tag='007'&gt;zu&lt;/controlfield&gt;\n    &lt;controlfield tag='008'&gt;2403200p    0   4001uueng0210908&lt;/controlfield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='852'&gt;\n        &lt;subfield code='a'&gt;NYP&lt;/subfield&gt;\n        &lt;subfield code='b'&gt;TEST&lt;/subfield&gt;\n        &lt;subfield code='c'&gt;TEST-STACKS&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='876'&gt;\n        &lt;subfield code='p'&gt;00001&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p> <p>lhr_replace MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = io.BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.lhr_replace(\n            controlNumber=\"12345\",\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(response.content)\n</code></pre> lhr_replace MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000nx  a2200000zi 4500&lt;/leader&gt;\n    &lt;controlfield tag='001'&gt;12345&lt;/controlfield&gt;\n    &lt;controlfield tag='004'&gt;00001&lt;/controlfield&gt;\n    &lt;controlfield tag='005'&gt;20240320085741.4&lt;/controlfield&gt;\n    &lt;controlfield tag='007'&gt;zu&lt;/controlfield&gt;\n    &lt;controlfield tag='008'&gt;2403200p    0   4001uueng0210908&lt;/controlfield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='852'&gt;\n        &lt;subfield code='a'&gt;NYP&lt;/subfield&gt;\n        &lt;subfield code='b'&gt;TEST&lt;/subfield&gt;\n        &lt;subfield code='c'&gt;TEST-STACKS&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='876'&gt;\n        &lt;subfield code='p'&gt;00001&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p> <p>lhr_delete MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.lhr_delete(\"12345\")\n    print(response.content)\n</code></pre> lhr_delete MARCXML Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000nx  a2200000zi 4500&lt;/leader&gt;\n    &lt;controlfield tag='001'&gt;12345&lt;/controlfield&gt;\n    &lt;controlfield tag='004'&gt;00001&lt;/controlfield&gt;\n    &lt;controlfield tag='005'&gt;20240320085741.4&lt;/controlfield&gt;\n    &lt;controlfield tag='007'&gt;zu&lt;/controlfield&gt;\n    &lt;controlfield tag='008'&gt;2403200p    0   4001uueng0210908&lt;/controlfield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='852'&gt;\n        &lt;subfield code='a'&gt;NYP&lt;/subfield&gt;\n        &lt;subfield code='b'&gt;TEST&lt;/subfield&gt;\n        &lt;subfield code='c'&gt;TEST-STACKS&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='876'&gt;\n        &lt;subfield code='p'&gt;00001&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p>"},{"location":"local/#managing-shared-print-commitments","title":"Managing Shared Print Commitments","text":"<p>Users can manage Shared Print collections using the Metadata API by adding Shared Print flags to their Local Holdings Records. More information on managing Shared Print collections is available on OCLC's website and information about managing Shared Print collections via the Metadata API is available on OCLC's Developer Network Site.</p> MARC/XML with retention commitment in MARC 583 field<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000nx  a2200000zi 4500&lt;/leader&gt;\n    &lt;controlfield tag='004'&gt;00001&lt;/controlfield&gt;\n    &lt;controlfield tag='005'&gt;20240320085741.4&lt;/controlfield&gt;\n    &lt;controlfield tag='007'&gt;ta&lt;/controlfield&gt;\n    &lt;controlfield tag='008'&gt;2403200c    8   4001aaeng0240401&lt;/controlfield&gt;\n    &lt;datafield ind2='1' ind1=' ' tag='583'&gt;\n        &lt;subfield code='a'&gt;committed to retain&lt;/subfield&gt;\n        &lt;subfield code='c'&gt;20240101&lt;/subfield&gt;\n        &lt;subfield code='d'&gt;in perpetuity&lt;/subfield&gt;\n        &lt;subfield code='f'&gt;Test Program&lt;/subfield&gt;\n        &lt;subfield code='5'&gt;NYP&lt;/subfield&gt;                \n    &lt;/datafield&gt;    \n    &lt;datafield ind2=' ' ind1=' ' tag='852'&gt;\n        &lt;subfield code='a'&gt;NYP&lt;/subfield&gt;\n        &lt;subfield code='b'&gt;TEST&lt;/subfield&gt;\n        &lt;subfield code='c'&gt;TEST-STACKS&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield ind2=' ' ind1=' ' tag='876'&gt;\n        &lt;subfield code='p'&gt;00001&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre>"},{"location":"local/#search-local-holdings-resources","title":"Search Local Holdings Resources","text":"<p>Users can browse, search for and retrieve brief local holdings data in JSON format using the <code>local_holdings_get</code>, <code>local_holdings_search</code>, <code>local_holdings_browse</code>, and <code>local_holdings_search_shared_print</code> methods:</p> local_holdings_getlocal_holdings_searchlocal_holdings_browselocal_holdings_search_shared_print <p>local_holdings_get Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.local_holdings_get(controlNumber=\"111111111\")\n    print(response.json())\n</code></pre> local_holdings_get Response<pre><code>{\n  \"numberOfHoldings\": 1,\n  \"detailedHoldings\": [\n    {\n      \"lhrControlNumber\": \"111111111\",\n      \"lhrDateEntered\": \"20240101\",\n      \"lhrLastUpdated\": \"20240201\",\n      \"oclcNumber\": \"123456789\",\n      \"format\": \"zu\",\n      \"location\": {\n        \"holdingLocation\": \"NYP\",\n        \"sublocationCollection\": \"TEST\",\n        \"shelvingLocation\": \"TEST-STACKS\"\n      },\n      \"copyNumber\": \"1\",\n      \"callNumber\": {\n        \"displayCallNumber\": \"TEST\",\n        \"classificationPart\": \"TEST\"\n      },\n      \"hasSharedPrintCommitment\": \"N\",\n      \"summary\": \"Local holdings available.\",\n      \"holdingParts\": [\n        {\n        \"pieceDesignation\": \"TEST12345\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre></p> <p>local_holdings_search Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.local_holdings_search(\n        oclcNumber=\"123456789\", \n        orderBy=\"location\"\n        )\n    print(response.json())\n</code></pre> local_holdings_search Response<pre><code>{\n  \"numberOfHoldings\": 1,\n  \"detailedHoldings\": [\n    {\n      \"lhrControlNumber\": \"111111111\",\n      \"lhrDateEntered\": \"20240101\",\n      \"lhrLastUpdated\": \"20240201\",\n      \"oclcNumber\": \"123456789\",\n      \"format\": \"zu\",\n      \"location\": {\n        \"holdingLocation\": \"NYP\",\n        \"sublocationCollection\": \"TEST\",\n        \"shelvingLocation\": \"TEST-STACKS\"\n      },\n      \"copyNumber\": \"1\",\n      \"callNumber\": {\n        \"displayCallNumber\": \"TEST\",\n        \"classificationPart\": \"TEST\"\n      },\n      \"hasSharedPrintCommitment\": \"N\",\n      \"summary\": \"Local holdings available.\",\n      \"holdingParts\": [\n        {\n        \"pieceDesignation\": \"TEST12345\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre></p> <p>local_holdings_browse Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.local_holdings_browse(\n        callNumber=\"ReCAP-000000\", \n        holdingLocation=\"TEST-LOCATION\",\n        shelvingLocation=\"TEST-STACKS\",\n        )\n    print(response.json())\n</code></pre> local_holdings_browse Response<pre><code>{\n  \"numberOfRecords\": 1,\n  \"entries\": [\n    {\n      \"displayCallNumber\": \"ReCAP-000000\",\n      \"holdingLocation\": \"TEST-LOCATION\",\n      \"shelvingLocation\": \"TEST-STACKS\",\n      \"pieceDesignation\": \"123456789\",\n      \"oclcNumber\": 000000000,\n      \"title\": \"Test\",\n      \"creator\": \"Author, Test\",\n      \"date\": \"2024\",\n      \"language\": \"eng\",\n      \"generalFormat\": \"Book\",\n      \"specificFormat\": \"PrintBook\",\n      \"edition\": \"1st ed.\",\n      \"publisher\": \"Test\",\n      \"publicationPlace\": \"New York :\"\n    },\n  ]\n}\n</code></pre></p> <p>local_holdings_search_shared_print Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.local_holdings_search_shared_print(\n        oclcNumber=\"123456789\", \n        orderBy=\"location\"\n        )\n    print(response.json())\n</code></pre> local_holdings_search_shared_print Response<pre><code>{\n  \"numberOfHoldings\": 1,\n  \"detailedHoldings\": [\n    {\n      \"lhrControlNumber\": \"111111111\",\n      \"lhrDateEntered\": \"20240101\",\n      \"lhrLastUpdated\": \"20240201\",\n      \"oclcNumber\": \"123456789\",\n      \"format\": \"zu\",\n      \"location\": {\n        \"holdingLocation\": \"NYP\",\n        \"sublocationCollection\": \"TEST\",\n        \"shelvingLocation\": \"TEST-STACKS\"\n      },\n      \"copyNumber\": \"1\",\n      \"callNumber\": {\n        \"displayCallNumber\": \"TEST\",\n        \"classificationPart\": \"TEST\"\n      },\n      \"hasSharedPrintCommitment\": \"Y\",\n      \"summary\": \"Local holdings available.\",\n      \"holdingParts\": [\n        {\n        \"pieceDesignation\": \"TEST12345\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre></p>"},{"location":"manage_bibs/","title":"Manage Bibliographic Records","text":"<p>Note</p> <p>Users must have \"WorldCatMetadataAPI:manage_bibs\" in the list of scopes for their WSKeys in order to manage bib records using the Metadata API. To check if your WSKey has access to these endpoints, log into your WSKey Management portal. </p>"},{"location":"manage_bibs/#get-full-marc-records","title":"Get Full MARC Records","text":"<p>Users can retrieve full MARC records from WorldCat by passing the <code>bib_get</code> method an OCLC number. The Metadata API correctly matches OCLC numbers of records that have been merged together and returns the current master record. Records can be retrieved in MARCXML or MARC21 formats. The default format is MARCXML.  </p> bib_get<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.bib_get(\"321339\")\n    print(response.status_code)\n#&gt;200\n    print(response.url)\n#&gt;\"https://metadata.api.oclc.org/worldcat/manage/bibs/321339\"\n</code></pre> <p>To avoid raising a <code>UnicodeEncodeError</code> when requesting full bib records it is recommended that one access the response data using the <code>.content</code> attribute of the response object:</p> MARCXMLMARC21 <p>bib_get MARCXML Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.bib_get(\"321339\")\n    print(response.content)\n</code></pre> bib_get MARCXML Response<pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt;\n  &lt;record xmlns=\"http://www.loc.gov/MARC21/slim\"&gt;\n    &lt;leader&gt;00000cam a22000001a 4500&lt;/leader&gt;\n    &lt;controlfield tag=\"001\"&gt;ocm00321339&lt;/controlfield&gt;\n    &lt;controlfield tag=\"003\"&gt;OCoLC&lt;/controlfield&gt;\n    &lt;controlfield tag=\"005\"&gt;20240202180208.2&lt;/controlfield&gt;\n    &lt;controlfield tag=\"008\"&gt;711005s1967    nyu           000 f eng  &lt;/controlfield&gt;\n    &lt;datafield tag=\"010\" ind1=\" \" ind2=\" \"&gt;\n      &lt;subfield code=\"a\"&gt;   67022898 &lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;!--...--&gt;\n    &lt;datafield tag=\"100\" ind1=\"1\" ind2=\" \"&gt;\n      &lt;subfield code=\"a\"&gt;Bulgakov, Mikhail,&lt;/subfield&gt;\n      &lt;subfield code=\"d\"&gt;1891-1940.&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"240\" ind1=\"1\" ind2=\"0\"&gt;\n      &lt;subfield code=\"a\"&gt;Master i Margarita.&lt;/subfield&gt;\n      &lt;subfield code=\"l\"&gt;English&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"245\" ind1=\"1\" ind2=\"4\"&gt;\n      &lt;subfield code=\"a\"&gt;The master and Margarita /&lt;/subfield&gt;\n      &lt;subfield code=\"c\"&gt;Mikhail Bulgakov ; translated from the Russian by Michael Glenny.&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;!--...--&gt;\n&lt;/record&gt;\n</code></pre></p> <p>bib_get MARC21 Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.bib_get(\"321339\", responseFormat=\"application/marc\")\n    print(response.content)\n</code></pre> bib_get MARC21 Response<pre><code>04305cam a22007691a 4500001001200000003000600012005001700018008004100035010001700076040024300093016002500336019009500361029002200456029002100478029001800499029002200517035016600539037001700705041001300722043001200735050001900747050002500766055002600791082001700817100003500834240003300869245009800902250001701000260003901017300002701056336002601083337002801109338002701137500001101164500016401175500008201339500003201421520019801453546004501651505080201696583004802498651002702546650001602573650002402589651004702613651003002660651002302690651002502713655002302738655001602761655005802777655004802835655002102883655001802904655002802922655002302950655003002973655002303003655002903026655002203055655002503077700002103102700004003123758015803163776017003321938004403491\\x1eocm00321339\\x1eOCoLC\\x1e20240202180208.2\\x1e711005s1967    nyu           000 f eng  \\x1faBulgakov, Mikhail,\\x1fd1891-1940.\\x1e10\\x1faMaster i Margarita.\\x1flEnglish\\x1e14\\x1faThe master and Margarita /\\x1fcMikhail Bulgakov ; translated from the Russian by Michael Glenny.\n</code></pre></p>"},{"location":"manage_bibs/#get-current-oclc-numbers","title":"Get Current OCLC Numbers","text":"<p>The <code>bib_get_current_oclc_number</code> method allows users to retrieve the current control number of a WorldCat record. Occasionally, records identified as duplicates in WorldCat have been merged and in that case a local control number may not correctly refer to the WorldCat record. </p> <p>bib_get_current_oclc_number Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.bib_get_current_oclc_number(\"992611164\")\n    print(response.json())\n</code></pre> bib_get_current_oclc_number Response<pre><code>{\n  \"controlNumbers\": [\n    {\n      \"requested\": \"992611164\",\n      \"current\": \"321339\"\n    }\n  ]\n}\n</code></pre></p>"},{"location":"manage_bibs/#advanced-bib-record-functionality","title":"Advanced Bib Record Functionality","text":"<p>Several of the <code>/manage/bibs/</code> endpoints take a MARC record in the body of the request. When passing MARC records to any of these endpoints, users should ensure that the format passed in the <code>recordFormat</code> argument matches the format of the data passed in the request body using the <code>record</code> argument.</p>"},{"location":"manage_bibs/#match-bib-records","title":"Match Bib Records","text":"<p>Users can pass a bib record in MARCXML or MARC21 to the <code>bib_match</code> method and the web service will identify the best match for the record in WorldCat. The response will be a brief bib resource in JSON.</p> MARCXMLMARC21 bib_match Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_match(\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(response.json())\n</code></pre> bib_match Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.mrc\",\"rb\") as mrc_file:\n    for r in mrc_file:\n        mrc_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_match(\n            record=mrc_record, \n            recordFormat=\"application/marc\"\n        )\n        print(response.json())\n</code></pre> bib_match Response<pre><code>{\n  \"numberOfRecords\": 1, \n  \"briefRecords\": [\n    {\n      \"oclcNumber\": \"321339\", \n      \"title\": \"The master and Margarita\", \n      \"creator\": \"Mikhail Bulgakov\", \n      \"date\": \"\u00a91967\", \n      \"machineReadableDate\": \"1967\", \n      \"language\": \"eng\", \n      \"generalFormat\": \"Book\", \n      \"specificFormat\": \"PrintBook\", \n      \"edition\": \"1st U.S. ed\", \n      \"publisher\": \"Harper &amp; Row\", \n      \"publicationPlace\": \"New York\", \n      \"isbns\": [], \n      \"issns\": [], \n      \"mergedOclcNumbers\": [\n        \"68172169\", \n        \"977269772\", \n        \"992611164\", \n        \"1053636208\", \n        \"1086334687\", \n        \"1089359174\", \n        \"1126595016\", \n        \"1154557860\"\n      ], \n      \"catalogingInfo\": {\n        \"catalogingAgency\": \"DLC\", \n        \"catalogingLanguage\": \"eng\", \n        \"levelOfCataloging\": \"1\", \n        \"transcribingAgency\": \"DLC\"\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"manage_bibs/#create-bib-records","title":"Create Bib Records","text":"<p>Users can create new WorldCat records using the <code>bib_create</code> method. The web service will check if the record exists in WorldCat and create a new record if it does not. Users should pass passed a valid MARC record in MARCXML or MARC21 format in the body of the request. </p> <p>The response returned by the web service will contain the WorldCat record in the format specified in the <code>responseFormat</code> parameter with its newly added OCLC Number.</p> <p>Note</p> <p>It is recommended that users validate their records before trying to create new records in WorldCat in order to avoid errors. See <code>bib_validate</code> below.</p> MARCXMLMARC21 <p>bib_create Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_create(\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(xml_record)\n        print(response.content)\n</code></pre> bib_create Test Record<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000nam a2200000 a 4500&lt;/leader&gt;\n    &lt;controlfield tag=\"008\"&gt;240320s2024    nyua          000 0 eng d&lt;/controlfield&gt;\n    &lt;datafield tag=\"010\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;   12345678 &lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"040\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;NYP&lt;/subfield&gt;\n        &lt;subfield code=\"b\"&gt;eng&lt;/subfield&gt;\n        &lt;subfield code=\"c\"&gt;NYP&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"100\" ind1=\"0\" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;BookOps&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"245\" ind1=\"1\" ind2=\"0\"&gt;\n        &lt;subfield code=\"a\"&gt;Test Record&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"500\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;BOOKOPS-WORLDCAT DOCUMENTATION&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre> bib_create Response<pre><code>&lt;record&gt;\n    &lt;leader&gt;00000nam a2200000 a 4500&lt;/leader&gt;\n    &lt;controlfield tag=\"001\"&gt;ocn123456789&lt;/controlfield&gt;\n    &lt;controlfield tag=\"008\"&gt;240320s2024    nyua          000 0 eng d&lt;/controlfield&gt;\n    &lt;datafield tag=\"010\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;   12345678 &lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"040\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;NYP&lt;/subfield&gt;\n        &lt;subfield code=\"b\"&gt;eng&lt;/subfield&gt;\n        &lt;subfield code=\"c\"&gt;NYP&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"100\" ind1=\"0\" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;BookOps&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"245\" ind1=\"1\" ind2=\"0\"&gt;\n        &lt;subfield code=\"a\"&gt;Test Record&lt;/subfield&gt;\n    &lt;/datafield&gt;\n    &lt;datafield tag=\"500\" ind1=\" \" ind2=\" \"&gt;\n        &lt;subfield code=\"a\"&gt;BOOKOPS-WORLDCAT DOCUMENTATION&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;/record&gt;\n</code></pre></p> <p>bib_create Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.mrc\",\"rb\") as mrc_file:\n    for r in mrc_file:\n        mrc_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_create(\n            record=mrc_record, \n            recordFormat=\"application/marc\"\n        )\n        print(mrc_record)\n        print(response.text)\n</code></pre> bib_create Test Record<pre><code>00266nam a2200097 a 4500008004100000010001700041040002200058100002700080245001600107500004500123\\u001E240320s2024    nyua          000 0 eng d\\u001E  \\u001Fa   63011276 \\u001E  \\u001FaNYP\\u001Fbeng\\u001FcNYP\\u001E0 \\u001FaBookOps\\u001E10\\u001FaTest Record\\u001E  \\u001FaBOOKOPS-WORLDCAT DOCUMENTATION\\u001E\\u001D    \n</code></pre> bib_create Response<pre><code>00291nam a2200109 a 4500001001300000008004100013010001700054040002200071100002700093245001600120500004500136\\u001Eocn123456789\\u001E240320s2024    nyua          000 0 eng d\\u001E  \\u001Fa   63011276 \\u001E  \\u001FaNYP\\u001Fbeng\\u001FcNYP\\u001E0 \\u001FaBookOps\\u001E10\\u001FaTest Record\\u001E  \\u001FaBOOKOPS-WORLDCAT DOCUMENTATION\\u001E\\u001D \n</code></pre></p>"},{"location":"manage_bibs/#replace-bib-records","title":"Replace Bib Records","text":"<p>The <code>bib_replace</code> method will retrieve a record in WorldCat and replace it with the record it is passed in the request body. If the record does not exist, a new WorldCat record will be created.</p> MARCXMLMARC21 bib_replace Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_replace(\n            oclcNumber=\"123456789\"\n            record=xml_record,\n            recordFormat=\"application/marcxml+xml\",\n        )\n</code></pre> bib_replace Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.mrc\",\"rb\") as mrc_file:\n    for r in mrc_file:\n        mrc_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_replace(\n            record=mrc_record, \n            recordFormat=\"application/marc\"\n        )\n</code></pre>"},{"location":"manage_bibs/#validate-bib-records","title":"Validate Bib Records","text":"<p>Users can first pass their MARC records to the <code>bib_validate</code> method in order to avoid parsing errors when creating or updating WorldCat records. This will check the formatting and quality of the bib record and return either errors identified in the record or a brief JSON response confirming that the record is valid.</p> MARCXMLMARC21 bib_validate Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_validate(\n            record=xml_record,\n            recordFormat=\"application/marcxml+xml\",\n            validationLevel=\"validateFull\",\n        )\n        print(response.json())\n</code></pre> bib_validate Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.mrc\",\"rb\") as mrc_file:\n    for r in mrc_file:\n        mrc_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.bib_validate(\n            record=mrc_record,\n            recordFormat=\"application/marc\",\n            validationLevel=\"validateFull\",\n        )\n        print(response.json())\n</code></pre> bib_validate Response<pre><code>{\n    \"httpStatus\": \"OK\",\n    \"status\": {\n        \"summary\": \"VALID\",\n        \"description\": \"The provided Bib is valid\"\n    }\n}\n</code></pre>"},{"location":"manage_holdings/","title":"Manage Institution Holdings","text":"<p>Server responses are returned in JSON format for requests made to any <code>/manage/holdings/</code> endpoints. These responses can be accessed and parsed with the <code>.json()</code> method.</p>"},{"location":"manage_holdings/#get-institution-holdings-codes","title":"Get Institution Holdings Codes","text":"<p>The <code>holdings_get_codes</code> method retrieves an institution's holdings codes. The web service identifies the institution based on the data passed to the <code>WorldcatAccessToken</code>.</p> <p>holdings_get_codes Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.holdings_get_codes()\n    print(response.json())\n</code></pre> holdings_get_codes Response<pre><code>{\n  \"holdingLibraryCodes\": [\n    {\n      \"code\": \"Rodgers &amp; Hammerstein\",\n      \"name\": \"NYPH\"\n    },\n    {\n      \"code\": \"Schomburg Center\",\n      \"name\": \"NYP3\"\n    },\n    ]\n}\n</code></pre></p>"},{"location":"manage_holdings/#get-current-holdings","title":"Get Current Holdings","text":"<p>The <code>holdings_get_current</code> method retrieves the holding status of a requested record for the authenticated institution.</p> <p>holdings_get_current Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.holdings_get_current(oclcNumbers=123456789)\n    print(response.json())\n</code></pre> holdings_get_current Response<pre><code>{\n  \"holdings\": [\n    {\n      \"requestedControlNumber\": \"123456789\",\n      \"currentControlNumber\": \"123456789\",\n      \"institutionSymbol\": \"NYP\",\n      \"holdingSet\": true\n    }\n  ]\n}\n</code></pre></p>"},{"location":"manage_holdings/#set-and-unset-holdings","title":"Set and Unset Holdings","text":"<p>Users can set and/or unset holdings in WorldCat by passing an OCLC Number to the <code>holdings_set</code> and/or <code>holdings_unset</code> methods. </p> <p>Info</p> <p>In version 2.0 of the Metadata API, users are no longer able to set holdings on multiple records with one request. Users should now pass one OCLC Number per request to <code>holdings_set</code> and <code>holdings_unset</code>.</p> <p>Version 2.0 of the Metadata API provides new functionality to set and unset holdings in WorldCat by passing the Metadata API a MARC record in MARCXML or MARC21 format. The record must have an OCLC number in the 035 or 001 field in order to set holdings in WorldCat.</p> <p>Bookops-Worldcat supports this functionality with the <code>holdings_set_with_bib</code> and <code>holdings_unset_with_bib</code> methods which can be passed a MARC record in the body of the request in the same way that one would pass a record to a method that uses any of the <code>/manage/bibs/</code> endpoints.</p> <p>Beginning in September 2024 users are able to remove associated Local Bibliographic Data and/or Local Holdings Records when unsetting holdings on a record in OCLC. This functionality is supported by both the <code>/worldcat/manage/institution/holdings/unset</code> and <code>/worldcat/manage/institution/holdings/{oclcNumber}/unset</code> endpoints using the <code>cascadeDelete</code> arg. If <code>cascadeDelete</code> is <code>True</code>, local records will be removed from WorldCat when unsetting a holding. If <code>False</code>, the associated local records will remain in WorldCat. The default value within <code>bookops-worldcat</code> and the Metadata API is <code>True</code> </p> holdings_setholdings_unsetholdings_set_with_bibholdings_unset_with_bib <p>holdings_set Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.holdings_set(oclcNumber=123456789)\n    print(response.json())\n</code></pre> holdings_set Response<pre><code>{\n  \"controlNumber\": \"123456789\",\n  \"requestedControlNumber\": \"123456789\",\n  \"institutionCode\": \"58122\",\n  \"institutionSymbol\": \"NYP\",\n  \"success\": true,\n  \"message\": \"Holding Updated Successfully\",\n  \"action\": \"Set Holdings\"\n}\n</code></pre></p> <p>holdings_unset Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.holdings_unset(oclcNumber=123456789)\n    print(response.json())\n</code></pre> holdings_unset Response<pre><code>{\n  \"controlNumber\": \"123456789\",\n  \"requestedControlNumber\": \"123456789\",\n  \"institutionCode\": \"58122\",\n  \"institutionSymbol\": \"NYP\",\n  \"success\": true,\n  \"message\": \"Holding Updated Successfully\",\n  \"action\": \"Unset Holdings\"\n}\n</code></pre></p> <p>holdings_set_with_bib Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.holdings_set_with_bib(\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(response.json())\n</code></pre> holdings_set_with_bib Response<pre><code>{\n  \"controlNumber\": \"123456789\",\n  \"requestedControlNumber\": \"123456789\",\n  \"institutionCode\": \"58122\",\n  \"institutionSymbol\": \"NYP\",\n  \"success\": true,\n  \"message\": \"Holding Updated Successfully\",\n  \"action\": \"Set Holdings\"\n}\n</code></pre></p> <p>holdings_unset_with_bib Request<pre><code>from bookops_worldcat import MetadataSession\nfrom io import BytesIO\n\nwith open(\"file.xml\",\"rb\") as xml_file:\n    for r in xml_file:\n        xml_record = BytesIO(r)\n        session = MetadataSession(authorization=token)\n        response = session.holdings_unset_with_bib(\n            record=xml_record, \n            recordFormat=\"application/marcxml+xml\"\n        )\n        print(response.json())\n</code></pre> holdings_unset_with_bib Response<pre><code>{\n  \"controlNumber\": \"123456789\",\n  \"requestedControlNumber\": \"123456789\",\n  \"institutionCode\": \"58122\",\n  \"institutionSymbol\": \"NYP\",\n  \"success\": true,\n  \"message\": \"Holding Updated Successfully\",\n  \"action\": \"Unset Holdings\"\n}\n</code></pre></p>"},{"location":"search/","title":"Search WorldCat","text":"<p>Bookops-Worldcat provides functionality that allows users to search WorldCat for brief bibliographic resources, holdings data, and classification recommendations. </p> <p>Requests made to any <code>/search/</code> endpoints return server responses in JSON format. These responses can be accessed and parsed with the <code>.json()</code> method.</p>"},{"location":"search/#brief-bib-resources","title":"Brief Bib Resources","text":""},{"location":"search/#search-brief-bibs","title":"Search Brief Bibs","text":"<p>The <code>brief_bibs_search</code> method allows users to query WorldCat using WorldCat's bibliographic record indexes.</p> <p>The Metadata API has many limiters that one can use to restrict query results. A full list of available parameters for the <code>brief_bibs_search</code> method is available in the API Documentation. Additional search examples are also available in the Advanced Search Functionality section of this page.</p> <p>Basic usage: brief_bibs_search Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.brief_bibs_search(\n        q=\"ti: My brilliant friend AND au: Ferrante, Elena\",\n        inCatalogLanguage=\"eng\",\n        itemSubType=\"book-printbook\",\n        orderBy=\"mostWidelyHeld\",\n        )\n    print(response.json())\n</code></pre> brief_bibs_search Response<pre><code>{\n  \"numberOfRecords\": 79, \n  \"briefRecords\": [\n    {\n      \"oclcNumber\": \"778419313\", \n      \"title\": \"My brilliant friend\", \n      \"creator\": \"Elena Ferrante\", \n      \"date\": \"2012\", \n      \"machineReadableDate\": \"2012\", \n      \"language\": \"eng\", \n      \"generalFormat\": \"Book\", \n      \"specificFormat\": \"PrintBook\", \n      \"publisher\": \"Europa Editions\", \n      \"publicationPlace\": \"New York, New York\", \n      \"isbns\": [\n        \"9781609450786\", \n        \"1609450787\"\n      ], \n      \"mergedOclcNumbers\": [\n        \"811639683\", \n        \"818678733\", \n        \"824701856\", \n        \"829903719\", \n        \"830036387\", \n        \"1302347443\"\n      ], \n      \"catalogingInfo\": {\n        \"catalogingAgency\": \"BTCTA\", \n        \"catalogingLanguage\": \"eng\", \n        \"levelOfCataloging\": \" \", \n        \"transcribingAgency\": \"BTCTA\"\n      }\n    },\n  ]\n}\n</code></pre></p>"},{"location":"search/#get-brief-bibs","title":"Get Brief Bibs","text":"<p>Users can retrieve a brief bib resource for a known item by passing the OCLC Number for the resource to the <code>brief_bibs_get</code> method.</p> <p>Basic usage: brief_bibs_get Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.brief_bibs_get(778419313)\n    print(response.json())\n</code></pre> brief_bibs_get Response<pre><code>{\n  \"oclcNumber\": \"778419313\",\n  \"title\": \"My brilliant friend\",\n  \"creator\": \"Elena Ferrante\",\n  \"date\": \"2012\",\n  \"machineReadableDate\": \"2012\",\n  \"language\": \"eng\",\n  \"generalFormat\": \"Book\",\n  \"specificFormat\": \"PrintBook\",\n  \"publisher\": \"Europa Editions\",\n  \"publicationPlace\": \"New York, New York\",\n  \"isbns\": [\n    \"9781609450786\",\n    \"1609450787\"\n  ],\n  \"mergedOclcNumbers\": [\n    \"811639683\",\n    \"818678733\",\n    \"824701856\",\n    \"829903719\",\n    \"830036387\",\n    \"1302347443\"\n  ],\n  \"catalogingInfo\": {\n    \"catalogingAgency\": \"BTCTA\",\n    \"catalogingLanguage\": \"eng\",\n    \"levelOfCataloging\": \" \",\n    \"transcribingAgency\": \"BTCTA\"\n  }\n}\n</code></pre></p>"},{"location":"search/#get-brief-bibs-for-other-editions","title":"Get Brief Bibs for Other Editions","text":"<p>Users can retrieve brief bib resources for other editions of a title by passing an OCLC Number to the <code>brief_bibs_get_other_editions</code> method.</p> <p>Basic usage: brief_bibs_get_other_editions Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.brief_bibs_get_other_editions(\n        oclcNumber=\"321339\", \n        itemSubType=\"book-digital\", \n        inCatalogLanguage=\"eng\", \n        orderBy=\"bestMatch\"\n    )\n    print(response.json())\n</code></pre> brief_bibs_get_other_editions Response<pre><code>{\n  \"numberOfRecords\": 15, \n  \"briefRecords\": [\n    {\n      \"oclcNumber\": \"859323121\", \n      \"title\": \"My brilliant friend. book one : childhood, adolescence\", \n      \"creator\": \"Elena Ferrante\", \n      \"date\": \"2012\", \n      \"machineReadableDate\": \"2012\", \n      \"language\": \"eng\", \n      \"generalFormat\": \"Book\", \n      \"specificFormat\": \"Digital\", \n      \"publisher\": \"Europa Editions\", \n      \"publicationPlace\": \"New York\", \n      \"isbns\": [\n        \"9781609458638\", \n        \"160945863X\", \n        \"9781787701151\", \n        \"1787701158\"\n      ], \n      \"mergedOclcNumbers\": [\n        \"883320518\", \n        \"907236505\", \n        \"1030261956\", \n        \"1031563997\", \n        \"1032076035\", \n        \"1052184907\", \n        \"1124391373\", \n        \"1155208541\", \n        \"1191036210\", \n        \"1196835133\"\n      ], \n      \"catalogingInfo\": {\n        \"catalogingAgency\": \"TEFOD\", \n        \"catalogingLanguage\": \"eng\", \n        \"levelOfCataloging\": \" \", \n        \"transcribingAgency\": \"TEFOD\"\n      }\n    }, \n  ]\n}\n</code></pre></p>"},{"location":"search/#full-bib-resources","title":"Full Bib Resources","text":""},{"location":"search/#search-bibs","title":"Search Bibs","text":"<p>Users can retrieve full bib records in <code>.json</code> format by passing an OCLC Number to the <code>bibs_search</code> method.</p> <p>Basic usage: bibs_search Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.bibs_search(oclcNumber=778419313)\n    print(response.json())\n</code></pre> bibs_search Response<pre><code>{\n  'identifier': {\n    'oclcNumber': '778419313', \n    'isbns': [\n      '9781609450786', '1609450787', '9781609455064', '1609455061'\n    ]\n  }, \n  'title': {\n    'mainTitles': [\n      {\n        'text': 'My brilliant friend / Elena Ferrante ; translated from the Italian by Ann Goldstein'\n        }\n      ]\n    }, \n  'contributor': {\n    'creators': [\n      {\n        'firstName': {'text': 'Elena'}, 'secondName': {'text': 'Ferrante'}\n        }\n      ]\n    },\n  'subjects': [\n    {\n      'subjectName': {'text': 'Female friendship Fiction'}, \n      'vocabulary': 'Library of Congress Subject Headings', \n      'subjectType': 'topic'\n      }, \n    {\n      'subjectName': {'text': 'Naples (Italy) History 20th century Fiction'}, \n      'vocabulary': 'Library of Congress Subject Headings', \n      'subjectType': 'geographicalTerm'\n      },\n    ], \n  'publishers': [\n    {\n      'publisherName': {'text': 'Europa Editions'}, \n      'publicationPlace': 'New York, New York'\n      }\n    ], \n  'date': {\n    'publicationDate': '2012', \n    }, \n  'language': {\n    'itemLanguage': 'eng', \n    'catalogingLanguage': 'eng'\n    }, \n  'description': {\n    'physicalDescription': '331 pages ; 21 cm', \n    }\n  }\n</code></pre></p>"},{"location":"search/#member-holdings","title":"Member Holdings","text":"<p>Users can query WorldCat for holdings data and return holdings summaries using Bookops-Worldcat and the Metadata API. Requests made using the <code>summary_holdings_search</code> and <code>shared_print_holdings_search</code> methods return brief bib resources with the holdings summaries in their responses, while requests made using the <code>summary_holdings_get</code> method only return holdings summaries. </p>"},{"location":"search/#get-holdings-summary","title":"Get Holdings Summary","text":"<p>Users can retrieve a summary of holdings data from WorldCat for a known item by passing an OCLC Number to the <code>summary_holdings_get</code> method. </p> <p>Basic Usage: Basic summary_holdings_get Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.summary_holdings_get(\"778419313\")\n    print(response.json())\n</code></pre> Basic summary_holdings_get Response<pre><code>{\n  \"totalHoldingCount\": 1626,\n  \"totalSharedPrintCount\": 5,\n  \"totalEditions\": 1\n}\n</code></pre> Users can limit their search results to specific institutions, library types, or geographic areas.</p> <p>Limit holdings search by state: summary_holdings_get Request with heldInState limiter<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n  response = session.summary_holdings_get(\"778419313\", heldInState=\"US-NY\")\n  print(response.json())\n</code></pre> summary_holdings_get Response with heldInState limiter<pre><code>{\n  \"totalHoldingCount\": 56,\n  \"totalSharedPrintCount\": 0\n}\n</code></pre></p>"},{"location":"search/#search-general-holdings","title":"Search General Holdings","text":"<p>Users can pass either an OCLC Number, ISBN, or ISSN to the <code>summary_holdings_search</code> method to search for bibliographic resources their holdings.</p> <p>Basic Usage: summary_holdings_search Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    response = session.summary_holdings_search(\n        isbn=\"9781609458638\", \n        heldInCountry=\"US\"\n    )\n    print(response.json())\n</code></pre> summary_holdings_search Response<pre><code>{\n  \"numberOfRecords\": 1, \n  \"briefRecords\": [\n    {\n      \"oclcNumber\": \"859323121\", \n      \"title\": \"My brilliant friend. book one : childhood, adolescence\", \n      \"creator\": \"Elena Ferrante\", \n      \"date\": \"2012\", \n      \"machineReadableDate\": \"2012\", \n      \"language\": \"eng\", \n      \"generalFormat\": \"Book\", \n      \"specificFormat\": \"Digital\", \n      \"publisher\": \"Europa Editions\", \n      \"publicationPlace\": \"New York\", \n      \"isbns\": [\n        \"9781609458638\", \n        \"160945863X\", \n        \"9781787701151\", \n        \"1787701158\"\n      ], \n      \"mergedOclcNumbers\": [\n        \"883320518\", \n        \"907236505\", \n        \"1030261956\", \n        \"1031563997\", \n        \"1032076035\", \n        \"1052184907\", \n        \"1124391373\", \n        \"1155208541\", \n        \"1191036210\", \n        \"1196835133\"\n      ], \n      \"catalogingInfo\": {\n        \"catalogingAgency\": \"TEFOD\", \n        \"catalogingLanguage\": \"eng\", \n        \"levelOfCataloging\": \" \", \n        \"transcribingAgency\": \"TEFOD\"\n      }, \n      \"institutionHolding\": {\n        \"totalHoldingCount\": 159\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"search/#search-shared-print-holdings","title":"Search Shared Print Holdings","text":"<p>To search just for holdings with retention commitments, users can pass an OCLC Number, ISBN, or ISSN to the <code>shared_print_holdings_search</code> method. The response includes the brief bib resource, a summary of shared print holdings for that resource, and data about the institutions with retention commitments for the resource.  </p> <p>shared_print_holdings_search Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n  response = session.shared_print_holdings_search(321339)\n  print(response.json())\n</code></pre> shared_print_holdings_search Response<pre><code>{\n  \"numberOfRecords\": 1, \n  \"briefRecords\": [\n    {\n      \"oclcNumber\": \"778419313\", \n      \"title\": \"My brilliant friend\", \n      \"creator\": \"Elena Ferrante\", \n      \"date\": \"2012\", \n      \"machineReadableDate\": \"2012\", \n      \"language\": \"eng\", \n      \"generalFormat\": \"Book\", \n      \"specificFormat\": \"PrintBook\", \n      \"publisher\": \"Europa Editions\", \n      \"publicationPlace\": \"New York, New York\", \n      \"isbns\": [\n        \"9781609450786\", \n        \"1609450787\"\n      ], \n      \"mergedOclcNumbers\": [\n        \"811639683\", \n        \"818678733\", \n        \"824701856\", \n        \"829903719\", \n        \"830036387\", \n        \"1302347443\"\n      ], \n      \"catalogingInfo\": {\n        \"catalogingAgency\": \"BTCTA\", \n        \"catalogingLanguage\": \"eng\", \n        \"levelOfCataloging\": \" \", \n        \"transcribingAgency\": \"BTCTA\"\n      }, \n      \"institutionHolding\": {\n        \"totalHoldingCount\": 5, \n        \"briefHoldings\": [\n          {\n            \"country\": \"US\", \n            \"state\": \"US-ME\", \n            \"oclcSymbol\": \"CBY\", \n            \"registryId\": 1233, \n            \"institutionNumber\": 90, \n            \"institutionName\": \"Colby College\", \n            \"alsoCalled\": \"Miller Library\", \n            \"hasOPACLink\": True, \n            \"self\": \"https://worldcat.org/oclc-config/institution/data/1233\", \n            \"address\": {\n              \"street1\": \"Miller Library\", \n              \"street2\": \"5124 Mayflower Hill\", \n              \"city\": \"Waterville\",\n              \"state\": \"US-ME\",\n              \"postalCode\": \"04901-8851\", \n              \"country\": \"US\", \n              \"lat\": 44.564102, \n              \"lon\": -69.66333\n            }, \n            \"institutionType\": \"ACADEMIC\"\n          }\n        ]\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"search/#classification-recommendations","title":"Classification Recommendations","text":"<p>Version 2.0 of the Metadata API added a new endpoint that users can query to retrieve classification recommendations for known items. With Bookops-Worldcat, users can pass an OCLC Number to the <code>bib_get_classification</code> method and the response will contain the most popular classification for that item in both Dewey and LC. </p> <p>bib_get_classification Request<pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n  response = session.bib_get_classification(\"778419313\")\n  print(response.json())\n</code></pre> bib_get_classification Response<pre><code>{\n  \"dewey\": {\n    \"mostPopular\": [\n      \"853/.92\"\n    ]\n  },\n  \"lc\": {\n    \"mostPopular\": [\n      \"PQ4866.E6345 A8113 2012\"\n    ]\n  }\n}\n</code></pre></p>"},{"location":"search/#advanced-search-functionality","title":"Advanced Search Functionality","text":"<p>Info</p> <p>While most arguments passed to <code>/search/</code> endpoints (such as <code>brief_bibs_search</code>, <code>local_bibs_search</code>, and <code>summary_holdings_search</code>) are joined using the 'AND' operator, when both <code>itemType</code> and <code>itemSubType</code> are used in a query, they are joined using the 'OR' operator. </p>"},{"location":"search/#keyword-and-fielded-queries","title":"Keyword and Fielded Queries","text":"<p>The Metadata API provides robust search functionality for bib resources. In addition to a flexible query string that supports keyword and fielded searches, it is possible to set further limits using various elements such as item type, language, and publishing date. Users can specify the order of returned records by using the <code>orderBy</code> argument. </p> <p>The query syntax is case-insensitive and allows keyword and phrase search (use quotation marks around phrases), boolean operators (AND, OR, NOT), wildcards (# - single character, ? - any number of additional characters), and truncation (use * character).</p>"},{"location":"search/#advanced-search-for-brief-bib-resources","title":"Advanced Search for Brief Bib Resources","text":"<p>More about the query syntax available for brief bib resource searches can be found in OCLC's documentation.</p> Info <p>Queries with the following indexes are not allowed without additional indexes:    dd: Dewey Decimal Class Number   yr: Year   li: Holdings Library   ln: Language   ll: Language of cataloging   mt: Material Type   cs: Cataloging Source   x0: Format/Document Type word index   x4: Format/Document Type word index   l8: Shared Print word index   zu: Holding Library Group</p> <p>Two equivalent <code>brief_bibs_search</code> examples with item type and language limiters:</p> Keyword SearchFielded Search <pre><code>  response = session.brief_bibs_search(\n      q=\"ti=my brilliant friend\",\n        itemType=\"video\",\n        inLanguage=\"eng\",\n        orderBy=\"bestMatch\",\n      )\n  print(response.json())\n</code></pre> <pre><code>  response = session.brief_bibs_search(\n      q='ti=\"my brilliant friend\" AND x0: video AND ln: eng',\n      orderBy=\"bestMatch\"\n      )\n  print(response.json())\n</code></pre> <pre><code>{\n  \"numberOfRecords\": 37, \n  \"briefRecords\": [\n    {\n      \"oclcNumber\": \"1091307669\", \n      \"title\": \"My Brilliant Friend\",\n      \"date\": \"2019\", \n      \"machineReadableDate\": \"2019\", \n      \"language\": \"eng\", \n      \"generalFormat\": \"Video\", \n      \"specificFormat\": \"DVD\", \n      \"edition\": \"Widescreen ed\", \n      \"publisher\": \"Home Box Office\", \n      \"publicationPlace\": \"[United States]\", \n      \"catalogingInfo\": {\n        \"catalogingAgency\": \"CNWPU\", \n        \"catalogingLanguage\": \"eng\", \n        \"levelOfCataloging\": \"M\", \n        \"transcribingAgency\": \"CNWPU\"\n      }\n    },\n  ]\n}\n</code></pre>"},{"location":"search/#advanced-search-for-local-bib-resources","title":"Advanced Search for Local Bib Resources","text":"<p>The <code>local_bibs_search</code> method also allows for fielded queries. The available indexes are slightly different from those available for brief bib resource searches. For more information about the query syntax for local bib resources see OCLC's documentation.</p> <p><code>local_bibs_search</code> with language and date created as MARC limiters: local_bibs_search Fielded Query<pre><code>session.local_bibs_search(q=\"ti=My Local Bib Record AND dc=2024? AND ln=eng\")\n</code></pre></p>"},{"location":"start/","title":"Get Started","text":""},{"location":"start/#authentication-and-authorization","title":"Authentication and Authorization","text":"<p>An Access Token can be obtained by passing credential parameters into the <code>WorldcatAccessToken</code> object. This will authenticate the user against OCLC's Authorization Server and allow the user to send requests to the OCLC Metadata API. </p> Get Access Token<pre><code>from bookops_worldcat import WorldcatAccessToken\ntoken = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=\"WorldCatMetadataAPI\",\n)\nprint(token)\n#&gt;\"access_token: 'tk_Yebz4BpEp9dAsghA7KpWx6dYD1OZKWBlHjqW', expires_at: '2024-01-01 17:19:58Z'\"\nprint(token.is_expired())\n#&gt;False\n</code></pre> <p>This <code>token</code> object can be passed directly into <code>MetadataSession</code> to authorize requests to the Metadata API web service:</p> Open MetadataSession<pre><code>from bookops_worldcat import MetadataSession\n\nsession = MetadataSession(authorization=token)\nsession.brief_bibs_get(\"321339\")\n</code></pre>"},{"location":"start/#metadatasession-as-context-manager","title":"MetadataSession as Context Manager","text":"<p>A <code>MetadataSession</code> can also be used as a context manager. This allows users to use the same parameters and configuration for each request they send to the Metadata API and to ensure that the session is closed after their code has finished running. </p> <p><code>MetadataSession</code> inherits all <code>requests.Session</code> methods and properties (see Advanced Usage &gt; MetadataSession for more information). </p> <p>Metadata Session as Context Manager<pre><code>with MetadataSession(authorization=token) as session:\n    response = session.brief_bibs_get(\"321339\")\n</code></pre> A <code>MetadataSession</code> has methods that allow users to interact with each endpoint of the OCLC Metadata API. See the tabs on the left of this page for more information about <code>MetadataSession</code> methods and examples of their usage.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>The following examples illustrate how bookops-worldcat can be used in technical services workflows. These examples use pymarc (version 5.1.2) and modules from the Python standard library in addition to bookops-worldcat. </p> <p>Each example contains in-line comments in the code explaining the process step-by-step.</p>"},{"location":"tutorials/#setup","title":"Setup","text":""},{"location":"tutorials/#create-and-activate-a-virtual-environment","title":"Create and activate a virtual environment","text":"<p>Create and activate a virtual environment before installing any packages. Using a virtual environment can help users manage dependencies. For more information about virtual environments see PyPA's guide to virtual environments and Real Python's Virtual Environments primer.</p> <p>Windows (Git Bash):</p> <ol> <li> <p>Create your virtual environment</p> <p><code>python -m venv .venv</code></p> </li> <li> <p>Activate your virtual environment</p> <p><code>source ./.venv/scripts/activate</code></p> </li> <li> <p>Install tutorial packages</p> <p><code>pip -m install bookops-worldcat</code></p> <p><code>pip -m install pymarc</code></p> </li> </ol> <p>MacOS: </p> <ol> <li> <p>Create a virtual environment</p> <p><code>python3 -m venv .venv</code></p> </li> <li> <p>Activate your virtual environment</p> <p><code>source ./.venv/bin/activate</code></p> </li> <li> <p>Install tutorial packages</p> <p><code>pip3 -m install bookops-worldcat</code></p> <p><code>pip3 -m install pymarc</code></p> </li> </ol>"},{"location":"tutorials/#obtain-an-access-token","title":"Obtain an Access Token","text":"<p>The examples below use the following helper function to get an Access Token:</p> get_token helper function<pre><code>def get_token(filepath: str) -&gt; WorldcatAccessToken:\n   \"\"\"\n   Retrieves user's WSKey credentials from a .json file.\n\n   Args:\n       filepath: \n            Path to location of .json file with credentials.\n            The format of the credentials in the .json file should be:\n               {\n                 \"key\": \"my_key\",\n                 \"secret\": \"my_secret\",\n                 \"scopes\": \"WorldcatMetadataAPI\",\n                 \"agent\": \"MyApp/1.0\"\n               } \n\n   Returns:\n       WorldcatAccessToken\n   \"\"\"\n   with open(filepath, \"r\") as file:\n       data = json.load(file)\n       return WorldcatAccessToken(\n           key=data[\"key\"],\n           secret=data[\"secret\"],\n           scopes=data[\"scopes\"],\n           agent=data[\"agent\"],\n       )\n</code></pre>"},{"location":"tutorials/#match-minimal-vendor-records-to-full-worldcat-records","title":"Match minimal vendor records to full WorldCat records","text":"<p>Given minimal MARC records from a vendor, identify matches in WorldCat using the <code>/manage/bibs/match</code> endpoint. Parse the API response and retrieve full MARC records using the <code>/manage/bibs</code> endpoint. Merge the resulting records with the original records and save them to a new file. </p> Match MARC records<pre><code>import os\n\nfrom bookops_worldcat import MetadataSession\nfrom pymarc import MARCReader, MARCWriter, Record\n\nfrom utils import get_token  # (1)!\n\ntoken = get_token(\"C:/Users/username/credentials/tutorial_creds.json\") # (2)!\n\n# Step 1. Initiate MetadataSession\nwith MetadataSession(authorization=token) as session:\n\n  # Step 2.  Read records from .mrc file one-by-one\n  with open(\"data/tutorial_input_1.mrc\", \"rb\") as file: # (3)!\n      reader = MARCReader(file)\n      for record in reader:\n\n          # Step 3. Extract embedded order data from vendor record\n          order_data = record.get(\"960\") # (4)! \n\n          # Step 4. Match record using bib_match\n          match_response = session.bib_match(\n              record=record.as_marc(), recordFormat=\"application/marc\"\n          )\n\n          # Step 5. Parse .json response and extract OCLC Number\n          match_json = match_response.json()\n          matched_oclc_number = match_json[\"briefRecords\"][0][\"oclcNumber\"]\n\n          # Step 6. Retrieve full MARC record using OCLC Number\n          get_response = session.bib_get(\n              matched_oclc_number, responseFormat=\"application/marc\"\n          )\n\n          # Step 7. Create pymarc Record object from MARC record in API response\n          pymarc_record = Record(get_response.content)\n\n          # Step 8. Merge order data from original record into new MARC record\n          pymarc_record.add_field(order_data)\n\n          # Step 9. Write record to new .mrc file\n          writer = MARCWriter(open(\"data/tutorial_output_1.mrc\", \"ab\"))\n          writer.write(pymarc_record)\n          writer.close()\n</code></pre> <ol> <li>The helper function, <code>get_token</code>, is mentioned at the top of this page. In this example we are importing it from a module named <code>utils.py</code></li> <li>The filepath for the <code>.json</code> file where your WSKey is stored.</li> <li>This is the name of the vendor MARC file.</li> <li>This is a MARC tag used for embedded order data but users should change this field based on local practices.</li> </ol>"},{"location":"tutorials/#search-brief-bibliographic-resources","title":"Search brief bibliographic resources","text":"<p>Given minimal data in a spreadsheet, read data to form queries. Search for records using the <code>/search/brief-bibs/</code> endpoint and query formed from spreadsheet data. Retrieve full MARC records using the OCLC numbers in the API response. </p> <p>The spreadsheet in this example contains the following fields: Title, Author, ISBN, Publication Date, Barcode, and Item Price.</p> Search brief bibliographic resources<pre><code>import os\nimport csv\n\nfrom bookops_worldcat import MetadataSession\nfrom pymarc import MARCWriter, Record, Field, Subfield\n\nfrom utils import get_token # (1)!\n\ntoken = get_token(\"C:/Users/username/credentials/tutorial_creds.json\") # (2)!\n\n# Step 1. Initiate MetadataSession\nwith MetadataSession(authorization=token) as session:\n\n    # Step 2.  Read data from spreadsheet\n    with open(\"data/tutorial_input_2.csv\", \"r\", encoding=\"utf-8\") as csvfile:  # (3)!\n        reader = csv.reader(csvfile, delimiter=\"\\t\")\n        next(reader)\n\n        # Step 3. Iterate through each row in spreadsheet\n        for row in reader:\n\n            # Step 4. Query API using spreadsheet data and brief_bibs_search \n            brief_bib_response = session.brief_bibs_search(\n                q=f\"ti:{row[0]} AND au:{row[1]} AND bn:{row[2]}\",\n                inCatalogLanguage=\"eng\",\n                itemSubType=\"book-printbook\",\n                datePublished=row[3], # (4)!\n            )\n\n            # Step 5. Parse .json response and extract OCLC Number\n            brief_bib_json = brief_bib_response.json()\n            matched_oclc_number = brief_bib_json[\"briefRecords\"][0][\"oclcNumber\"]\n\n            # Step 6. Retrieve full MARC record using OCLC Number\n            get_response = session.bib_get(\n                matched_oclc_number, responseFormat=\"application/marc\"\n            )\n\n            # Step 7. Create pymarc Record object from MARC record in API response\n            pymarc_record = Record(get_response.content)\n\n            # Step 8. Merge additional data from spreadsheet into new MARC record\n            pymarc_record.add_field(\n                Field(\n                    tag=\"949\",\n                    indicators=[\"\", \"\"],\n                    subfields=[\n                        Subfield(code=\"i\", value=f\"{row[4]}\"), # (5)!\n                        Subfield(code=\"p\", value=f\"{row[5]}\"), # (6)!\n                    ],\n                )\n            )\n\n            # Step 9. Write record to new .mrc file\n            writer = MARCWriter(open(\"data/tutorial_output_2.mrc\", \"ab\"))\n            writer.write(pymarc_record)\n            writer.close()\n</code></pre> <ol> <li>The helper function, <code>get_token</code>, is mentioned at the top of this page. In this example we are importing it from a module named <code>utils.py</code></li> <li>The filepath for the <code>.json</code> file where your WSKey is stored.</li> <li>The name of your vendor spreadsheet file.</li> <li>The query is formed using data from the first four columns of the spreadsheet: Title (column 1), Author (column 2), Publication Date (column 3), and ISBN (column 4)</li> <li>Add the barcode to the 949$i field.</li> <li>Add the item price to the 949$p field.</li> </ol>"},{"location":"tutorials/#check-and-set-holdings","title":"Check and Set Holdings","text":""},{"location":"tutorials/#using-marc-records","title":"Using MARC records","text":"<p>Given a file of MARC records, extract the OCLC numbers from the records and check if holdings are set. Set/Unset holdings using the MARC record. </p> Using MARC records<pre><code>import os\n\nfrom bookops_worldcat import MetadataSession\nfrom pymarc import MARCReader\n\nfrom utils import get_token  # (1)!\n\n\ntoken = get_token(\"C:/Users/username/credentials/tutorial_creds.json\") # (2)!\n\n# 1. Initiate MetadataSession\nwith MetadataSession(authorization=token) as session:\n    # 2. Read MARC records from file\n    with open(\"data/tutorial_input_3.mrc\", \"rb\") as marc_file:  # (3)!\n        reader = MARCReader(marc_file)\n        for record in reader:\n            # 3. Get OCLC Number for record\n            oclc_number = record.get(\"035\").value()\n\n            # 4. Check if holdings are set for record\n            get_response = session.holdings_get_current(oclc_number)\n\n            # 5.1. Set holdings with record\n            set_response = session.holdings_set_with_bib( # (4)!\n                record.as_marc(), recordFormat=\"application/marc\"\n            )\n\n            # 5.2. Unset holdings with record\n            unset_response = session.holdings_unset_with_bib( # (5)!\n                record.as_marc(), recordFormat=\"application/marc\"\n            )\n</code></pre> <ol> <li>The helper function, <code>get_token</code>, is mentioned at the top of this page. In this example we are importing it from a module named <code>utils.py</code></li> <li>The filepath for the <code>.json</code> file where your WSKey is stored.</li> <li>The name of the file with your MARC records.</li> <li>If copying code from this example, delete step 5.1 or 5.2 depending on whether you would like to set or unset holdings. </li> <li>If copying code from this example, delete step 5.1 or 5.2 depending on whether you would like to set or unset holdings.</li> </ol>"},{"location":"tutorials/#using-oclc-numbers","title":"Using OCLC Numbers","text":"<p>Read OCLC Numbers from a text file and check if holdings are set. Set/unset holdings using OCLC Number. </p> Step-by-step instructions <p>This example uses the following steps. These steps are noted using in-line comments in the code:</p> <ol> <li>Read a file of OCLC Numbers and add them to a list.</li> <li>Initiate <code>MetadataSession</code></li> <li>Loop through OCLC Numbers.</li> <li>Check if holdings are set using OCLC Number.</li> <li>Set holdings using OCLC Number.</li> <li>Unset holdings using OCLC Number.</li> </ol> Using OCLC Numbers<pre><code>import os\n\nfrom bookops_worldcat import MetadataSession\n\nfrom utils import get_token  # (1)!\n\n\ntoken = get_token(\"C:/Users/username/credentials/tutorial_creds.json\") # (2)!\n\n# 1. Read a file of OCLC Numbers and add them to a list\noclc_numbers = []\nwith open(\"data/tutorial_input_3.txt\", \"r\") as numbers:  # (3)!\n    for number in numbers:\n        oclc_numbers.append(number.strip(\"\\n\"))\n# 2. Initiate MetadataSession\nwith MetadataSession(authorization=token) as session:\n    # 3. Loop through OCLC Numbers\n    for number in oclc_numbers:\n        # 4. Check if holdings are set using OCLC Number\n        get_response = session.holdings_get_current(number)\n\n        # 5.1. Set holdings using OCLC Number\n        set_response = session.holdings_set(number) # (4)!\n\n        # 5.2. Unset holdings using OCLC Number\n        unset_response = session.holdings_unset(number) # (5)!\n</code></pre> <ol> <li>The helper function, <code>get_token</code>, is mentioned at the top of this page. In this example we are importing it from a module named <code>utils.py</code></li> <li>The filepath for the <code>.json</code> file where your WSKey is stored.</li> <li>The name of the <code>.txt</code> file with your OCLC numbers.</li> <li>If copying code from this example, delete step 5.1 or 5.2 depending on whether you would like to set or unset holdings. </li> <li>If copying code from this example, delete step 5.1 or 5.2 depending on whether you would like to set or unset holdings.</li> </ol>"},{"location":"tutorials/#get-classification-recommendations-for-vendor-records","title":"Get classification recommendations for vendor records","text":"<p>Read data from a <code>.mrc</code> file and query WorldCat to retrieve classification recommendations. Add the resulting call numbers to the original MARC records and write the records to a new <code>.mrc</code> file.</p> Get classification recommendations<pre><code>import os\n\nfrom bookops_worldcat import MetadataSession\nfrom pymarc import MARCReader, Field, Subfield, MARCWriter\n\nfrom utils import get_token  # (1)!\n\n\ntoken = get_token(\"C:/Users/username/credentials/tutorial_creds.json\") # (2)!\n\n# 1. Initiate MetadataSession\nwith MetadataSession(authorization=token) as session:\n    # 2. Read MARC records from file\n    with open(\"data/classification_tutorial.mrc\", \"rb\") as marc_file:  # (3)!\n        reader = MARCReader(marc_file)\n        for record in reader:\n            # 3. Extract OCLC Number from record\n            oclc_number = record.get(\"035\").value()\n\n            # 4. Query API for classification recommendations using OCLC Number\n            response = session.bib_get_classification(oclc_number)\n\n            # 5. Parse API response\n            dewey = response.json()[\"dewey\"][\"mostPopular\"][0]\n            lcc = response.json()[\"lc\"][\"mostPopular\"][0]\n\n            # 6. Add classification from response to records\n            record.add_field(\n                Field(\n                    tag=\"050\",\n                    indicators=[\" \", \"0\"],\n                    subfields=[Subfield(code=\"a\", value=f\"{lcc}\")],\n                )\n            )\n            record.add_field(\n                Field(\n                    tag=\"082\",\n                    indicators=[\"0\", \" \"],\n                    subfields=[Subfield(code=\"a\", value=f\"{dewey}\")],\n                )\n            )\n\n            # 7. Write records to new file\n            writer = MARCWriter(open(\"data/tutorial_output_4.mrc\", \"ab\"))\n            writer.write(record)\n            writer.close()\n</code></pre> <ol> <li>The helper function, <code>get_token</code>, is mentioned at the top of this page. In this example we are importing it from a module named <code>utils.py</code></li> <li>The filepath for the <code>.json</code> file where your WSKey is stored.</li> <li>The name of the file with your MARC records.</li> </ol>"},{"location":"api/authorize/","title":"bookops_worldcat.authorize","text":"<p>Provides means to authenticate and authorize interactions with OCLC web services.</p>"},{"location":"api/authorize/#bookops_worldcat.authorize.WorldcatAccessToken","title":"WorldcatAccessToken","text":"<pre><code>WorldcatAccessToken(\n    key: str,\n    secret: str,\n    scopes: str,\n    agent: str = \"\",\n    timeout: Union[\n        int,\n        float,\n        Tuple[int, int],\n        Tuple[float, float],\n        None,\n    ] = (5, 5),\n)\n</code></pre> <p>Requests a WorldCat access token.</p> <p>Authenticates and authorizes using Client Credentials Grant flow. A token with correctly bonded scopes can be passed into a session of an OCLC web service to authorize requests for resources.</p> Example <pre><code>from bookops_worldcat import WorldcatAccessToken\n\ntoken = WorldcatAccessToken(\n    key=\"my_WSKey_client_id\",\n    secret=\"my_WSKey_secret\",\n    scopes=\"WorldCatMetadataAPI\",\n    agent=\"my_app/1.0.0\")\nprint(token.token_str)\n#&gt;\"tk_Yebz4BpEp9dAsghA7KpWx6dYD1OZKWBlHjqW\"\nprint(token.is_expired())\n#&gt;False\nprint(token.server_response.json())\n{\n    \"token_token\": \"tk_Yebz4BpEp9dAsghA7KpWx6dYD1OZKWBlHjqW\",\n    \"token_type\": \"bearer\",\n    \"expires_in\": \"1199\",\n    \"principalID\": \"\",\n    \"principalIDNS\": \"\",\n    \"scope\": \"WorldCatMetadataAPI\",\n    \"scopes\": \"WorldCatMetadataAPI\",\n    \"contextInstitutionId\": \"00001\",\n    \"expires_at\": \"2020-08-23 18:45:29Z\"\n}\nprint(token.server_response.request.headers)\n{\n    \"User-Agent\": \"my_app/1.0.0\",\n    \"Accept-Encoding\": \"gzip, deflate\",\n    \"Accept\": \"application/json\",\n    \"Connection\": \"keep-alive\",\n    \"Content-Length\": \"67\",\n    \"Content-Type\": \"application/x-www-form-urlencoded\",\n    \"Authorization\": \"Basic encoded_authorization_here=\"\n}\n</code></pre> Usage Documentation: <ul> <li>Basic Usage</li> <li>Advanced Usage</li> </ul> PARAMETER DESCRIPTION <code>key</code> <p>Your WSKey public client_id</p> <p> TYPE: <code>str</code> </p> <code>secret</code> <p>Your WSKey secret</p> <p> TYPE: <code>str</code> </p> <code>scopes</code> <p>Request scopes for the access token as a string. Multiple scopes should be separated with a space. Users with WSKeys set up to act on behalf of multiple institutions should provide scope and registryID in the format: <code>{scope} context:{registryID}</code></p> <p>EXAMPLES:</p> <ul> <li>Single institution WSKey: <code>\"WorldCatMetadataAPI\"</code></li> <li>Multi-institution WSKey: <code>\"WorldCatMetadataAPI context:00001\"</code></li> </ul> <p> TYPE: <code>str</code> </p> <code>agent</code> <p><code>User-agent</code> parameter to be passed in the request header. Usage is strongly encouraged.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>timeout</code> <p>How long to wait for server to send data before giving up. Accepts separate values for connect and read timeouts or a single value.</p> <p> TYPE: <code>Union[int, float, Tuple[int, int], Tuple[float, float], None]</code> DEFAULT: <code>(5, 5)</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If <code>agent</code>, <code>key</code>, <code>secret</code>, or <code>scopes</code> args are passed anything other than a str.</p> <code>ValueError</code> <p>If an empty str is passed to <code>key</code>, <code>secret</code> or <code>scopes</code> arg.</p> <code>WorldcatAuthorizationError</code> <p>If request for token encounters any errors.</p> Source code in <code>bookops_worldcat\\authorize.py</code> <pre><code>def __init__(\n    self,\n    key: str,\n    secret: str,\n    scopes: str,\n    agent: str = \"\",\n    timeout: Union[int, float, Tuple[int, int], Tuple[float, float], None] = (\n        5,\n        5,\n    ),\n) -&gt; None:\n    \"\"\"Initializes WorldcatAccessToken object.\n\n\n    info: Usage Documentation:\n        - [Basic Usage](../start.md#authentication-and-authorization)\n        - [Advanced Usage](../advanced.md#WorldcatAccessToken)\n\n    Args:\n        key:\n            Your WSKey public client_id\n        secret:\n            Your WSKey secret\n        scopes:\n            Request scopes for the access token as a string. Multiple scopes\n            should be separated with a space. Users with WSKeys set up to act on\n            behalf of multiple institutions should provide scope and registryID\n            in the format:\n            `{scope} context:{registryID}`\n\n            **EXAMPLES:**\n\n            - Single institution WSKey: `\"WorldCatMetadataAPI\"`\n            - Multi-institution WSKey: `\"WorldCatMetadataAPI context:00001\"`\n\n        agent:\n            `User-agent` parameter to be passed in the request header. Usage is\n            strongly encouraged.\n        timeout:\n            How long to wait for server to send data before giving up. Accepts\n            separate values for connect and read timeouts or a single value.\n\n    Raises:\n        TypeError:\n            If `agent`, `key`, `secret`, or `scopes` args are passed\n            anything other than a str.\n        ValueError:\n            If an empty str is passed to `key`, `secret` or `scopes` arg.\n        WorldcatAuthorizationError:\n            If request for token encounters any errors.\n    \"\"\"\n\n    self.agent = agent\n    self.grant_type = \"client_credentials\"\n    self.key = key\n    self.oauth_server = \"https://oauth.oclc.org\"\n    self.scopes = scopes\n    self.secret = secret\n    self.server_response: Optional[requests.Response] = None\n    self.timeout = timeout\n    self.token_expires_at: Optional[datetime.datetime] = None\n    self.token_str = \"\"\n    self.token_type = \"\"\n\n    # default bookops-worldcat request header\n    if isinstance(self.agent, str):\n        if not self.agent.strip():\n            self.agent = f\"{__title__}/{__version__}\"\n    else:\n        raise TypeError(\"Argument 'agent' must be a string.\")\n\n    # ensure passed arguments are valid\n    if isinstance(self.key, str):\n        if not self.key.strip():\n            raise ValueError(\"Argument 'key' cannot be an empty string.\")\n    else:\n        raise TypeError(\"Argument 'key' must be a string.\")\n\n    if isinstance(self.secret, str):\n        if not self.secret.strip():\n            raise ValueError(\"Argument 'secret' cannot be an empty string.\")\n    else:\n        raise TypeError(\"Argument 'secret' must be a string.\")\n\n    # validate passed scopes\n    if isinstance(self.scopes, str):\n        if not self.scopes.strip():\n            raise ValueError(\"Argument 'scopes' cannot be an empty string.\")\n    else:\n        raise TypeError(\"Argument 'scopes' must a string.\")\n    self.scopes = self.scopes.strip()\n\n    # initiate request\n    self._request_token()\n</code></pre>"},{"location":"api/authorize/#bookops_worldcat.authorize.WorldcatAccessToken.is_expired","title":"is_expired","text":"<pre><code>is_expired() -&gt; bool\n</code></pre> <p>Checks if the access token is expired.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether or not the token is expired.</p> <p> TYPE: <code>bool</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If <code>WorldcatAccessToken.token_expires_at</code> is not a <code>datetime.datetime</code> object.</p> Example <pre><code>token = WorldcatAccessToken(\n    key=\"my_WSKey_client_id\",\n    secret=\"my_WSKey_secret\",\n    scopes=\"WorldCatMetadataAPI\",\n    agent=\"my_app/1.0.0\")\nprint(token.is_expired())\n#&gt;False\n</code></pre> Source code in <code>bookops_worldcat\\authorize.py</code> <pre><code>def is_expired(self) -&gt; bool:\n    \"\"\"\n    Checks if the access token is expired.\n\n    Returns:\n        bool: Whether or not the token is expired.\n\n    Raises:\n        TypeError:\n            If `WorldcatAccessToken.token_expires_at` is not a\n            `datetime.datetime` object.\n\n    Example:\n        ```py\n        token = WorldcatAccessToken(\n            key=\"my_WSKey_client_id\",\n            secret=\"my_WSKey_secret\",\n            scopes=\"WorldCatMetadataAPI\",\n            agent=\"my_app/1.0.0\")\n        print(token.is_expired())\n        #&gt;False\n        ```\n    \"\"\"\n    if isinstance(self.token_expires_at, datetime.datetime):\n        if self.token_expires_at &lt; datetime.datetime.now(datetime.timezone.utc):\n            return True\n        else:\n            return False\n    else:\n        raise TypeError(\n            \"Attribute 'WorldcatAccessToken.token_expires_at' is of invalid type. \"\n            \"Expected `datetime.datetime` object.\"\n        )\n</code></pre>"},{"location":"api/errors/","title":"bookops_worldcat.errors","text":"<p>This module contains the set of bookops_worldcat exceptions.</p>"},{"location":"api/errors/#bookops_worldcat.errors.BookopsWorldcatError","title":"BookopsWorldcatError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for exceptions in this module.</p>"},{"location":"api/errors/#bookops_worldcat.errors.InvalidOclcNumber","title":"InvalidOclcNumber","text":"<p>               Bases: <code>BookopsWorldcatError</code></p> <p>Exception raised when an invalid OCLC record number is encountered</p>"},{"location":"api/errors/#bookops_worldcat.errors.WorldcatAuthorizationError","title":"WorldcatAuthorizationError","text":"<p>               Bases: <code>BookopsWorldcatError</code></p> <p>Exception raised when WorldCat access token is not obtained</p>"},{"location":"api/errors/#bookops_worldcat.errors.WorldcatRequestError","title":"WorldcatRequestError","text":"<p>               Bases: <code>BookopsWorldcatError</code></p> <p>Exceptions raised on HTTP errors returned by web service</p>"},{"location":"api/metadata_api/","title":"bookops_worldcat.metadata_api","text":"<p>WorldCat Metadata API wrapper session.</p>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession","title":"MetadataSession","text":"<pre><code>MetadataSession(\n    authorization: WorldcatAccessToken,\n    agent: Optional[str] = None,\n    timeout: Union[\n        int,\n        float,\n        Tuple[int, int],\n        Tuple[float, float],\n        None,\n    ] = (5, 5),\n    totalRetries: int = 0,\n    backoffFactor: float = 0,\n    statusForcelist: Optional[List[int]] = None,\n    allowedMethods: Optional[List[str]] = None,\n)\n</code></pre> <p>               Bases: <code>WorldcatSession</code></p> <p>The <code>MetadataSession</code> class supports interactions with the WorldCat Metadata API and the child methods of this class allow users to interact with each endpoint of the API.</p> <p><code>MetadataSession</code> inherits attributes and methods from <code>requests.Session</code> and <code>WorldcatSession</code> and contains specific functionality for interacting with the WorldCat Metadata API.</p> PARAMETER DESCRIPTION <code>authorization</code> <p><code>WorldcatAccessToken</code> object for session.</p> <p> TYPE: <code>WorldcatAccessToken</code> </p> <code>agent</code> <p><code>User-agent</code> for session to be passed in the request header. Usage is strongly encouraged.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>How long to wait for server to send data before giving up. Accepts separate values for connect and read timeouts or a single value.</p> <p> TYPE: <code>Union[int, float, Tuple[int, int], Tuple[float, float], None]</code> DEFAULT: <code>(5, 5)</code> </p> <code>totalRetries</code> <p>Optional number of times to retry a request that failed or timed out. If <code>totalRetries</code> argument is not passed, any arguments passed to <code>backoffFactor</code>, <code>statusForcelist</code>, and <code>allowedMethods</code> will be ignored.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>backoffFactor</code> <p>If <code>totalRetries</code> is not <code>0</code>, the backoff factor as a float to use to calculate amount of time session will sleep before attempting request again.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>statusForcelist</code> <p>If <code>totalRetries</code> is not <code>0</code>, a list of HTTP status codes to automatically retry requests on. If not specified, failed requests with status codes 413, 429, and 503 will be retried up to number of <code>totalRetries</code>.</p> <p>EXAMPLE: <code>[500, 502, 503, 504]</code></p> <p> TYPE: <code>Optional[List[int]]</code> DEFAULT: <code>None</code> </p> <code>allowedMethods</code> <p>If <code>totalRetries</code> is not <code>0</code>, set of HTTP methods that requests should be retried on. If not specified, requests using any HTTP method verbs will be retried.</p> <p>EXAMPLE: <code>[\"GET\", \"POST\"]</code></p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def __init__(\n    self,\n    authorization: WorldcatAccessToken,\n    agent: Optional[str] = None,\n    timeout: Union[int, float, Tuple[int, int], Tuple[float, float], None] = (\n        5,\n        5,\n    ),\n    totalRetries: int = 0,\n    backoffFactor: float = 0,\n    statusForcelist: Optional[List[int]] = None,\n    allowedMethods: Optional[List[str]] = None,\n) -&gt; None:\n    \"\"\"Initializes MetadataSession.\n\n    Args:\n        authorization:\n            `WorldcatAccessToken` object for session.\n        agent:\n            `User-agent` for session to be passed in the request header. Usage is\n            strongly encouraged.\n        timeout:\n            How long to wait for server to send data before giving up. Accepts\n            separate values for connect and read timeouts or a single value.\n        totalRetries:\n            Optional number of times to retry a request that failed or timed out.\n            If `totalRetries` argument is not passed, any arguments passed to\n            `backoffFactor`, `statusForcelist`, and `allowedMethods` will be\n            ignored.\n        backoffFactor:\n            If `totalRetries` is not `0`, the backoff factor as a float to use to\n            calculate amount of time session will sleep before attempting request\n            again.\n        statusForcelist:\n            If `totalRetries` is not `0`, a list of HTTP status codes to\n            automatically retry requests on. If not specified, failed requests\n            with status codes 413, 429, and 503 will be retried up to number of\n            `totalRetries`.\n\n            **EXAMPLE:** `[500, 502, 503, 504]`\n        allowedMethods:\n            If `totalRetries` is not `0`, set of HTTP methods that requests should\n            be retried on. If not specified, requests using any HTTP method verbs\n            will be retried.\n\n            **EXAMPLE:** `[\"GET\", \"POST\"]`\n    \"\"\"\n    super().__init__(\n        authorization,\n        agent=agent,\n        timeout=timeout,\n        totalRetries=totalRetries,\n        backoffFactor=backoffFactor,\n        statusForcelist=statusForcelist,\n        allowedMethods=allowedMethods,\n    )\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.bib_create","title":"bib_create","text":"<pre><code>bib_create(\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Create a bib record in OCLC if it does not already exist.</p> <p>Uses /manage/bibs endpoint.</p> PARAMETER DESCRIPTION <code>record</code> <p>MARC record to be created</p> <p> TYPE: <code>Union[str, bytes, BinaryIO]</code> </p> <code>recordFormat</code> <p>Format of MARC record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> </p> <code>responseFormat</code> <p>Format of returned record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/marcxml+xml'</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def bib_create(\n    self,\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Create a bib record in OCLC if it does not already exist.\n\n    Uses /manage/bibs endpoint.\n\n    Args:\n        record:\n            MARC record to be created\n        recordFormat:\n            Format of MARC record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        responseFormat:\n            Format of returned record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_bibs_create()\n    header = {\n        \"Accept\": responseFormat,\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"POST\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.bib_get","title":"bib_get","text":"<pre><code>bib_get(\n    oclcNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Send a GET request for a full bib record.</p> <p>Uses /manage/bibs/{oclcNumber} endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number. Can be an integer or string with or without OCLC Number prefix.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>responseFormat</code> <p>Format of returned record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/marcxml+xml'</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def bib_get(\n    self,\n    oclcNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Send a GET request for a full bib record.\n\n    Uses /manage/bibs/{oclcNumber} endpoint.\n\n    Args:\n        oclcNumber:\n            OCLC bibliographic record number. Can be an integer or string\n            with or without OCLC Number prefix.\n        responseFormat:\n            Format of returned record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_manage_bibs(oclcNumber)\n    header = {\"Accept\": responseFormat}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.bib_get_classification","title":"bib_get_classification","text":"<pre><code>bib_get_classification(\n    oclcNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given an OCLC number, retrieve classification recommendations for the bib record.</p> <p>Uses /search/classification-bibs/{oclcNumber} endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number. Can be an integer or string with or without OCLC Number prefix.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def bib_get_classification(\n    self,\n    oclcNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given an OCLC number, retrieve classification recommendations for the bib\n    record.\n\n    Uses /search/classification-bibs/{oclcNumber} endpoint.\n\n    Args:\n        oclcNumber:\n            OCLC bibliographic record number. Can be an integer or string\n            with or without OCLC Number prefix.\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_classification_bibs(oclcNumber)\n    header = {\"Accept\": \"application/json\"}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.bib_get_current_oclc_number","title":"bib_get_current_oclc_number","text":"<pre><code>bib_get_current_oclc_number(\n    oclcNumbers: Union[int, str, List[Union[str, int]]],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given one or more OCLC Numbers, retrieve current OCLC numbers.</p> <p>Uses /manage/bibs/current endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumbers</code> <p>Integer, string or list containing one or more OCLC numbers to be checked. Numbers can be integers or strings with or without OCLC Number prefix. If str, the numbers must be separated by a comma. If int, only one number may be passed as an arg.</p> <p> TYPE: <code>Union[int, str, List[Union[str, int]]]</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If more than 10 items passed to <code>oclcNumbers</code> arg.</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def bib_get_current_oclc_number(\n    self,\n    oclcNumbers: Union[int, str, List[Union[str, int]]],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given one or more OCLC Numbers, retrieve current OCLC numbers.\n\n    Uses /manage/bibs/current endpoint.\n\n    Args:\n        oclcNumbers:\n            Integer, string or list containing one or more OCLC numbers to be\n            checked. Numbers can be integers or strings with or without OCLC\n            Number prefix. If str, the numbers must be separated by a comma.\n            If int, only one number may be passed as an arg.\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Raises:\n        ValueError: If more than 10 items passed to `oclcNumbers` arg.\n    \"\"\"\n    vetted_numbers = verify_oclc_numbers(oclcNumbers)\n\n    # check that no more than 10 oclc numbers were passed\n    if len(vetted_numbers) &gt; 10:\n        raise ValueError(\"Too many OCLC Numbers passed to 'oclcNumbers' argument.\")\n\n    header = {\"Accept\": \"application/json\"}\n    url = self._url_manage_bibs_current_oclc_number()\n    payload = {\"oclcNumbers\": \",\".join(vetted_numbers)}\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.bib_match","title":"bib_match","text":"<pre><code>bib_match(\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given a bib record in MARC21 or MARCXML identify the best match in WorldCat. Record must contain at minimum an 008 and 245. Response contains number of potential matches in <code>numberOfRecords</code> and best match in <code>briefRecords</code>.</p> <p>Uses /manage/bibs/match endpoint.</p> PARAMETER DESCRIPTION <code>record</code> <p>MARC record to be matched.</p> <p> TYPE: <code>Union[str, bytes, BinaryIO]</code> </p> <code>recordFormat</code> <p>Format of MARC record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def bib_match(\n    self,\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given a bib record in MARC21 or MARCXML identify the best match in WorldCat.\n    Record must contain at minimum an 008 and 245. Response contains number of\n    potential matches in `numberOfRecords` and best match in `briefRecords`.\n\n    Uses /manage/bibs/match endpoint.\n\n    Args:\n        record:\n            MARC record to be matched.\n        recordFormat:\n            Format of MARC record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_bibs_match()\n    header = {\n        \"Accept\": \"application/json\",\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"POST\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.bib_replace","title":"bib_replace","text":"<pre><code>bib_replace(\n    oclcNumber: Union[int, str],\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given an OCLC number and MARC record, find record in WorldCat and replace it. If the record does not exist in WorldCat, a new bib record will be created.</p> <p>Uses /manage/bibs/{oclcNumber} endpoint.</p> PARAMETER DESCRIPTION <code>record</code> <p>MARC record to replace existing WorldCat record</p> <p> TYPE: <code>Union[str, bytes, BinaryIO]</code> </p> <code>recordFormat</code> <p>Format of MARC record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> </p> <code>responseFormat</code> <p>Format of returned record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/marcxml+xml'</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def bib_replace(\n    self,\n    oclcNumber: Union[int, str],\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given an OCLC number and MARC record, find record in WorldCat and replace it.\n    If the record does not exist in WorldCat, a new bib record will be created.\n\n    Uses /manage/bibs/{oclcNumber} endpoint.\n\n    Args:\n        record:\n            MARC record to replace existing WorldCat record\n        recordFormat:\n            Format of MARC record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        responseFormat:\n            Format of returned record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_manage_bibs(oclcNumber)\n    header = {\n        \"Accept\": responseFormat,\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"PUT\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.bib_search","title":"bib_search","text":"<pre><code>bib_search(\n    oclcNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Send a GET request for a full bib record in JSON format.</p> <p>Uses /search/bibs/{oclcNumber} endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number. Can be an integer or string with or without OCLC Number prefix.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def bib_search(\n    self,\n    oclcNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Send a GET request for a full bib record in JSON format.\n\n    Uses /search/bibs/{oclcNumber} endpoint.\n\n    Args:\n        oclcNumber:\n            OCLC bibliographic record number. Can be an integer or string\n            with or without OCLC Number prefix.\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_bibs(oclcNumber)\n    header = {\"Accept\": \"application/json\"}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.bib_validate","title":"bib_validate","text":"<pre><code>bib_validate(\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    validationLevel: str = \"validateFull\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given a bib record, validate that record conforms to MARC standards.</p> <p>Uses /manage/bibs/validate/{validationLevel} endpoint.</p> PARAMETER DESCRIPTION <code>record</code> <p>MARC record to validate</p> <p> TYPE: <code>Union[str, bytes, BinaryIO]</code> </p> <code>recordFormat</code> <p>Format of MARC record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> </p> <code>validationLevel</code> <p>Level at which to validate records.</p> <p>OPTIONS: <code>'validateFull'</code>, <code>'validateAdd'</code>, <code>'validateReplace'</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'validateFull'</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> RAISES DESCRIPTION <code>ValueError</code> <p>If value of arg passed to <code>validationLevel</code> is not <code>'validateFull'</code>, <code>'validateAdd'</code>, or <code>'validateReplace'</code>.</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def bib_validate(\n    self,\n    record: Union[str, bytes, BinaryIO],\n    recordFormat: str,\n    validationLevel: str = \"validateFull\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given a bib record, validate that record conforms to MARC standards.\n\n    Uses /manage/bibs/validate/{validationLevel} endpoint.\n\n    Args:\n        record:\n            MARC record to validate\n        recordFormat:\n            Format of MARC record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        validationLevel:\n            Level at which to validate records.\n\n            **OPTIONS:** `'validateFull'`, `'validateAdd'`, `'validateReplace'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n\n    Raises:\n        ValueError:\n            If value of arg passed to `validationLevel` is not\n            `'validateFull'`, `'validateAdd'`, or `'validateReplace'`.\n    \"\"\"\n    if validationLevel not in [\"validateFull\", \"validateAdd\", \"validateReplace\"]:\n        raise ValueError(\n            \"Invalid argument 'validationLevel'.\"\n            \"Must be either 'validateFull', 'validateAdd', or 'validateReplace'\"\n        )\n\n    url = self._url_manage_bibs_validate(validationLevel)\n    header = {\n        \"Accept\": \"application/json\",\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\n        \"POST\",\n        url,\n        data=record,\n        headers=header,\n        hooks=hooks,\n    )\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.brief_bibs_get","title":"brief_bibs_get","text":"<pre><code>brief_bibs_get(\n    oclcNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Retrieve specific brief bibliographic resource.</p> <p>Uses /search/brief-bibs/{oclcNumber} endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number. Can be an integer or string with or without OCLC Number prefix.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def brief_bibs_get(\n    self, oclcNumber: Union[int, str], hooks: Optional[Dict[str, Callable]] = None\n) -&gt; Response:\n    \"\"\"\n    Retrieve specific brief bibliographic resource.\n\n    Uses /search/brief-bibs/{oclcNumber} endpoint.\n\n    Args:\n        oclcNumber:\n            OCLC bibliographic record number. Can be an integer or string\n            with or without OCLC Number prefix.\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_brief_bibs_oclc_number(oclcNumber)\n    header = {\"Accept\": \"application/json\"}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.brief_bibs_get_other_editions","title":"brief_bibs_get_other_editions","text":"<pre><code>brief_bibs_get_other_editions(\n    oclcNumber: Union[int, str],\n    deweyNumber: Optional[Union[str, List[str]]] = None,\n    datePublished: Optional[Union[str, List[str]]] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[Union[str, List[str]]] = None,\n    heldByInstitutionID: Optional[\n        Union[str, int, List[Union[str, int]]]\n    ] = None,\n    inLanguage: Optional[Union[str, List[str]]] = None,\n    inCatalogLanguage: Optional[str] = \"eng\",\n    materialType: Optional[str] = None,\n    catalogSource: Optional[str] = None,\n    itemType: Optional[Union[str, List[str]]] = None,\n    itemSubType: Optional[Union[str, List[str]]] = None,\n    retentionCommitments: bool = False,\n    spProgram: Optional[str] = None,\n    genre: Optional[str] = None,\n    topic: Optional[str] = None,\n    subtopic: Optional[str] = None,\n    audience: Optional[str] = None,\n    content: Optional[Union[str, List[str]]] = None,\n    openAccess: Optional[bool] = None,\n    peerReviewed: Optional[bool] = None,\n    facets: Optional[Union[str, List[str]]] = None,\n    groupVariantRecords: bool = False,\n    preferredLanguage: str = \"eng\",\n    showHoldingsIndicators: bool = False,\n    offset: int = 1,\n    limit: int = 10,\n    orderBy: str = \"publicationDateDesc\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Retrieve other editions related to bibliographic resource with provided OCLC Number. Query may contain only one of: <code>heldByInstitutionID</code>, <code>heldByGroup</code>, <code>heldBySymbol</code>, or <code>spProgram</code>.</p> <p>Uses /brief-bibs/{oclcNumber}/other-editions endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number. Can be an integer or string with or without OCLC Number prefix.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>deweyNumber</code> <p>Limits response to the specified dewey classification number(s). For multiple values repeat the parameter.</p> <p>EXAMPLE: <code>'794'</code></p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>datePublished</code> <p>Limits response to one or more dates, or to a range.</p> <p>EXAMPLES: <code>'2000'</code>, <code>'2000-2005'</code>, <code>'2000,2005'</code></p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>heldByGroup</code> <p>Limits response to holdings held by group symbol.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldBySymbol</code> <p>Limits response to holdings held by specified institution symbol.</p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>heldByInstitutionID</code> <p>Limits response to holdings held by specified institution registryId.</p> <p> TYPE: <code>Optional[Union[str, int, List[Union[str, int]]]]</code> DEFAULT: <code>None</code> </p> <code>inLanguage</code> <p>Limits response to the single specified language</p> <p>EXAMPLE: <code>'fre'</code></p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>inCatalogLanguage</code> <p>Limits response to specified cataloging language.</p> <p>EXAMPLE: <code>'eng'</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'eng'</code> </p> <code>materialType</code> <p>Limits response to specified material type.</p> <p>EXAMPLES: <code>'bks'</code>, <code>'vis'</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>catalogSource</code> <p>Limits response to single OCLC symbol as the cataloging source.</p> <p>EXAMPLE: <code>'DLC'</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>itemType</code> <p>Limits response to specified item type.</p> <p>EXAMPLES: <code>'book'</code>, <code>'vis'</code></p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>itemSubType</code> <p>Limits response to specified item sub type</p> <p>EXAMPLES: <code>'book-digital'</code>, <code>'audiobook-cd'</code></p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>retentionCommitments</code> <p>Limits response to bibliographic records with retention commitment.</p> <p>OPTIONS: <code>True</code> or <code>False</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>spProgram</code> <p>Limits response to bibliographic records associated with particular shared print program.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>genre</code> <p>Genre to limit response to (ge index).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>topic</code> <p>Topic to limit response to (s0 index).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>subtopic</code> <p>Subtopic to limit response to (s1 index).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>audience</code> <p>Audience to limit response to.</p> <p>OPTIONS: <code>'juv'</code> or <code>'nonJuv'</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>content</code> <p>Content to limit response to.</p> <p>OPTIONS: <code>'fic'</code>, <code>'nonFic'</code>, <code>'bio'</code></p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>openAccess</code> <p>Limits response to just open access content.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>peerReviewed</code> <p>Limits response to just peer reviewed content.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>facets</code> <p>List of facets to limit responses.</p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>groupVariantRecords</code> <p>Whether or not to group variant records.</p> <p>OPTIONS: <code>True</code> or <code>False</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>preferredLanguage</code> <p>Language user would prefer metadata description in. Does not limit responses. To limit responses use <code>inCataloglanguage</code> facet.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'eng'</code> </p> <code>showHoldingsIndicators</code> <p>Whether or not to show holdings indicators in response.</p> <p>OPTIONS: <code>True</code> or <code>False</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>offset</code> <p>Start position of bibliographic records to return.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>limit</code> <p>Maximum number of records to return.</p> <p>MAXIMUM: <code>50</code></p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>orderBy</code> <p>Results sort key.</p> <p>OPTIONS:</p> <ul> <li><code>'recency'</code></li> <li><code>'bestMatch'</code></li> <li><code>'creator'</code></li> <li><code>'library'</code></li> <li><code>'publicationDateAsc'</code></li> <li><code>'publicationDateDesc'</code></li> <li><code>'mostWidelyHeld'</code></li> <li><code>'title'</code></li> </ul> <p> TYPE: <code>str</code> DEFAULT: <code>'publicationDateDesc'</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def brief_bibs_get_other_editions(\n    self,\n    oclcNumber: Union[int, str],\n    deweyNumber: Optional[Union[str, List[str]]] = None,\n    datePublished: Optional[Union[str, List[str]]] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[Union[str, List[str]]] = None,\n    heldByInstitutionID: Optional[Union[str, int, List[Union[str, int]]]] = None,\n    inLanguage: Optional[Union[str, List[str]]] = None,\n    inCatalogLanguage: Optional[str] = \"eng\",\n    materialType: Optional[str] = None,\n    catalogSource: Optional[str] = None,\n    itemType: Optional[Union[str, List[str]]] = None,\n    itemSubType: Optional[Union[str, List[str]]] = None,\n    retentionCommitments: bool = False,\n    spProgram: Optional[str] = None,\n    genre: Optional[str] = None,\n    topic: Optional[str] = None,\n    subtopic: Optional[str] = None,\n    audience: Optional[str] = None,\n    content: Optional[Union[str, List[str]]] = None,\n    openAccess: Optional[bool] = None,\n    peerReviewed: Optional[bool] = None,\n    facets: Optional[Union[str, List[str]]] = None,\n    groupVariantRecords: bool = False,\n    preferredLanguage: str = \"eng\",\n    showHoldingsIndicators: bool = False,\n    offset: int = 1,\n    limit: int = 10,\n    orderBy: str = \"publicationDateDesc\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Retrieve other editions related to bibliographic resource with provided\n    OCLC Number. Query may contain only one of: `heldByInstitutionID`,\n    `heldByGroup`, `heldBySymbol`, or `spProgram`.\n\n    Uses /brief-bibs/{oclcNumber}/other-editions endpoint.\n\n    Args:\n        oclcNumber:\n            OCLC bibliographic record number. Can be an integer or string\n            with or without OCLC Number prefix.\n        deweyNumber:\n            Limits response to the specified dewey classification number(s).\n            For multiple values repeat the parameter.\n\n            **EXAMPLE:** `'794'`\n        datePublished:\n            Limits response to one or more dates, or to a range.\n\n            **EXAMPLES:** `'2000'`, `'2000-2005'`, `'2000,2005'`\n        heldByGroup:\n            Limits response to holdings held by group symbol.\n        heldBySymbol:\n            Limits response to holdings held by specified institution symbol.\n        heldByInstitutionID:\n            Limits response to holdings held by specified institution registryId.\n        inLanguage:\n            Limits response to the single specified language\n\n            **EXAMPLE:** `'fre'`\n        inCatalogLanguage:\n            Limits response to specified cataloging language.\n\n            **EXAMPLE:** `'eng'`\n        materialType:\n            Limits response to specified material type.\n\n            **EXAMPLES:** `'bks'`, `'vis'`\n        catalogSource:\n            Limits response to single OCLC symbol as the cataloging source.\n\n            **EXAMPLE:** `'DLC'`\n        itemType:\n            Limits response to specified item type.\n\n            **EXAMPLES:** `'book'`, `'vis'`\n        itemSubType:\n            Limits response to specified item sub type\n\n            **EXAMPLES:** `'book-digital'`, `'audiobook-cd'`\n        retentionCommitments:\n            Limits response to bibliographic records with retention commitment.\n\n            **OPTIONS:** `True` or `False`\n        spProgram:\n            Limits response to bibliographic records associated with particular\n            shared print program.\n        genre:\n            Genre to limit response to (ge index).\n        topic:\n            Topic to limit response to (s0 index).\n        subtopic:\n            Subtopic to limit response to (s1 index).\n        audience:\n            Audience to limit response to.\n\n            **OPTIONS:** `'juv'` or `'nonJuv'`\n        content:\n            Content to limit response to.\n\n            **OPTIONS:** `'fic'`, `'nonFic'`, `'bio'`\n        openAccess:\n            Limits response to just open access content.\n        peerReviewed:\n            Limits response to just peer reviewed content.\n        facets:\n            List of facets to limit responses.\n        groupVariantRecords:\n            Whether or not to group variant records.\n\n            **OPTIONS:** `True` or `False`\n        preferredLanguage:\n            Language user would prefer metadata description in. Does not limit\n            responses. To limit responses use `inCataloglanguage` facet.\n        showHoldingsIndicators:\n            Whether or not to show holdings indicators in response.\n\n            **OPTIONS:** `True` or `False`\n        offset:\n            Start position of bibliographic records to return.\n        limit:\n            Maximum number of records to return.\n\n            **MAXIMUM:** `50`\n        orderBy:\n            Results sort key.\n\n            **OPTIONS:**\n\n            - `'recency'`\n            - `'bestMatch'`\n            - `'creator'`\n            - `'library'`\n            - `'publicationDateAsc'`\n            - `'publicationDateDesc'`\n            - `'mostWidelyHeld'`\n            - `'title'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_brief_bibs_other_editions(oclcNumber)\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"deweyNumber\": deweyNumber,\n        \"datePublished\": datePublished,\n        \"heldByGroup\": heldByGroup,\n        \"heldBySymbol\": heldBySymbol,\n        \"heldByInstitutionID\": heldByInstitutionID,\n        \"inLanguage\": inLanguage,\n        \"inCatalogLanguage\": inCatalogLanguage,\n        \"materialType\": materialType,\n        \"catalogSource\": catalogSource,\n        \"itemType\": itemType,\n        \"itemSubType\": itemSubType,\n        \"retentionCommitments\": retentionCommitments,\n        \"spProgram\": spProgram,\n        \"genre\": genre,\n        \"topic\": topic,\n        \"subtopic\": subtopic,\n        \"audience\": audience,\n        \"content\": content,\n        \"openAccess\": openAccess,\n        \"peerReviewed\": peerReviewed,\n        \"facets\": facets,\n        \"groupVariantRecords\": groupVariantRecords,\n        \"preferredLanguage\": preferredLanguage,\n        \"showHoldingsIndicators\": showHoldingsIndicators,\n        \"offset\": offset,\n        \"limit\": limit,\n        \"orderBy\": orderBy,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.brief_bibs_search","title":"brief_bibs_search","text":"<pre><code>brief_bibs_search(\n    q: str,\n    deweyNumber: Optional[Union[str, List[str]]] = None,\n    datePublished: Optional[Union[str, List[str]]] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[Union[str, List[str]]] = None,\n    heldByInstitutionID: Optional[\n        Union[str, int, List[str], List[int]]\n    ] = None,\n    inLanguage: Optional[Union[str, List[str]]] = None,\n    inCatalogLanguage: Optional[str] = \"eng\",\n    materialType: Optional[str] = None,\n    catalogSource: Optional[str] = None,\n    itemType: Optional[Union[str, List[str]]] = None,\n    itemSubType: Optional[Union[str, List[str]]] = None,\n    retentionCommitments: bool = False,\n    spProgram: Optional[str] = None,\n    genre: Optional[str] = None,\n    topic: Optional[str] = None,\n    subtopic: Optional[str] = None,\n    audience: Optional[str] = None,\n    content: Optional[Union[str, List[str]]] = None,\n    openAccess: Optional[bool] = None,\n    peerReviewed: Optional[bool] = None,\n    facets: Optional[Union[str, List[str]]] = None,\n    groupRelatedEditions: bool = False,\n    groupVariantRecords: bool = False,\n    preferredLanguage: str = \"eng\",\n    showHoldingsIndicators: bool = False,\n    lat: Optional[float] = None,\n    lon: Optional[float] = None,\n    distance: Optional[int] = None,\n    unit: str = \"M\",\n    orderBy: str = \"bestMatch\",\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Search for brief bibliographic resources using WorldCat query syntax. See OCLC Bibliographic Records Index Documentation for more information on available indexes. Request may contain only one of: <code>heldByInstitutionID</code>, <code>heldByGroup</code>, <code>heldBySymbol</code>, or combination of <code>lat</code> and <code>lon</code>.</p> <p>Uses /search/brief-bibs endpoint.</p> PARAMETER DESCRIPTION <code>q</code> <p>Query in the form of a keyword search or fielded search.</p> <p>EXAMPLES:</p> <ul> <li><code>ti:Zendegi</code></li> <li><code>ti:\"Czarne oceany\"</code></li> <li><code>bn:9781680502404</code></li> <li><code>kw:python databases</code></li> <li><code>ti:Zendegi AND au:greg egan</code></li> <li><code>(au:Okken OR au:Myers) AND su:python</code></li> </ul> <p> TYPE: <code>str</code> </p> <code>deweyNumber</code> <p>Limits the response to the specified dewey classification number(s). For multiple values repeat the parameter.</p> <p>EXAMPLE: <code>'794'</code></p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>datePublished</code> <p>Restricts the response to one or more dates, or to a range.</p> <p>EXAMPLES: <code>'2000'</code>, <code>'2000-2005'</code>, <code>'2000,2005'</code></p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>heldByGroup</code> <p>Limits response to holdings held by group symbol.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldBySymbol</code> <p>Limits response to holdings held by specified institution symbol.</p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>heldByInstitutionID</code> <p>Limits response to holdings held by specified institution registryId.</p> <p> TYPE: <code>Optional[Union[str, int, List[str], List[int]]]</code> DEFAULT: <code>None</code> </p> <code>inLanguage</code> <p>Limits response to the single specified language</p> <p>EXAMPLE: <code>'fre'</code></p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>inCatalogLanguage</code> <p>Limits response to specified cataloging language.</p> <p>EXAMPLE: <code>'eng'</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'eng'</code> </p> <code>materialType</code> <p>Limits response to specified material type.</p> <p>EXAMPLES: <code>'bks'</code>, <code>'vis'</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>catalogSource</code> <p>Limits response to single OCLC symbol as the cataloging source.</p> <p>EXAMPLE: <code>'DLC'</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>itemType</code> <p>Limits response to specified item type.</p> <p>EXAMPLE: <code>'book'</code>, <code>'vis'</code></p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>itemSubType</code> <p>Limits response to specified item subtype.</p> <p>EXAMPLES: <code>'book-digital'</code>, <code>'audiobook-cd'</code></p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>retentionCommitments</code> <p>Limits response to bibliographic records with retention commitment.</p> <p>OPTIONS: <code>True</code> or <code>False</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>spProgram</code> <p>Limits response to bibliographic records associated with particular shared print program.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>genre</code> <p>Genre to limit response to (ge index).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>topic</code> <p>Topic to limit response to (s0 index).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>subtopic</code> <p>Subtopic to limit response to (s1 index).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>audience</code> <p>Audience to limit response to.</p> <p>OPTIONS: <code>'juv'</code> or <code>'nonJuv'</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>content</code> <p>Content to limit response to.</p> <p>OPTIONS: <code>'fic'</code>, <code>'nonFic'</code>, <code>'bio'</code></p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>openAccess</code> <p>Limits response to just open access content.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>peerReviewed</code> <p>Limits response to just peer reviewed content.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>facets</code> <p>List of facets to limit responses.</p> <p> TYPE: <code>Optional[Union[str, List[str]]]</code> DEFAULT: <code>None</code> </p> <code>groupRelatedEditions</code> <p>Whether or not use FRBR grouping.</p> <p>OPTIONS: <code>True</code> or <code>False</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>groupVariantRecords</code> <p>Whether or not to group variant records.</p> <p>OPTIONS: <code>True</code> or <code>False</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>preferredLanguage</code> <p>Language user would prefer metadata description in. Does not limit responses. To limit responses use <code>inCataloglanguage</code> facet.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'eng'</code> </p> <code>showHoldingsIndicators</code> <p>Whether or not to show holdings indicators in response. OPTIONS: <code>True</code> or <code>False</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>lat</code> <p>Latitude</p> <p>EXAMPLE: <code>37.502508</code></p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>lon</code> <p>Longitude</p> <p>EXAMPLE: <code>-122.22702</code></p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>distance</code> <p>Limits response to holdings held by institutions within specified distance from latitude and longitude.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>unit</code> <p>Unit of distance from latitude and longitude.</p> <p>OPTIONS: <code>'M'</code> (miles) or <code>'K'</code> (kilometers)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'M'</code> </p> <code>orderBy</code> <p>Results sort key.</p> <p>OPTIONS:</p> <ul> <li><code>'recency'</code></li> <li><code>'bestMatch'</code></li> <li><code>'creator'</code></li> <li><code>'library'</code></li> <li><code>'publicationDateAsc'</code></li> <li><code>'publicationDateDesc'</code></li> <li><code>'mostWidelyHeld'</code></li> <li><code>'title'</code></li> </ul> <p> TYPE: <code>str</code> DEFAULT: <code>'bestMatch'</code> </p> <code>offset</code> <p>Start position of bibliographic records to return.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>limit</code> <p>Maximum number of records to return.</p> <p>MAXIMUM: <code>50</code></p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def brief_bibs_search(\n    self,\n    q: str,\n    deweyNumber: Optional[Union[str, List[str]]] = None,\n    datePublished: Optional[Union[str, List[str]]] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[Union[str, List[str]]] = None,\n    heldByInstitutionID: Optional[Union[str, int, List[str], List[int]]] = None,\n    inLanguage: Optional[Union[str, List[str]]] = None,\n    inCatalogLanguage: Optional[str] = \"eng\",\n    materialType: Optional[str] = None,\n    catalogSource: Optional[str] = None,\n    itemType: Optional[Union[str, List[str]]] = None,\n    itemSubType: Optional[Union[str, List[str]]] = None,\n    retentionCommitments: bool = False,\n    spProgram: Optional[str] = None,\n    genre: Optional[str] = None,\n    topic: Optional[str] = None,\n    subtopic: Optional[str] = None,\n    audience: Optional[str] = None,\n    content: Optional[Union[str, List[str]]] = None,\n    openAccess: Optional[bool] = None,\n    peerReviewed: Optional[bool] = None,\n    facets: Optional[Union[str, List[str]]] = None,\n    groupRelatedEditions: bool = False,\n    groupVariantRecords: bool = False,\n    preferredLanguage: str = \"eng\",\n    showHoldingsIndicators: bool = False,\n    lat: Optional[float] = None,\n    lon: Optional[float] = None,\n    distance: Optional[int] = None,\n    unit: str = \"M\",\n    orderBy: str = \"bestMatch\",\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Search for brief bibliographic resources using WorldCat query syntax.\n    See OCLC\n    [Bibliographic Records Index Documentation](https://help.oclc.org/Librarian_Toolbox/Searching_WorldCat_Indexes/Bibliographic_records/Bibliographic_record_indexes)\n    for more information on available indexes. Request may contain\n    only one of: `heldByInstitutionID`, `heldByGroup`, `heldBySymbol`, or\n    combination of `lat` and `lon`.\n\n    Uses /search/brief-bibs endpoint.\n\n    Args:\n        q:\n            Query in the form of a keyword search or fielded search.\n\n            **EXAMPLES:**\n\n            - `ti:Zendegi`\n            - `ti:\"Czarne oceany\"`\n            - `bn:9781680502404`\n            - `kw:python databases`\n            - `ti:Zendegi AND au:greg egan`\n            - `(au:Okken OR au:Myers) AND su:python`\n\n        deweyNumber:\n            Limits the response to the specified dewey classification number(s).\n            For multiple values repeat the parameter.\n\n            **EXAMPLE:** `'794'`\n        datePublished:\n            Restricts the response to one or more dates, or to a range.\n\n            **EXAMPLES:** `'2000'`, `'2000-2005'`, `'2000,2005'`\n        heldByGroup:\n            Limits response to holdings held by group symbol.\n        heldBySymbol:\n            Limits response to holdings held by specified institution symbol.\n        heldByInstitutionID:\n            Limits response to holdings held by specified institution registryId.\n        inLanguage:\n            Limits response to the single specified language\n\n            **EXAMPLE:** `'fre'`\n        inCatalogLanguage:\n            Limits response to specified cataloging language.\n\n            **EXAMPLE:** `'eng'`\n        materialType:\n            Limits response to specified material type.\n\n            **EXAMPLES:** `'bks'`, `'vis'`\n        catalogSource:\n            Limits response to single OCLC symbol as the cataloging source.\n\n            **EXAMPLE:** `'DLC'`\n        itemType:\n            Limits response to specified item type.\n\n            **EXAMPLE:** `'book'`, `'vis'`\n        itemSubType:\n            Limits response to specified item subtype.\n\n            **EXAMPLES:** `'book-digital'`, `'audiobook-cd'`\n        retentionCommitments:\n            Limits response to bibliographic records with retention commitment.\n\n            **OPTIONS:** `True` or `False`\n        spProgram:\n            Limits response to bibliographic records associated with particular\n            shared print program.\n        genre:\n            Genre to limit response to (ge index).\n        topic:\n            Topic to limit response to (s0 index).\n        subtopic:\n            Subtopic to limit response to (s1 index).\n        audience:\n            Audience to limit response to.\n\n            **OPTIONS:** `'juv'` or `'nonJuv'`\n        content:\n            Content to limit response to.\n\n            **OPTIONS:** `'fic'`, `'nonFic'`, `'bio'`\n        openAccess:\n            Limits response to just open access content.\n        peerReviewed:\n            Limits response to just peer reviewed content.\n        facets:\n            List of facets to limit responses.\n        groupRelatedEditions:\n            Whether or not use FRBR grouping.\n\n            **OPTIONS:** `True` or `False`\n        groupVariantRecords:\n            Whether or not to group variant records.\n\n            **OPTIONS:** `True` or `False`\n        preferredLanguage:\n            Language user would prefer metadata description in. Does not limit\n            responses. To limit responses use `inCataloglanguage` facet.\n        showHoldingsIndicators:\n            Whether or not to show holdings indicators in response.\n            **OPTIONS:** `True` or `False`\n        lat:\n            Latitude\n\n            **EXAMPLE:** `37.502508`\n        lon:\n            Longitude\n\n            **EXAMPLE:** `-122.22702`\n        distance:\n            Limits response to holdings held by institutions within specified\n            distance from latitude and longitude.\n        unit:\n            Unit of distance from latitude and longitude.\n\n            **OPTIONS:** `'M'` (miles) or `'K'` (kilometers)\n        orderBy:\n            Results sort key.\n\n            **OPTIONS:**\n\n            - `'recency'`\n            - `'bestMatch'`\n            - `'creator'`\n            - `'library'`\n            - `'publicationDateAsc'`\n            - `'publicationDateDesc'`\n            - `'mostWidelyHeld'`\n            - `'title'`\n        offset:\n            Start position of bibliographic records to return.\n        limit:\n            Maximum number of records to return.\n\n            **MAXIMUM:** `50`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"  # noqa: E501\n    url = self._url_search_brief_bibs()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"q\": q,\n        \"deweyNumber\": deweyNumber,\n        \"datePublished\": datePublished,\n        \"heldByGroup\": heldByGroup,\n        \"heldBySymbol\": heldBySymbol,\n        \"heldByInstitutionID\": heldByInstitutionID,\n        \"inLanguage\": inLanguage,\n        \"inCatalogLanguage\": inCatalogLanguage,\n        \"materialType\": materialType,\n        \"catalogSource\": catalogSource,\n        \"itemType\": itemType,\n        \"itemSubType\": itemSubType,\n        \"retentionCommitments\": retentionCommitments,\n        \"spProgram\": spProgram,\n        \"genre\": genre,\n        \"topic\": topic,\n        \"subtopic\": subtopic,\n        \"audience\": audience,\n        \"content\": content,\n        \"openAccess\": openAccess,\n        \"peerReviewed\": peerReviewed,\n        \"facets\": facets,\n        \"groupRelatedEditions\": groupRelatedEditions,\n        \"groupVariantRecords\": groupVariantRecords,\n        \"preferredLanguage\": preferredLanguage,\n        \"showHoldingsIndicators\": showHoldingsIndicators,\n        \"lat\": lat,\n        \"lon\": lon,\n        \"distance\": distance,\n        \"unit\": unit,\n        \"orderBy\": orderBy,\n        \"offset\": offset,\n        \"limit\": limit,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_get_codes","title":"holdings_get_codes","text":"<pre><code>holdings_get_codes(\n    hooks: Optional[Dict[str, Callable]] = None\n) -&gt; Response\n</code></pre> <p>Retrieve the all holding codes for the authenticated institution.</p> <p>Uses /manage/institution/holding-codes endpoint.</p> PARAMETER DESCRIPTION <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def holdings_get_codes(\n    self,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Retrieve the all holding codes for the authenticated institution.\n\n    Uses /manage/institution/holding-codes endpoint.\n\n    Args:\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_ih_codes()\n    header = {\"Accept\": \"application/json\"}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_get_current","title":"holdings_get_current","text":"<pre><code>holdings_get_current(\n    oclcNumbers: Union[int, str, List[Union[str, int]]],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Retrieves WorldCat holdings status of a record with provided OCLC number. The service automatically recognizes the user's institution based on the issued access token.</p> <p>Uses /manage/institution/holdings/current endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumbers</code> <p>Integer, string or list containing one or more OCLC numbers to be checked. Numbers can be integers or strings with or without OCLC Number prefix. If str, the numbers must be separated by a comma. If int, only one number may be passed as an arg.</p> <p> TYPE: <code>Union[int, str, List[Union[str, int]]]</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> RAISES DESCRIPTION <code>ValueError</code> <p>If more than 10 items passed to <code>oclcNumbers</code> arg.</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def holdings_get_current(\n    self,\n    oclcNumbers: Union[int, str, List[Union[str, int]]],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Retrieves WorldCat holdings status of a record with provided OCLC number.\n    The service automatically recognizes the user's institution based on the\n    issued access token.\n\n    Uses /manage/institution/holdings/current endpoint.\n\n    Args:\n        oclcNumbers:\n            Integer, string or list containing one or more OCLC numbers to be\n            checked. Numbers can be integers or strings with or without OCLC\n            Number prefix. If str, the numbers must be separated by a comma.\n            If int, only one number may be passed as an arg.\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n\n    Raises:\n        ValueError: If more than 10 items passed to `oclcNumbers` arg.\n    \"\"\"\n    vetted_numbers = verify_oclc_numbers(oclcNumbers)\n\n    # check that no more than 10 oclc numbers were passed\n    if len(vetted_numbers) &gt; 10:\n        raise ValueError(\"Too many OCLC Numbers passed to 'oclcNumbers' argument.\")\n\n    url = self._url_manage_ih_current()\n    header = {\"Accept\": \"application/json\"}\n\n    payload = {\"oclcNumbers\": vetted_numbers}\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_set","title":"holdings_set","text":"<pre><code>holdings_set(\n    oclcNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Sets institution's WorldCat holdings on an individual record.</p> <p>Uses /manage/institions/holdings/{oclcNumber}/set endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number. Can be an integer or string with or without OCLC Number prefix.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def holdings_set(\n    self,\n    oclcNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Sets institution's WorldCat holdings on an individual record.\n\n    Uses /manage/institions/holdings/{oclcNumber}/set endpoint.\n\n    Args:\n        oclcNumber:\n            OCLC bibliographic record number. Can be an integer or string\n            with or without OCLC Number prefix.\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_manage_ih_set(oclcNumber)\n    header = {\"Accept\": \"application/json\"}\n\n    # prep request\n    req = Request(\"POST\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_set_with_bib","title":"holdings_set_with_bib","text":"<pre><code>holdings_set_with_bib(\n    record: str,\n    recordFormat: str,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given a MARC record in MARCXML or MARC21, set institution holdings on the record. MARC record must contain OCLC number in 001 or 035 subfield a. Only one MARC record is allowed in the request body.</p> <p>Uses /manage/institution/holdings/set endpoint.</p> PARAMETER DESCRIPTION <code>record</code> <p>MARC record on which to set holdings.</p> <p> TYPE: <code>str</code> </p> <code>recordFormat</code> <p>Format of MARC record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def holdings_set_with_bib(\n    self,\n    record: str,\n    recordFormat: str,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given a MARC record in MARCXML or MARC21, set institution holdings on the\n    record. MARC record must contain OCLC number in 001 or 035 subfield a.\n    Only one MARC record is allowed in the request body.\n\n    Uses /manage/institution/holdings/set endpoint.\n\n    Args:\n        record:\n            MARC record on which to set holdings.\n        recordFormat:\n            Format of MARC record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_ih_set_with_bib()\n    header = {\n        \"Accept\": \"application/json\",\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"POST\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_unset","title":"holdings_unset","text":"<pre><code>holdings_unset(\n    oclcNumber: Union[int, str],\n    cascadeDelete: bool = True,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Unsets institution's WorldCat holdings on an individual record.</p> <p>Uses /manage/institions/holdings/{oclcNumber}/unset endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number. Can be an integer or string with or without OCLC Number prefix.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>cascadeDelete</code> <p>Whether or not to remove any LBDs and/or LHRs associated with the bib record on which holdings are being removed. If <code>False</code>, associated local records will remain in WorldCat. If <code>True</code>, local records will be removed from WorldCat.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def holdings_unset(\n    self,\n    oclcNumber: Union[int, str],\n    cascadeDelete: bool = True,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Unsets institution's WorldCat holdings on an individual record.\n\n    Uses /manage/institions/holdings/{oclcNumber}/unset endpoint.\n\n    Args:\n        oclcNumber:\n            OCLC bibliographic record number. Can be an integer or string\n            with or without OCLC Number prefix.\n        cascadeDelete:\n            Whether or not to remove any LBDs and/or LHRs associated with\n            the bib record on which holdings are being removed. If `False`,\n            associated local records will remain in WorldCat. If `True`,\n            local records will be removed from WorldCat.\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_manage_ih_unset(oclcNumber)\n    header = {\"Accept\": \"application/json\"}\n\n    payload = {\"cascadeDelete\": cascadeDelete}\n\n    # prep request\n    req = Request(\"POST\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_unset_with_bib","title":"holdings_unset_with_bib","text":"<pre><code>holdings_unset_with_bib(\n    record: str,\n    recordFormat: str,\n    cascadeDelete: bool = True,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given a MARC record in MARCXML or MARC21, unset institution holdings on the record. MARC record must contain OCLC number in 001 or 035 subfield a. Only one MARC record is allowed in the request body.</p> <p>Uses /manage/institution/holdings/unset endpoint.</p> PARAMETER DESCRIPTION <code>record</code> <p>MARC record on which to unset holdings.</p> <p> TYPE: <code>str</code> </p> <code>recordFormat</code> <p>Format of MARC record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> </p> <code>cascadeDelete</code> <p>Whether or not to remove any LBDs and/or LHRs associated with the bib record on which holdings are being removed. If <code>False</code>, associated local records will remain in WorldCat. If <code>True</code>, local records will be removed from WorldCat.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def holdings_unset_with_bib(\n    self,\n    record: str,\n    recordFormat: str,\n    cascadeDelete: bool = True,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given a MARC record in MARCXML or MARC21, unset institution holdings on the\n    record. MARC record must contain OCLC number in 001 or 035 subfield a.\n    Only one MARC record is allowed in the request body.\n\n    Uses /manage/institution/holdings/unset endpoint.\n\n    Args:\n        record:\n            MARC record on which to unset holdings.\n        recordFormat:\n            Format of MARC record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        cascadeDelete:\n            Whether or not to remove any LBDs and/or LHRs associated with\n            the bib record on which holdings are being removed. If `False`,\n            associated local records will remain in WorldCat. If `True`,\n            local records will be removed from WorldCat.\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n\n    url = self._url_manage_ih_unset_with_bib()\n    header = {\n        \"Accept\": \"application/json\",\n        \"content-type\": recordFormat,\n    }\n\n    payload = {\"cascadeDelete\": cascadeDelete}\n\n    # prep request\n    req = Request(\n        \"POST\",\n        url,\n        data=record,\n        params=payload,\n        headers=header,\n        hooks=hooks,\n    )\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lbd_create","title":"lbd_create","text":"<pre><code>lbd_create(\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given a local bibliographic data record, create it in WorldCat.</p> <p>Uses /manage/lbds endpoint.</p> PARAMETER DESCRIPTION <code>record</code> <p>MARC record to be created.</p> <p> TYPE: <code>str</code> </p> <code>recordFormat</code> <p>Format of MARC record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> </p> <code>responseFormat</code> <p>Format of returned record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/marcxml+xml'</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def lbd_create(\n    self,\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given a local bibliographic data record, create it in WorldCat.\n\n    Uses /manage/lbds endpoint.\n\n    Args:\n        record:\n            MARC record to be created.\n        recordFormat:\n            Format of MARC record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        responseFormat:\n            Format of returned record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lbd_create()\n    header = {\n        \"Accept\": responseFormat,\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"POST\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lbd_delete","title":"lbd_delete","text":"<pre><code>lbd_delete(\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given a control number, delete the associated Local Bibliographic Data record.</p> <p>Uses /manage/lbds/{controlNumber} endpoint.</p> PARAMETER DESCRIPTION <code>controlNumber</code> <p>Control number associated with Local Bibliographic Data record. Can be an integer or string.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>responseFormat</code> <p>Format of returned record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/marcxml+xml'</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def lbd_delete(\n    self,\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given a control number, delete the associated Local Bibliographic Data record.\n\n    Uses /manage/lbds/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:\n            Control number associated with Local Bibliographic Data record.\n            Can be an integer or string.\n        responseFormat:\n            Format of returned record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lbd(controlNumber)\n    header = {\"Accept\": responseFormat}\n\n    # prep request\n    req = Request(\"DELETE\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lbd_get","title":"lbd_get","text":"<pre><code>lbd_get(\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given a Control Number, retrieve a Local Bibliographic Data record.</p> <p>Uses /manage/lbds/{controlNumber} endpoint.</p> PARAMETER DESCRIPTION <code>controlNumber</code> <p>Control number associated with Local Bibliographic Data record. Can be an integer or string.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>responseFormat</code> <p>Format of returned record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/marcxml+xml'</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def lbd_get(\n    self,\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given a Control Number, retrieve a Local Bibliographic Data record.\n\n    Uses /manage/lbds/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:\n            Control number associated with Local Bibliographic Data record.\n            Can be an integer or string.\n        responseFormat:\n            Format of returned record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lbd(controlNumber)\n    header = {\"Accept\": responseFormat}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lbd_replace","title":"lbd_replace","text":"<pre><code>lbd_replace(\n    controlNumber: Union[int, str],\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given a Control Number, find the associated Local Bibliographic Data Record and replace it. If the Control Number is not found in WorldCat, then the provided Local Bibliographic Data Record will be created.</p> <p>Uses /manage/lbds/{controlNumber} endpoint.</p> PARAMETER DESCRIPTION <code>controlNumber</code> <p>Control number associated with Local Bibliographic Data record. Can be an integer or string.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>record</code> <p>MARC record to replace existing Local Bibliographic Data record.</p> <p> TYPE: <code>str</code> </p> <code>recordFormat</code> <p>Format of MARC record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> </p> <code>responseFormat</code> <p>Format of returned record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/marcxml+xml'</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def lbd_replace(\n    self,\n    controlNumber: Union[int, str],\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given a Control Number, find the associated Local Bibliographic Data\n    Record and replace it. If the Control Number is not found in\n    WorldCat, then the provided Local Bibliographic Data Record will be created.\n\n    Uses /manage/lbds/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:\n            Control number associated with Local Bibliographic Data record.\n            Can be an integer or string.\n        record:\n            MARC record to replace existing Local Bibliographic Data record.\n        recordFormat:\n            Format of MARC record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        responseFormat:\n            Format of returned record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lbd(controlNumber)\n    header = {\n        \"Accept\": responseFormat,\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"PUT\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lhr_create","title":"lhr_create","text":"<pre><code>lhr_create(\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given a local holdings record, create it in WorldCat</p> <p>Uses /manage/lhrs endpoint.</p> PARAMETER DESCRIPTION <code>record</code> <p>MARC holdings record to be created.</p> <p> TYPE: <code>str</code> </p> <code>recordFormat</code> <p>Format of MARC record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> </p> <code>responseFormat</code> <p>Format of returned record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/marcxml+xml'</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def lhr_create(\n    self,\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given a local holdings record, create it in WorldCat\n\n    Uses /manage/lhrs endpoint.\n\n    Args:\n        record:\n            MARC holdings record to be created.\n        recordFormat:\n            Format of MARC record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        responseFormat:\n            Format of returned record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lhr_create()\n    header = {\n        \"Accept\": responseFormat,\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"POST\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lhr_delete","title":"lhr_delete","text":"<pre><code>lhr_delete(\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given a control number, delete a Local Holdings record.</p> <p>Uses /manage/lhrs/{controlNumber} endpoint.</p> PARAMETER DESCRIPTION <code>controlNumber</code> <p>Control number associated with Local Holdings record. Can be an integer or string.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>responseFormat</code> <p>Format of returned record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/marcxml+xml'</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def lhr_delete(\n    self,\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given a control number, delete a Local Holdings record.\n\n    Uses /manage/lhrs/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:\n            Control number associated with Local Holdings record.\n            Can be an integer or string.\n        responseFormat:\n            Format of returned record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lhr(controlNumber)\n    header = {\"Accept\": responseFormat}\n\n    # prep request\n    req = Request(\"DELETE\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lhr_get","title":"lhr_get","text":"<pre><code>lhr_get(\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Send a GET request for a local holdings record</p> <p>Uses /manage/lhrs/{controlNumber} endpoint.</p> PARAMETER DESCRIPTION <code>controlNumber</code> <p>Control number associated with Local Holdings record. Can be an integer or string.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>responseFormat</code> <p>Format of returned record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/marcxml+xml'</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def lhr_get(\n    self,\n    controlNumber: Union[int, str],\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Send a GET request for a local holdings record\n\n    Uses /manage/lhrs/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:\n            Control number associated with Local Holdings record.\n            Can be an integer or string.\n        responseFormat:\n            Format of returned record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lhr(controlNumber)\n    header = {\"Accept\": responseFormat}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.lhr_replace","title":"lhr_replace","text":"<pre><code>lhr_replace(\n    controlNumber: Union[int, str],\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given a Control Number, find the associated Local Holdings Record and replace it. If the Control Number is not found in WorldCat, then the provided Local Holdings Record will be created.</p> <p>Uses /manage/lhrs/{controlNumber} endpoint.</p> PARAMETER DESCRIPTION <code>controlNumber</code> <p>Control number associated with Local Holdings record. Can be an integer or string.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>record</code> <p>MARC holdings record to replace existing local holdings record.</p> <p> TYPE: <code>str</code> </p> <code>recordFormat</code> <p>Format of MARC record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> </p> <code>responseFormat</code> <p>Format of returned record.</p> <p>OPTIONS: <code>'application/marcxml+xml'</code> or <code>'application/marc'</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/marcxml+xml'</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def lhr_replace(\n    self,\n    controlNumber: Union[int, str],\n    record: str,\n    recordFormat: str,\n    responseFormat: str = \"application/marcxml+xml\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given a Control Number, find the associated Local Holdings\n    Record and replace it. If the Control Number is not found in\n    WorldCat, then the provided Local Holdings Record will be created.\n\n    Uses /manage/lhrs/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:\n            Control number associated with Local Holdings record.\n            Can be an integer or string.\n        record:\n            MARC holdings record to replace existing local holdings record.\n        recordFormat:\n            Format of MARC record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        responseFormat:\n            Format of returned record.\n\n            **OPTIONS:** `'application/marcxml+xml'` or `'application/marc'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_manage_lhr(controlNumber)\n    header = {\n        \"Accept\": responseFormat,\n        \"content-type\": recordFormat,\n    }\n\n    # prep request\n    req = Request(\"PUT\", url, data=record, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.local_bibs_get","title":"local_bibs_get","text":"<pre><code>local_bibs_get(\n    controlNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Retrieve LBD Resource.</p> <p>Uses /search/my-local-bib-data/{controlNumber} endpoint.</p> PARAMETER DESCRIPTION <code>controlNumber</code> <p>Control number associated with Local Bibliographic Data record. Can be an integer or string.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def local_bibs_get(\n    self,\n    controlNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Retrieve LBD Resource.\n\n    Uses /search/my-local-bib-data/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:\n            Control number associated with Local Bibliographic Data record.\n            Can be an integer or string.\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_search_lbd_control_number(controlNumber)\n    header = {\"Accept\": \"application/json\"}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.local_bibs_search","title":"local_bibs_search","text":"<pre><code>local_bibs_search(\n    q: str,\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Search LBD Resources using WorldCat query syntax. See OCLC Local Bibliographic Data Record Index Documentation for more information on available indexes.</p> <p>Uses /search/my-local-bib-data endpoint.</p> PARAMETER DESCRIPTION <code>q</code> <p>Query in the form of a keyword search or fielded search.</p> <p>EXAMPLES:</p> <ul> <li><code>ti:Zendegi</code></li> <li><code>ti:\"Czarne oceany\"</code></li> <li><code>bn:9781680502404</code></li> <li><code>kw:python databases</code></li> <li><code>ti:Zendegi AND au:greg egan</code></li> <li><code>(au:Okken OR au:Myers) AND su:python</code></li> </ul> <p> TYPE: <code>str</code> </p> <code>offset</code> <p>Start position of bibliographic records to return.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>limit</code> <p>Maximum number of records to return.</p> <p>MAXIMUM: <code>50</code></p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def local_bibs_search(\n    self,\n    q: str,\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Search LBD Resources using WorldCat query syntax. See OCLC\n    [Local Bibliographic Data Record Index](https://help.oclc.org/Librarian_Toolbox/Searching_WorldCat_Indexes/Local_bibliographic_data_records/Local_bibliographic_data_record_indexes_A-Z)\n    Documentation for more information on available indexes.\n\n    Uses /search/my-local-bib-data endpoint.\n\n    Args:\n        q:\n            Query in the form of a keyword search or fielded search.\n\n            **EXAMPLES:**\n\n            - `ti:Zendegi`\n            - `ti:\"Czarne oceany\"`\n            - `bn:9781680502404`\n            - `kw:python databases`\n            - `ti:Zendegi AND au:greg egan`\n            - `(au:Okken OR au:Myers) AND su:python`\n        offset:\n            Start position of bibliographic records to return.\n        limit:\n            Maximum number of records to return.\n\n            **MAXIMUM:** `50`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"  # noqa: E501\n    url = self._url_search_lbd()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\"q\": q, \"offset\": offset, \"limit\": limit}\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.local_holdings_browse","title":"local_holdings_browse","text":"<pre><code>local_holdings_browse(\n    holdingLocation: str,\n    shelvingLocation: str,\n    callNumber: str,\n    oclcNumber: Optional[Union[int, str]] = None,\n    browsePosition: int = 0,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Browse local holdings.</p> <p>Uses /browse/my-holdings endpoint.</p> PARAMETER DESCRIPTION <code>holdingLocation</code> <p>Holding location for item.</p> <p> TYPE: <code>str</code> </p> <code>shelvingLocation</code> <p>Shelving location for item.</p> <p> TYPE: <code>str</code> </p> <code>callNumber</code> <p>Call number for item.</p> <p> TYPE: <code>str</code> </p> <code>oclcNumber</code> <p>OCLC bibliographic record number. Can be an integer or string with or without OCLC Number prefix.</p> <p> TYPE: <code>Optional[Union[int, str]]</code> DEFAULT: <code>None</code> </p> <code>browsePosition</code> <p>Position within browse list where the matching record should be.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>limit</code> <p>Maximum number of records to return.</p> <p>MAXIMUM: <code>50</code></p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def local_holdings_browse(\n    self,\n    holdingLocation: str,\n    shelvingLocation: str,\n    callNumber: str,\n    oclcNumber: Optional[Union[int, str]] = None,\n    browsePosition: int = 0,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Browse local holdings.\n\n    Uses /browse/my-holdings endpoint.\n\n    Args:\n        holdingLocation:\n            Holding location for item.\n        shelvingLocation:\n            Shelving location for item.\n        callNumber:\n            Call number for item.\n        oclcNumber:\n            OCLC bibliographic record number. Can be an integer or string\n            with or without OCLC Number prefix.\n        browsePosition:\n            Position within browse list where the matching record should be.\n        limit:\n            Maximum number of records to return.\n\n            **MAXIMUM:** `50`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    if oclcNumber is not None:\n        oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_browse_lhr()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"callNumber\": callNumber,\n        \"oclcNumber\": oclcNumber,\n        \"holdingLocation\": holdingLocation,\n        \"shelvingLocation\": shelvingLocation,\n        \"browsePosition\": browsePosition,\n        \"limit\": limit,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.local_holdings_get","title":"local_holdings_get","text":"<pre><code>local_holdings_get(\n    controlNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Retrieve LHR Resource.</p> <p>Uses /search/my-holdings/{controlNumber} endpoint.</p> PARAMETER DESCRIPTION <code>controlNumber</code> <p>Control number associated with Local Holdings record. Can be an integer or string.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def local_holdings_get(\n    self,\n    controlNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Retrieve LHR Resource.\n\n    Uses /search/my-holdings/{controlNumber} endpoint.\n\n    Args:\n        controlNumber:\n            Control number associated with Local Holdings record.\n            Can be an integer or string.\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    url = self._url_search_lhr_control_number(controlNumber)\n    header = {\"Accept\": \"application/json\"}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.local_holdings_search","title":"local_holdings_search","text":"<pre><code>local_holdings_search(\n    oclcNumber: Optional[Union[int, str]] = None,\n    barcode: Optional[str] = None,\n    orderBy: str = \"oclcSymbol\",\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Search LHR Resources. Query must contain, at minimum, either an <code>oclcNumber</code> or <code>barcode</code>.</p> <p>Uses /search/my-holdings endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number. Can be an integer or string with or without OCLC Number prefix.</p> <p> TYPE: <code>Optional[Union[int, str]]</code> DEFAULT: <code>None</code> </p> <code>barcode</code> <p>Barcode as a string.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>orderBy</code> <p>Results sort key.</p> <p>OPTIONS: <code>'commitmentExpirationDate'</code>, <code>'location'</code>, <code>'oclcSymbol'</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'oclcSymbol'</code> </p> <code>offset</code> <p>Start position of bibliographic records to return.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>limit</code> <p>Maximum number of records to return.</p> <p>MAXIMUM: <code>50</code></p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def local_holdings_search(\n    self,\n    oclcNumber: Optional[Union[int, str]] = None,\n    barcode: Optional[str] = None,\n    orderBy: str = \"oclcSymbol\",\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Search LHR Resources. Query must contain, at minimum, either an\n    `oclcNumber` or `barcode`.\n\n    Uses /search/my-holdings endpoint.\n\n    Args:\n        oclcNumber:\n            OCLC bibliographic record number. Can be an integer or string\n            with or without OCLC Number prefix.\n        barcode:\n            Barcode as a string.\n        orderBy:\n            Results sort key.\n\n            **OPTIONS:** `'commitmentExpirationDate'`, `'location'`, `'oclcSymbol'`\n        offset:\n            Start position of bibliographic records to return.\n        limit:\n            Maximum number of records to return.\n\n            **MAXIMUM:** `50`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    if oclcNumber is not None:\n        oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_lhr()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"barcode\": barcode,\n        \"orderBy\": orderBy,\n        \"offset\": offset,\n        \"limit\": limit,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.local_holdings_search_shared_print","title":"local_holdings_search_shared_print","text":"<pre><code>local_holdings_search_shared_print(\n    oclcNumber: Optional[Union[int, str]] = None,\n    barcode: Optional[str] = None,\n    heldBySymbol: Optional[List[str]] = None,\n    heldByInstitutionID: Optional[List[int]] = None,\n    spProgram: Optional[List[str]] = None,\n    orderBy: str = \"oclcSymbol\",\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Search for shared print LHR Resources. Query must contain, at minimum, either an <code>oclcNumber</code> or <code>barcode</code> and a value for either <code>heldBySymbol</code>, <code>heldByInstitutionID</code> or <code>spProgram</code>.</p> <p>Uses /search/retained-holdings endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number. Can be an integer or string with or without OCLC Number prefix.</p> <p> TYPE: <code>Optional[Union[int, str]]</code> DEFAULT: <code>None</code> </p> <code>barcode</code> <p>Barcode as a string.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldBySymbol</code> <p>Restricts to holdings with specified institution symbol.</p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>heldByInstitutionID</code> <p>Restrict to specified institution registryId.</p> <p> TYPE: <code>Optional[List[int]]</code> DEFAULT: <code>None</code> </p> <code>spProgram</code> <p>Limits response to bibliographic records associated with particular shared print program.</p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>orderBy</code> <p>Results sort key.</p> <p>OPTIONS: <code>'commitmentExpirationDate'</code>, <code>'location'</code>, <code>'oclcSymbol'</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'oclcSymbol'</code> </p> <code>offset</code> <p>Start position of bibliographic records to return.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>limit</code> <p>Maximum number of records to return.</p> <p>MAXIMUM: <code>50</code></p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def local_holdings_search_shared_print(\n    self,\n    oclcNumber: Optional[Union[int, str]] = None,\n    barcode: Optional[str] = None,\n    heldBySymbol: Optional[List[str]] = None,\n    heldByInstitutionID: Optional[List[int]] = None,\n    spProgram: Optional[List[str]] = None,\n    orderBy: str = \"oclcSymbol\",\n    offset: int = 1,\n    limit: int = 10,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Search for shared print LHR Resources. Query must contain, at minimum,\n    either an `oclcNumber` or `barcode` and a value for either\n    `heldBySymbol`, `heldByInstitutionID` or `spProgram`.\n\n    Uses /search/retained-holdings endpoint.\n\n    Args:\n        oclcNumber:\n            OCLC bibliographic record number. Can be an integer or string\n            with or without OCLC Number prefix.\n        barcode:\n            Barcode as a string.\n        heldBySymbol:\n            Restricts to holdings with specified institution symbol.\n        heldByInstitutionID:\n            Restrict to specified institution registryId.\n        spProgram:\n            Limits response to bibliographic records associated with\n            particular shared print program.\n        orderBy:\n            Results sort key.\n\n            **OPTIONS:** `'commitmentExpirationDate'`, `'location'`, `'oclcSymbol'`\n        offset:\n            Start position of bibliographic records to return.\n        limit:\n            Maximum number of records to return.\n\n            **MAXIMUM:** `50`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    if oclcNumber is not None:\n        oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_lhr_shared_print()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"barcode\": barcode,\n        \"heldBySymbol\": heldBySymbol,\n        \"heldByInstitutionID\": heldByInstitutionID,\n        \"spProgram\": spProgram,\n        \"orderBy\": orderBy,\n        \"offset\": offset,\n        \"limit\": limit,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.shared_print_holdings_search","title":"shared_print_holdings_search","text":"<pre><code>shared_print_holdings_search(\n    oclcNumber: Optional[Union[int, str]] = None,\n    isbn: Optional[str] = None,\n    issn: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldInState: Optional[str] = None,\n    itemType: Optional[List[str]] = None,\n    itemSubType: Optional[List[str]] = None,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Finds member shared print holdings for specified item. Query must contain, at minimum, either an <code>oclcNumber</code>, <code>isbn</code>, or <code>issn</code>.</p> <p>Uses /search/bibs-retained-holdings endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number. Can be an integer or string with or without OCLC Number prefix.</p> <p> TYPE: <code>Optional[Union[int, str]]</code> DEFAULT: <code>None</code> </p> <code>isbn</code> <p>ISBN without any dashes.</p> <p>EXAMPLE: <code>'978149191646x'</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>issn</code> <p>ISSN, hyphenated.</p> <p>EXAMPLE: <code>'0099-1234'</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldByGroup</code> <p>Restricts to holdings held by group symbol.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldInState</code> <p>Restricts to holdings held by institutions in requested state.</p> <p>EXAMPLE: <code>'US-NY'</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>itemType</code> <p>Limits response to specified item type.</p> <p>EXAMPLES: <code>'book'</code>, <code>'vis'</code></p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>itemSubType</code> <p>Limits response to specified item sub type</p> <p>EXAMPLES: <code>'book-digital'</code>, <code>'audiobook-cd'</code></p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def shared_print_holdings_search(\n    self,\n    oclcNumber: Optional[Union[int, str]] = None,\n    isbn: Optional[str] = None,\n    issn: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldInState: Optional[str] = None,\n    itemType: Optional[List[str]] = None,\n    itemSubType: Optional[List[str]] = None,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Finds member shared print holdings for specified item. Query must\n    contain, at minimum, either an `oclcNumber`, `isbn`, or `issn`.\n\n    Uses /search/bibs-retained-holdings endpoint.\n\n    Args:\n        oclcNumber:\n            OCLC bibliographic record number. Can be an integer or string\n            with or without OCLC Number prefix.\n        isbn:\n            ISBN without any dashes.\n\n            **EXAMPLE:** `'978149191646x'`\n        issn:\n            ISSN, hyphenated.\n\n            **EXAMPLE:** `'0099-1234'`\n        heldByGroup:\n            Restricts to holdings held by group symbol.\n        heldInState:\n            Restricts to holdings held by institutions in requested state.\n\n            **EXAMPLE:** `'US-NY'`\n        itemType:\n            Limits response to specified item type.\n\n            **EXAMPLES:** `'book'`, `'vis'`\n        itemSubType:\n            Limits response to specified item sub type\n\n            **EXAMPLES:** `'book-digital'`, `'audiobook-cd'`\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    if oclcNumber is not None:\n        oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_shared_print_holdings()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"isbn\": isbn,\n        \"issn\": issn,\n        \"heldByGroup\": heldByGroup,\n        \"heldInState\": heldInState,\n        \"itemType\": itemType,\n        \"itemSubType\": itemSubType,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.summary_holdings_get","title":"summary_holdings_get","text":"<pre><code>summary_holdings_get(\n    oclcNumber: Union[int, str],\n    holdingsAllEditions: Optional[bool] = None,\n    holdingsAllVariantRecords: Optional[bool] = None,\n    holdingsFilterFormat: Optional[List[str]] = None,\n    heldInCountry: Optional[str] = None,\n    heldInState: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[List[str]] = None,\n    heldByInstitutionID: Optional[List[int]] = None,\n    heldByLibraryType: Optional[List[str]] = None,\n    lat: Optional[float] = None,\n    lon: Optional[float] = None,\n    distance: Optional[int] = None,\n    unit: str = \"M\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given an OCLC number, get summary of holdings. Query may contain only one of: <code>heldByInstitutionId</code>, <code>heldByGroup</code>, <code>heldBySymbol</code>, <code>heldInCountry</code>, <code>heldInState</code> or combination of <code>lat</code>, <code>lon</code> and <code>distance</code>. If using lat/lon arguments, query must contain a valid distance argument.</p> <p>Uses /search/summary-holdings endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number. Can be an integer or string with or without OCLC Number prefix.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>holdingsAllEditions</code> <p>Get holdings for all editions.</p> <p>OPTIONS: <code>True</code> or <code>False</code></p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>holdingsAllVariantRecords</code> <p>Get holdings for specific edition across variant records.</p> <p>OPTIONS: <code>True</code> or <code>False</code></p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>holdingsFilterFormat</code> <p>Get holdings for specific itemSubType.</p> <p>EXAMPLE: <code>'book-digital'</code></p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>heldInCountry</code> <p>Restricts to holdings held by institutions in requested country.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldInState</code> <p>Restricts to holdings held by institutions in requested state.</p> <p>EXAMPLE: <code>'US-NY'</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldByGroup</code> <p>Restricts to holdings held by group symbol.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldBySymbol</code> <p>Limits to holdings held by institutions indicated by institution symbol.</p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>heldByInstitutionID</code> <p>Limits to holdings held by institutions indicated by institution registryID.</p> <p> TYPE: <code>Optional[List[int]]</code> DEFAULT: <code>None</code> </p> <code>heldByLibraryType</code> <p>Limits to holdings held by library type.</p> <p>OPTIONS: <code>'PUBLIC'</code>, <code>'ALL'</code></p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>lat</code> <p>Latitude</p> <p>EXAMPLE: <code>37.502508</code></p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>lon</code> <p>Longitude</p> <p>EXAMPLE: <code>-122.22702</code></p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>distance</code> <p>Limits results to holdings held by institutions within specified distance from latitude and longitude.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>unit</code> <p>Unit of distance from latitude and longitude.</p> <p>OPTIONS: <code>'M'</code> (miles) or <code>'K'</code> (kilometers).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'M'</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def summary_holdings_get(\n    self,\n    oclcNumber: Union[int, str],\n    holdingsAllEditions: Optional[bool] = None,\n    holdingsAllVariantRecords: Optional[bool] = None,\n    holdingsFilterFormat: Optional[List[str]] = None,\n    heldInCountry: Optional[str] = None,\n    heldInState: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[List[str]] = None,\n    heldByInstitutionID: Optional[List[int]] = None,\n    heldByLibraryType: Optional[List[str]] = None,\n    lat: Optional[float] = None,\n    lon: Optional[float] = None,\n    distance: Optional[int] = None,\n    unit: str = \"M\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given an OCLC number, get summary of holdings. Query may contain\n    only one of: `heldByInstitutionId`, `heldByGroup`, `heldBySymbol`,\n    `heldInCountry`, `heldInState` or combination of `lat`, `lon` and\n    `distance`. If using lat/lon arguments, query must contain a valid\n    distance argument.\n\n    Uses /search/summary-holdings endpoint.\n\n    Args:\n        oclcNumber:\n            OCLC bibliographic record number. Can be an integer or string\n            with or without OCLC Number prefix.\n        holdingsAllEditions:\n            Get holdings for all editions.\n\n            **OPTIONS:** `True` or `False`\n        holdingsAllVariantRecords:\n            Get holdings for specific edition across variant records.\n\n            **OPTIONS:** `True` or `False`\n        holdingsFilterFormat:\n            Get holdings for specific itemSubType.\n\n            **EXAMPLE:** `'book-digital'`\n        heldInCountry:\n            Restricts to holdings held by institutions in requested country.\n        heldInState:\n            Restricts to holdings held by institutions in requested state.\n\n            **EXAMPLE:** `'US-NY'`\n        heldByGroup:\n            Restricts to holdings held by group symbol.\n        heldBySymbol:\n            Limits to holdings held by institutions indicated by\n            institution symbol.\n        heldByInstitutionID:\n            Limits to holdings held by institutions indicated by institution\n            registryID.\n        heldByLibraryType:\n            Limits to holdings held by library type.\n\n            **OPTIONS:** `'PUBLIC'`, `'ALL'`\n        lat:\n            Latitude\n\n            **EXAMPLE:** `37.502508`\n        lon:\n            Longitude\n\n            **EXAMPLE:** `-122.22702`\n        distance:\n            Limits results to holdings held by institutions within specified\n            distance from latitude and longitude.\n        unit:\n            Unit of distance from latitude and longitude.\n\n            **OPTIONS:** `'M'` (miles) or `'K'` (kilometers).\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_general_holdings_summary()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"holdingsAllEditions\": holdingsAllEditions,\n        \"holdingsAllVariantRecords\": holdingsAllVariantRecords,\n        \"holdingsFilterFormat\": holdingsFilterFormat,\n        \"heldInCountry\": heldInCountry,\n        \"heldInState\": heldInState,\n        \"heldByGroup\": heldByGroup,\n        \"heldBySymbol\": heldBySymbol,\n        \"heldByInstitutionID\": heldByInstitutionID,\n        \"heldByLibraryType\": heldByLibraryType,\n        \"lat\": lat,\n        \"lon\": lon,\n        \"distance\": distance,\n        \"unit\": unit,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.summary_holdings_search","title":"summary_holdings_search","text":"<pre><code>summary_holdings_search(\n    oclcNumber: Optional[Union[int, str]] = None,\n    isbn: Optional[str] = None,\n    issn: Optional[str] = None,\n    holdingsAllEditions: Optional[bool] = None,\n    holdingsAllVariantRecords: Optional[bool] = None,\n    preferredLanguage: str = \"eng\",\n    holdingsFilterFormat: Optional[List[str]] = None,\n    heldInCountry: Optional[str] = None,\n    heldInState: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[List[str]] = None,\n    heldByInstitutionID: Optional[List[int]] = None,\n    heldByLibraryType: Optional[List[str]] = None,\n    lat: Optional[float] = None,\n    lon: Optional[float] = None,\n    distance: Optional[int] = None,\n    unit: str = \"M\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given a known item, get summary of holdings and brief bib record. Query must contain, at minimum, either an OCLC Number, ISBN, or ISSN. Query may contain only one of: <code>heldByInstitutionId</code>, <code>heldByGroup</code>, <code>heldBySymbol</code>, <code>heldInCountry</code>, <code>heldInState</code> or combination of <code>lat</code>, <code>lon</code> and <code>distance</code>. If using lat/lon arguments, query must contain a valid distance argument.</p> <p>Uses /search/bibs-summary-holdings endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number. Can be an integer or string with or without OCLC Number prefix.</p> <p> TYPE: <code>Optional[Union[int, str]]</code> DEFAULT: <code>None</code> </p> <code>isbn</code> <p>ISBN without any dashes.</p> <p>EXAMPLE: <code>'978149191646x'</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>issn</code> <p>ISSN, hyphenated.</p> <p>EXAMPLE: <code>'0099-1234'</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>holdingsAllEditions</code> <p>Get holdings for all editions.</p> <p>OPTIONS: <code>True</code> or <code>False</code></p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>holdingsAllVariantRecords</code> <p>Get holdings for specific edition across variant records.</p> <p>OPTIONS: <code>True</code> or <code>False</code></p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>preferredLanguage</code> <p>Language user would prefer metadata description in. Does not limit responses. To limit responses use <code>inCataloglanguage</code> facet.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'eng'</code> </p> <code>holdingsFilterFormat</code> <p>Get holdings for specific itemSubType.</p> <p>EXAMPLE: <code>'book-digital'</code></p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>heldInCountry</code> <p>Restricts to holdings held by institutions in requested country.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldInState</code> <p>Restricts to holdings held by institutions in requested state.</p> <p>EXAMPLE: <code>'US-NY'</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldByGroup</code> <p>Restricts to holdings held by group symbol.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldBySymbol</code> <p>Limits to holdings held by institutions indicated by institution symbol.</p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>heldByInstitutionID</code> <p>Limits to holdings held by institutions indicated by institution registryID.</p> <p> TYPE: <code>Optional[List[int]]</code> DEFAULT: <code>None</code> </p> <code>heldByLibraryType</code> <p>Limits to holdings held by library type.</p> <p>OPTIONS: <code>'PUBLIC'</code>, <code>'ALL'</code></p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>lat</code> <p>Latitude</p> <p>EXAMPLE: <code>37.502508</code></p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>lon</code> <p>Longitude</p> <p>EXAMPLE: <code>-122.22702</code></p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>distance</code> <p>Limits results to holdings held by institutions within specified distance from latitude and longitude.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>unit</code> <p>Unit of distance from latitude and longitude.</p> <p>OPTIONS: <code>'M'</code> (miles) or <code>'K'</code> (kilometers).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'M'</code> </p> <code>hooks</code> <p>Requests library hook system that can be used for signal event handling. For more information see the Requests docs</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def summary_holdings_search(\n    self,\n    oclcNumber: Optional[Union[int, str]] = None,\n    isbn: Optional[str] = None,\n    issn: Optional[str] = None,\n    holdingsAllEditions: Optional[bool] = None,\n    holdingsAllVariantRecords: Optional[bool] = None,\n    preferredLanguage: str = \"eng\",\n    holdingsFilterFormat: Optional[List[str]] = None,\n    heldInCountry: Optional[str] = None,\n    heldInState: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[List[str]] = None,\n    heldByInstitutionID: Optional[List[int]] = None,\n    heldByLibraryType: Optional[List[str]] = None,\n    lat: Optional[float] = None,\n    lon: Optional[float] = None,\n    distance: Optional[int] = None,\n    unit: str = \"M\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given a known item, get summary of holdings and brief bib record. Query must\n    contain, at minimum, either an OCLC Number, ISBN, or ISSN. Query may contain\n    only one of: `heldByInstitutionId`, `heldByGroup`, `heldBySymbol`,\n    `heldInCountry`, `heldInState` or combination of `lat`, `lon` and\n    `distance`. If using lat/lon arguments, query must contain a valid\n    distance argument.\n\n    Uses /search/bibs-summary-holdings endpoint.\n\n    Args:\n        oclcNumber:\n            OCLC bibliographic record number. Can be an integer or string\n            with or without OCLC Number prefix.\n        isbn:\n            ISBN without any dashes.\n\n            **EXAMPLE:** `'978149191646x'`\n        issn:\n            ISSN, hyphenated.\n\n            **EXAMPLE:** `'0099-1234'`\n        holdingsAllEditions:\n            Get holdings for all editions.\n\n            **OPTIONS:** `True` or `False`\n        holdingsAllVariantRecords:\n            Get holdings for specific edition across variant records.\n\n            **OPTIONS:** `True` or `False`\n        preferredLanguage:\n            Language user would prefer metadata description in. Does not limit\n            responses. To limit responses use `inCataloglanguage` facet.\n        holdingsFilterFormat:\n            Get holdings for specific itemSubType.\n\n            **EXAMPLE:** `'book-digital'`\n        heldInCountry:\n            Restricts to holdings held by institutions in requested country.\n        heldInState:\n            Restricts to holdings held by institutions in requested state.\n\n            **EXAMPLE:** `'US-NY'`\n        heldByGroup:\n            Restricts to holdings held by group symbol.\n        heldBySymbol:\n            Limits to holdings held by institutions indicated by\n            institution symbol.\n        heldByInstitutionID:\n            Limits to holdings held by institutions indicated by institution\n            registryID.\n        heldByLibraryType:\n            Limits to holdings held by library type.\n\n            **OPTIONS:** `'PUBLIC'`, `'ALL'`\n        lat:\n            Latitude\n\n            **EXAMPLE:** `37.502508`\n        lon:\n            Longitude\n\n            **EXAMPLE:** `-122.22702`\n        distance:\n            Limits results to holdings held by institutions within specified\n            distance from latitude and longitude.\n        unit:\n            Unit of distance from latitude and longitude.\n\n            **OPTIONS:** `'M'` (miles) or `'K'` (kilometers).\n        hooks:\n            Requests library hook system that can be used for signal event\n            handling. For more information see the [Requests docs](https://requests.\n            readthedocs.io/en/master/user/advanced/#event-hooks)\n\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n    if oclcNumber is not None:\n        oclcNumber = verify_oclc_number(oclcNumber)\n\n    url = self._url_search_general_holdings()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"isbn\": isbn,\n        \"issn\": issn,\n        \"holdingsAllEditions\": holdingsAllEditions,\n        \"holdingsAllVariantRecords\": holdingsAllVariantRecords,\n        \"preferredLanguage\": preferredLanguage,\n        \"holdingsFilterFormat\": holdingsFilterFormat,\n        \"heldInCountry\": heldInCountry,\n        \"heldInState\": heldInState,\n        \"heldByGroup\": heldByGroup,\n        \"heldBySymbol\": heldBySymbol,\n        \"heldByInstitutionID\": heldByInstitutionID,\n        \"heldByLibraryType\": heldByLibraryType,\n        \"lat\": lat,\n        \"lon\": lon,\n        \"distance\": distance,\n        \"unit\": unit,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/query/","title":"bookops_worldcat.query","text":"<p>Handles requests to OCLC web services.</p>"},{"location":"api/query/#bookops_worldcat.query.Query","title":"Query","text":"<pre><code>Query(\n    session: MetadataSession,\n    prepared_request: PreparedRequest,\n    timeout: Union[\n        int,\n        float,\n        Tuple[int, int],\n        Tuple[float, float],\n        None,\n    ] = (5, 5),\n)\n</code></pre> <p>Sends a request to OCLC web service and unifies exceptions.</p> <p>Query object handles automatic refresh of expired token before each request is made to the web service. <code>Query.response</code> attribute is <code>requests.Response</code> instance that can be parsed to extract information received from the web service.</p> PARAMETER DESCRIPTION <code>session</code> <p><code>metadata_api.MetadataSession</code> instance.</p> <p> TYPE: <code>MetadataSession</code> </p> <code>prepared_request</code> <p><code>requests.PreparedRequest</code> instance.</p> <p> TYPE: <code>PreparedRequest</code> </p> <code>timeout</code> <p>How long to wait for server to send data before giving up. Accepts separate values for connect and read timeouts or a single value.</p> <p> TYPE: <code>Union[int, float, Tuple[int, int], Tuple[float, float], None]</code> DEFAULT: <code>(5, 5)</code> </p> RAISES DESCRIPTION <code>WorldcatRequestError</code> <p>If the request encounters any errors.</p> <code>TypeError</code> <p>If <code>prepared_request</code> arg is passed anything other than a <code>requests.PreparedRequest</code> object.</p> Source code in <code>bookops_worldcat\\query.py</code> <pre><code>def __init__(\n    self,\n    session: MetadataSession,\n    prepared_request: PreparedRequest,\n    timeout: Union[int, float, Tuple[int, int], Tuple[float, float], None] = (\n        5,\n        5,\n    ),\n) -&gt; None:\n    \"\"\"Initializes Query object.\n\n    Args:\n        session:\n            `metadata_api.MetadataSession` instance.\n        prepared_request:\n            `requests.PreparedRequest` instance.\n        timeout:\n            How long to wait for server to send data before giving up. Accepts\n            separate values for connect and read timeouts or a single value.\n\n    Raises:\n        WorldcatRequestError:\n            If the request encounters any errors.\n        TypeError:\n            If `prepared_request` arg is passed anything other than a\n            `requests.PreparedRequest` object.\n    \"\"\"\n    if not isinstance(prepared_request, PreparedRequest):\n        raise TypeError(\"Invalid type for argument 'prepared_request'.\")\n\n    # make sure access token is still valid and if not request a new one\n    if session.authorization.is_expired():\n        session._get_new_access_token()\n\n    try:\n        self.response = session.send(prepared_request, timeout=timeout)\n        self.response.raise_for_status()\n\n    except HTTPError as exc:\n        raise WorldcatRequestError(\n            f\"{exc}. Server response: \"  # type: ignore\n            f\"{self.response.content.decode('utf-8')}\"\n        )\n    except (Timeout, ConnectionError, RetryError):\n        raise WorldcatRequestError(f\"Connection Error: {sys.exc_info()[0]}\")\n\n    except Exception:\n        raise WorldcatRequestError(f\"Unexpected request error: {sys.exc_info()[0]}\")\n</code></pre>"},{"location":"api/utils/","title":"bookops_worldcat.utils","text":"<p>Shared utilities module.</p>"},{"location":"api/utils/#bookops_worldcat.utils.prep_oclc_number_str","title":"prep_oclc_number_str","text":"<pre><code>prep_oclc_number_str(oclcNumber: str) -&gt; str\n</code></pre> <p>Checks for OCLC prefixes and removes them.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC record number as string</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p><code>oclcNumber</code> as str</p> RAISES DESCRIPTION <code>InvalidOclcNumber</code> <p>If <code>oclcNumber</code> argument does not match</p> Source code in <code>bookops_worldcat\\utils.py</code> <pre><code>def prep_oclc_number_str(oclcNumber: str) -&gt; str:\n    \"\"\"\n    Checks for OCLC prefixes and removes them.\n\n    Args:\n        oclcNumber:\n            OCLC record number as string\n\n    Returns:\n        `oclcNumber` as str\n\n    Raises:\n        InvalidOclcNumber: If `oclcNumber` argument does not match\n        OCLC number formatting rules.\n    \"\"\"\n\n    if re.match(r\"^ocm[0-9]{,8}$\", oclcNumber.strip()) or re.match(\n        r\"^ocn[0-9]{9}$\", oclcNumber.strip()\n    ):\n        oclcNumber = oclcNumber.strip()[3:]\n    elif re.match(r\"^on[0-9]{10,}$\", oclcNumber.strip()):\n        oclcNumber = oclcNumber.strip()[2:]\n    elif re.match(r\"^\\(OCoLC\\)[0-9]{8,}$\", oclcNumber.strip()):\n        oclcNumber = oclcNumber.strip()[7:]\n\n    try:\n        oclcNumber = str(int(oclcNumber))\n        return oclcNumber\n    except ValueError:\n        raise InvalidOclcNumber(\"Argument 'oclcNumber' does not look like real OCLC #.\")\n</code></pre>"},{"location":"api/utils/#bookops_worldcat.utils.verify_oclc_number","title":"verify_oclc_number","text":"<pre><code>verify_oclc_number(oclcNumber: Union[int, str]) -&gt; str\n</code></pre> <p>Verifies a valid looking OCLC number is passed and normalize it as integer.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC record number as string or integer</p> <p> TYPE: <code>Union[int, str]</code> </p> RETURNS DESCRIPTION <code>str</code> <p><code>oclcNumber</code> as str</p> RAISES DESCRIPTION <code>InvalidOclcNumber</code> <p>If <code>oclcNumber</code> argument is not a str or int or is missing.</p> Source code in <code>bookops_worldcat\\utils.py</code> <pre><code>def verify_oclc_number(oclcNumber: Union[int, str]) -&gt; str:\n    \"\"\"\n    Verifies a valid looking OCLC number is passed and normalize it as integer.\n\n    Args:\n        oclcNumber:\n            OCLC record number as string or integer\n\n    Returns:\n        `oclcNumber` as str\n\n    Raises:\n        InvalidOclcNumber: If `oclcNumber` argument is not a str or int or is missing.\n    \"\"\"\n    if not oclcNumber:\n        raise InvalidOclcNumber(\"Argument 'oclcNumber' is missing.\")\n\n    elif isinstance(oclcNumber, int):\n        return str(oclcNumber)\n\n    elif isinstance(oclcNumber, str):\n        return prep_oclc_number_str(oclcNumber)\n\n    else:\n        raise InvalidOclcNumber(\"Argument 'oclcNumber' is of invalid type.\")\n</code></pre>"},{"location":"api/utils/#bookops_worldcat.utils.verify_oclc_numbers","title":"verify_oclc_numbers","text":"<pre><code>verify_oclc_numbers(\n    oclcNumbers: Union[int, str, List[Union[str, int]]]\n) -&gt; List[str]\n</code></pre> <p>Parses and verifies list of oclcNumbers</p> PARAMETER DESCRIPTION <code>oclcNumbers</code> <p>List of OCLC control numbers. Control numbers can be integers or strings with or without OCLC # prefix. If str, the numbers must be separated by commas. If int, only one number will be parsed. Lists may contain strings or integers or a combination of both.</p> <p> TYPE: <code>Union[int, str, List[Union[str, int]]]</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p><code>oclcNumbers</code> as a list of strings</p> RAISES DESCRIPTION <code>InvalidOclcNumber</code> <p>If <code>oclcNumbers</code> argument is not a list, str, or int.</p> Source code in <code>bookops_worldcat\\utils.py</code> <pre><code>def verify_oclc_numbers(\n    oclcNumbers: Union[int, str, List[Union[str, int]]]\n) -&gt; List[str]:\n    \"\"\"\n    Parses and verifies list of oclcNumbers\n\n    Args:\n        oclcNumbers:\n            List of OCLC control numbers. Control numbers can be integers or strings\n            with or without OCLC # prefix. If str, the numbers must be separated\n            by commas. If int, only one number will be parsed. Lists may contain strings\n            or integers or a combination of both.\n\n    Returns:\n        `oclcNumbers` as a list of strings\n\n    Raises:\n        InvalidOclcNumber: If `oclcNumbers` argument is not a list, str, or int.\n    \"\"\"\n    if isinstance(oclcNumbers, str):\n        oclcNumbers_lst = _str2list(oclcNumbers)\n    elif isinstance(oclcNumbers, int):\n        oclcNumbers_lst = _str2list(str(oclcNumbers))\n    elif isinstance(oclcNumbers, list):\n        oclcNumbers_lst = [str(n) for n in oclcNumbers]\n    else:\n        raise InvalidOclcNumber(\n            \"Argument 'oclcNumbers' must be a single integer, a list or a \"\n            \"comma separated string of valid OCLC #s.\"\n        )\n    if not oclcNumbers_lst:\n        raise InvalidOclcNumber(\n            \"Argument 'oclcNumbers' must be a single integer, a list or a \"\n            \"comma separated string of valid OCLC #s.\"\n        )\n\n    vetted_numbers = [verify_oclc_number(n) for n in oclcNumbers_lst]\n    return vetted_numbers\n</code></pre>"}]}