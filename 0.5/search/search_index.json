{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BookOps-Worldcat","text":""},{"location":"#overview","title":"Overview","text":"<p>Requires Python 3.7 and up.</p> <p>Bookops-Worldcat is a Python wrapper around OCLC's Worldcat Metadata API which supports changes released in the version 1.1 (May 2020) of the web service. The package features methods that utilize search functionality of the API as well as read-write endpoints.</p> <p>The Bookops-Worldcat package simplifies some of the OCLC API boilerplate, and ideally lowers the technological threshold for cataloging departments that may not have sufficient programming support to access and utilize those web services. Python language, with its gentle learning curve, has the potential to be a perfect vehicle towards this goal.</p> <p>This package takes advantage of the functionality of the popular Requests library. Interaction with OCLC's services is built around Requests sessions. <code>MetadataSession</code> inherits all <code>requests.Session</code> properties. Returned server responses are <code>requests.Response</code> objects with all of their properties and methods.</p> <p>Authorizing a session simply requires passing an access token into <code>MetadataSession</code>. Opening a session allows the user to call specific methods which facilitate communication between the user's script/client and a particular endpoint of OCLC's service. Many of the hurdles related to making valid requests are hidden under the hood of this package, making it as simple as possible to access the functionalities of OCLC APIs. Please note, not all features of the Metadata API are implemented because this tool was primarily built for our organization's specific needs. However, we are open to any collaboration to expand and improve the package.</p> <p>Supported OCLC web services:</p> <p>At the moment, the wrapper supports only OAuth 2.0 endpoints and flows. The specific protocols are Client Credential Grant and Access Token for authorization.</p> <p>Worldcat Metadata API is a read-write service for WorldCat. It allows adding and updating records in WorldCat, maintaining holdings, and working with local bibliographic data. Access to Metadata API requires OCLC credentials. The BookOps wrapper focuses on the following API operations:</p> <ul> <li>Search functionality<ul> <li>Find member shared print holdings (<code>/bibs-retained-holdings</code>)</li> <li>Get summary of holdings for known items (<code>/bibs-summary-holdings</code>)</li> <li>Brief bibliographic resources:<ul> <li>Search brief bibliographic resources (<code>/brief-bibs</code>)</li> <li>Retrieve specific brief bibliographic resource (<code>/brief-bibs/{oclcNumber}</code>)</li> <li>Retrieve other editions related to a particular bibliographic resource (<code>/brief-bibs/{oclcNumber}/other-editions</code>)</li> </ul> </li> </ul> </li> <li>Full bibliographic resources<ul> <li>Retrieve full bibliographic record (<code>/bib-data</code>)</li> <li>Get current OCLC number (<code>/bib/checkcontrolnumber</code>)</li> </ul> </li> <li>Holdings<ul> <li>Set and unset institution holding  (<code>/ih/data</code>)</li> <li>Retrieve status of institution holdings (<code>/ih/checkholdings</code>)</li> <li>Set and unset institution holdings for a batch or records (<code>/ih/datalist</code>)</li> <li>Set and unset holdings for a single record for multiple intitutions (<code>/ih/institutionlist</code>)</li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install use pip:</p> <p><code>$ pip -m install bookops-worldcat</code></p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Worldcat Metadata API requires OCLC credentials which can be obtained at the OCLC Developer Network site.</p>"},{"location":"#obtaining-access-token","title":"Obtaining Access Token","text":"<p>The Worldcat access token can be obtained by passing credential parameters into the <code>WorldcatAccessToken</code> object.</p> <pre><code>&gt;&gt;&gt; from bookops_worldcat import WorldcatAccessToken\n&gt;&gt;&gt; token = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=[\"WorldCatMetadataAPI\"],\n    principal_id=\"my_principal_id\",\n    principlal_idns=\"my_principal_idns\"\n)\n&gt;&gt;&gt; print(token)\n\"access_token: 'tk_Yebz4BpEp9dAsghA7KpWx6dYD1OZKWBlHjqW', expires_at: '2020-01-01 17:19:58Z'\"\n&gt;&gt;&gt; print(token.is_expired())\nFalse\n</code></pre> <p>Created <code>token</code> object can be directly passed into <code>MetadataSession</code> to authorize requests to the Metadata API web service:</p> <pre><code>&gt;&gt;&gt; from bookops_worldcat import MetadataSession\n&gt;&gt;&gt; session = MetadataSession(authorization=token)\n</code></pre>"},{"location":"#searching-brief-bibliographic-records-using-metadata-api","title":"Searching Brief Bibliographic Records Using Metadata API","text":"<p>The <code>MetadataSession</code> is authenticated using the <code>WorldcatAccessToken</code> object. The session allows searching brief records as well as retrieving full bibs in the MARC XML format.</p> <p>Basic usage: <pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    results = session.search_brief_bibs(q=\"ti:zendegi AND au:greg egan\")\n    print(results.json())\n</code></pre></p> <p>Returned brief bibliographic records are in the JSON format that can be parsed via <code>.json()</code> method.</p> <pre><code>{\n    \"numberOfRecords\": 24,\n    \"briefRecords\": [\n        {\n            \"oclcNumber\": \"430840771\",\n            \"title\": \"Zendegi\",\n            \"creator\": \"Greg Egan\",\n            \"date\": \"2010\",\n            \"language\": \"eng\",\n            \"generalFormat\": \"Book\",\n            \"specificFormat\": \"PrintBook\",\n            \"edition\": \"First edition.\",\n            \"publisher\": \"Night Shade Books\",\n            \"mergedOclcNumbers\": [\n                \"664026825\"\n            ],\n            \"catalogingInfo\": {\n                \"catalogingAgency\": \"BTCTA\",\n                \"transcribingAgency\": \"DLC\"\n            }\n        },\n        {\n            \"oclcNumber\": \"961162511\",\n            \"title\": \"Zendegi\",\n            \"creator\": \"Greg Egan\",\n            \"date\": \"2013\",\n            \"language\": \"eng\",\n            \"generalFormat\": \"AudioBook\",\n            \"specificFormat\": \"CD\",\n            \"publisher\": \"Audible Studios on Brilliance Audio\",\n            \"mergedOclcNumbers\": [\n                \"947806980\"\n            ],\n            \"catalogingInfo\": {\n                \"catalogingAgency\": \"AU@\",\n                \"transcribingAgency\": \"AU@\"\n            }\n        },\n    ]\n}\n</code></pre>"},{"location":"#retrieving-full-bibliographic-records","title":"Retrieving Full Bibliographic Records","text":"<p>To retrieve a full bibliographic record from WorldCat use the <code>.get_full_bib</code> method. The server returns records in MARC XML format by default.</p> <p><pre><code>from bookops_worldcat import MetadataSession\n\nwith MetadataSession(authorization=token) as session:\n    results = session.get_full_bib(oclcNumber=430840771)\n    print(results.text)\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;entry xmlns=\"http://www.w3.org/2005/Atom\"&gt;\n  &lt;content type=\"application/xml\"&gt;\n    &lt;response xmlns=\"http://worldcat.org/rb\" mimeType=\"application/vnd.oclc.marc21+xml\"&gt;\n      &lt;record xmlns=\"http://www.loc.gov/MARC21/slim\"&gt;\n        &lt;leader&gt;00000cam a2200000 i 4500&lt;/leader&gt;\n        &lt;controlfield tag=\"001\"&gt;on1143317889&lt;/controlfield&gt;\n        &lt;controlfield tag=\"003\"&gt;OCoLC&lt;/controlfield&gt;\n        &lt;controlfield tag=\"005\"&gt;20200328101446.1&lt;/controlfield&gt;\n        &lt;controlfield tag=\"008\"&gt;200305t20202019nyuabf   b    001 0 eng c&lt;/controlfield&gt;\n        &lt;datafield tag=\"010\" ind1=\" \" ind2=\" \"&gt;\n          &lt;subfield code=\"a\"&gt;  2018957420&lt;/subfield&gt;\n    &lt;/datafield&gt;\n        &lt;datafield tag=\"040\" ind1=\" \" ind2=\" \"&gt;\n          &lt;subfield code=\"a\"&gt;NYP&lt;/subfield&gt;\n          &lt;subfield code=\"b\"&gt;eng&lt;/subfield&gt;\n          &lt;subfield code=\"e\"&gt;rda&lt;/subfield&gt;\n          &lt;subfield code=\"c\"&gt;NYP&lt;/subfield&gt;\n&lt;!--...--&gt;\n        &lt;datafield tag=\"020\" ind1=\" \" ind2=\" \"&gt;\n          &lt;subfield code=\"a\"&gt;9780316230049&lt;/subfield&gt;\n          &lt;subfield code=\"q\"&gt;(pbk.)&lt;/subfield&gt;\n&lt;!--...--&gt;\n        &lt;datafield tag=\"100\" ind1=\"1\" ind2=\" \"&gt;\n          &lt;subfield code=\"a\"&gt;Christakis, Nicholas A.,&lt;/subfield&gt;\n          &lt;subfield code=\"e\"&gt;author.&lt;/subfield&gt;\n    &lt;/datafield&gt;\n        &lt;datafield tag=\"245\" ind1=\"1\" ind2=\"0\"&gt;\n          &lt;subfield code=\"a\"&gt;Blueprint :&lt;/subfield&gt;\n          &lt;subfield code=\"b\"&gt;the evolutionary origins of a good society /&lt;/subfield&gt;\n          &lt;subfield code=\"c\"&gt;Nicholas A. Christakis.&lt;/subfield&gt;\n    &lt;/datafield&gt;\n        &lt;datafield tag=\"250\" ind1=\" \" ind2=\" \"&gt;\n          &lt;subfield code=\"a\"&gt;First Little, Brown Spark trade paperback edition.&lt;/subfield&gt;\n    &lt;/datafield&gt;\n        &lt;datafield tag=\"264\" ind1=\" \" ind2=\"1\"&gt;\n          &lt;subfield code=\"a\"&gt;New York, NY :&lt;/subfield&gt;\n          &lt;subfield code=\"b\"&gt;Little, Brown Spark,&lt;/subfield&gt;\n          &lt;subfield code=\"c\"&gt;2020&lt;/subfield&gt;\n    &lt;/datafield&gt;\n&lt;!--...--&gt;\n  &lt;/record&gt;\n    &lt;/response&gt;\n  &lt;/content&gt;\n  &lt;id&gt;http://worldcat.org/oclc/1143317889&lt;/id&gt;\n  &lt;link href=\"http://worldcat.org/oclc/1143317889\"&gt;&lt;/link&gt;\n&lt;/entry&gt;\n</code></pre></p>"},{"location":"#updating-holdings","title":"Updating Holdings","text":"<p><code>MetadataSession</code> can be used to check or set/unset your library holdings on a master record in Worldcat:</p> <p>example: <pre><code>result = session.holding_set(oclc_number=\"850939579\")\nprint(result)\n&lt;Response [201]&gt;\n</code></pre></p> <p><pre><code>result = session.holding_get_status(\"850939579\")\nprint(result.json())\n</code></pre> <pre><code>{\n  \"title\": \"850939579\",\n  \"content\": {\n    \"requestedOclcNumber\": \"850939579\",\n    \"currentOclcNumber\": \"850939579\",\n    \"institution\": \"NYP\",\n    \"holdingCurrentlySet\": true,\n    \"id\": \"http://worldcat.org/oclc/850939579\"\n  },\n  \"updated\": \"2020-10-01T04:10:13.017Z\"\n}\n</code></pre></p> <p>For holdings operations on batches of records see Advanced Usage&gt;MetadataSession&gt;Updating Holdings</p>"},{"location":"#advanced-usage","title":"Advanced Usage","text":"<p>Identifying your application</p> <p>BookOps-Worldcat provides a default <code>user-agent</code> value in headers of all requests to OCLC web services: <code>bookops-worldcat/{version}</code>. It is encouraged to update the <code>user-agent</code> value to properly identify your application to OCLC servers. This will provide a useful piece of information for OCLC staff if they need to assist with troubleshooting problems that may arise. To set a custom \"user-agent\" in a session simply pass is as an argument when initiating the session: <pre><code>session = MetadataSession(authorization=token, agent=\"my_client_name\")\n</code></pre></p> <p>... or simply update its headers attribute: <pre><code>session.headers.update({\"user-agent\": \"my-app/version 1.0\"})\n</code></pre></p> <p>The <code>user-agent</code> header can be set for an access token request as well. To do that simply pass it as the <code>agent</code> parameter when initiating <code>WorldcatAccessToken</code> object: <pre><code>token = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=[\"WorldCatMetadataAPI\"],\n    principal_id=\"my_principal_id\",\n    principlal_idns=\"my_principal_idns\",\n    agent=\"my_app/1.0.0\"\n)\n</code></pre></p> <p>Event hooks</p> <p><code>MetadataSession</code> methods support Requests event hooks which can be passed as an argument:</p> <pre><code>def print_url(response, *args, **kwargs):\n    print(response.url)\n\nhooks = {'response': print_url}\nsession.get_brief_bib(850939579, hooks=hooks)\n</code></pre>"},{"location":"#worldcataccesstoken","title":"WorldcatAccessToken","text":"<p>Bookops-Worldcat utilizes OAuth 2.0 and Client Credential Grant flow to acquire Access Token. Please note, your OCLC credentials must allow access to the Metadata API in their scope to be permitted to make requests to the web service.</p> <p>Obtaining: <pre><code>from bookops_worldcat import WorldcatAccessToken\ntoken = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=[\"WorldCatMetadataAPI\"],\n    principal_id=\"my_principal_id\",\n    principlal_idns=\"my_principal_idns\",\n    agent=\"my_app/version 1.0\"\n)\n</code></pre></p> <p>Token object retains underlying Requests object functionality (<code>requests.Request</code>) that can be accessed via the <code>.server_response</code> attribute:</p> <p><pre><code>print(token.server_response.status_code)\n200\nprint(token.server_response.elapsed):\n0:00:00.650108\nprint(token.server_response.json())\n</code></pre> <pre><code>{\n\"user-agent\": \"bookops-worldcat/0.1.0\",\n\"Accept-Encoding\": \"gzip, deflate\",\n\"Accept\": \"application/json\",\n\"Connection\": \"keep-alive\",\n\"Content-Length\": \"67\",\n\"Content-Type\": \"application/x-www-form-urlencoded\",\n\"Authorization\": \"Basic encoded_authorization_here=\"\n}\n</code></pre></p> <p>Checking if the token has expired can be done by calling the <code>is_expired</code> method: <pre><code>print(token.is_expired())\nTrue\n</code></pre></p> <p>A failed token request raises <code>WorldcatAuthorizationError</code> which provides a returned by the server error code and detailed message.</p>"},{"location":"#metadatasession","title":"MetadataSession","text":"<p>A wrapper around WorldCat Metadata API. <code>MetadataSession</code> inherits <code>requests.Session</code> methods. Returned full bibliographic records are by default in MARC/XML format, but it is possible to receive OCLC's native CDF XML and the CDF translation into JSON serializations by supplying appropriate values in the <code>response_format</code> argument to the <code>get_full_bib</code> method. Search endpoints of the Metadata API return responses serialized into JSON format only. All <code>MetadataSession</code> issued requests have a build-in access token auto-refresh feature. While a session is open, before any request is sent, a current token is checked for expiration and if needed a new access token is automatically obtained. </p> <p>OCLC numbers in methods' arguments</p> <p><code>MetadataSession</code> accepts OCLC numbers in methods' arguments as integers or strings with or without a prefix (\"ocm\", \"ocn\", \"on\"). The following are all acceptable: <pre><code>session.get_brief_bib(oclcNumber=\"ocm00012345\")\nsession.get_brief_bib(oclcNumber=\"00012345\")\nsession.get_brief_bib(oclcNumber=12345)\nsession.search_current_control_numbers(oclcNumbers=[\"ocm00012345\", \"00012346\", 12347])\n</code></pre></p>"},{"location":"#search-functionality","title":"Search Functionality","text":"<p>MetadataSession supports the following search functionality:</p> <ul> <li><code>get_brief_bib</code> retrieves a specific brief bibliographic resource</li> <li><code>search_brief_bib_other_editions</code> retrieves other editions related to a bibliographic resource specified with an OCLC #</li> <li><code>search_brief_bibs</code> retrieves brief resouces for a keyword or a fielded query</li> <li><code>search_current_control_numbers</code> retrieves current OCLC control numbers</li> <li><code>search_general_holdings</code> retrieves a summary of holdings for a specified item</li> <li><code>search_shared_print_holdings</code> finds member library holdings with a commitment to retain (Shared Print)</li> </ul> <p>The server responses are returned in JSON format by default.</p> <p>Obtaining brief record</p> <p><pre><code>with MetadataSession(authorization=token) as session:\n    result = session.get_brief_bib(850940548)\n    print(results.json())\n</code></pre> <pre><code>{\n    \"oclcNumber\": \"850940548\",\n    \"title\": \"Record Builder Added This Test Record On 06/26/2013 13:07:06.\",\n    \"creator\": \"OCLC RecordBuilder.\",\n    \"date\": \"2012\",\n    \"language\": \"eng\",\n    \"generalFormat\": \"Book\",\n    \"specificFormat\": \"PrintBook\",\n    \"catalogingInfo\": {\n        \"catalogingAgency\": \"OCPSB\",\n        \"transcribingAgency\": \"OCPSB\"\n    }\n}\n</code></pre></p> <p>Quering WorldCat</p> <p>Metadata API provides quite robust methods to query WorldCat. In addition to a flexible query string that supports keyword and fielded searches, it is possibile to set further limits using various elements such as type of item, language, publishing date, etc. It is possible to specify the order of returned records by using the <code>orderBy</code> argument. Results are returned as brief records in JSON format.</p> <p>The query syntax is case-insensitive and allows keyword and phrase search (use quotation marks), boolean operators (AND, OR, NOT), wildcards (# - single character, ? - any number of additional characters), and truncation (use * character).</p> <p>keyword search with item type, language, and publishing date limiters: <pre><code>session.search_brief_bibs(\n    q=\"czarne oceany dukaj\",\n    itemType=\"book\",\n    inLanguage=\"pol\",\n    datePublished=\"2015-2020\"\n    orderBy=\"publicationDateDesc\"\n)\n</code></pre></p> <p>fielded query: <pre><code>session.search_brief_bibs(\n    q='ti=\"czarne oceany\" AND au:jacek dukaj AND ge=\"science fiction\"')\n</code></pre></p> <p>More about the query syntax can be found in OCLC documentation</p>"},{"location":"#obtaining-full-bibliographic-records","title":"Obtaining Full Bibliographic Records","text":"<p><code>session.get_full_bib()</code> method with OCLC number as an argument sends a request for a matching full bibliographic record in WorldCat. The Metadata API correctly matches requested OCLC numbers of records that have been merged together by returning the current master record. By default <code>get_full_bib</code> returns records in MARC XML format.</p> <p>Returned response is a <code>requests.Response</code> object with all its features: <pre><code>with MetadataSession(authorization=token) as session:\n    result = session.get_full_bib(\"00000000123\")\n    print(result.status_code)\n    print(result.url)\n200\n\"https://worldcat.org/bib/data/00000000123\"\n</code></pre> To avoid any <code>UnicodeEncodeError</code> it is recommended to access retrieved data with <code>.content</code> attribute of the response object: <pre><code>print(response.content)\n</code></pre></p>"},{"location":"#retrieving-current-oclc-number","title":"Retrieving Current OCLC Number","text":"<p><code>MetadataSession.search_current_control_numbers</code> method allows retrieval of a current control number of the master record in WorldCat. Occasionally, records identified as duplicates in WorldCat have been merged.  In that case a local control number may not correctly refer to an OCLC master record. Returned responses are in JSON format by default, but it's possible to pass <code>'application/atom+xml'</code> in the <code>response_format</code> argument to have the response serialized into xml.</p> <p><code>search_current_control_numbers</code> method accepts control numbers as a list or a comma separated string: <pre><code>session.search_current_control_numbers(oclcNumbers=\"00012345,00012346,00012347\")\nsession.search_current_control_numbers(oclcNumbers=[12345, 12346, 12347], response_format=\"application/atom+xml\")\n</code></pre></p>"},{"location":"#holdings","title":"Holdings","text":"<p><code>MetadataSession</code> supports the following holdings operations:</p> <ul> <li><code>holding_get_status</code> retrieves holding status of a requested record</li> <li><code>holding_set</code> sets holding on an individual bibliographic record</li> <li><code>holding_unset</code> deletes holding on an individual bibliographic record</li> <li><code>holdings_set</code> allows holdings to be set on multiple records, and is not limited by OCLC's 50 bib record limit</li> <li><code>holdings_unset</code> allows holdings to be deleted on multiple records, and is not limited to OCLC's 50 bib record restriction</li> <li><code>holdings_set_multi_institutions</code> allows to set holdings for a single record for multiple institutions</li> <li><code>holdings_unset_multi_institutions</code> deletes holdings on a single record for multiple institutions</li> </ul> <p>By default, responses are returned in <code>atom+json</code> format, but <code>atom+xml</code> can be specified: <pre><code>result = session.holding_get_status(oclcNumber=\"ocn123456789\", response_format=\"application/atom+xml\")\nprint(result.text)\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;entry xmlns=\"http://www.w3.org/2005/Atom\"&gt;\n  &lt;title type=\"text\"&gt;1143317889&lt;/title&gt;\n  &lt;updated&gt;2020-04-25T05:21:10.233Z&lt;/updated&gt;\n  &lt;content type=\"application/xml\"&gt;\n    &lt;holdings xmlns=\"http://worldcat.org/metadata-api-service\"&gt;\n      &lt;requestedOclcNumber&gt;1143317889&lt;/requestedOclcNumber&gt;\n      &lt;currentOclcNumber&gt;1143317889&lt;/currentOclcNumber&gt;\n      &lt;institution&gt;NYP&lt;/institution&gt;\n      &lt;holdingCurrentlySet&gt;true&lt;/holdingCurrentlySet&gt;\n      &lt;id&gt;http://worldcat.org/oclc/1143317889&lt;/id&gt;\n    &lt;/holdings&gt;\n  &lt;/content&gt;\n&lt;/entry&gt;\n</code></pre></p> <p>Pass OCLC record numbers for batch operations as a list of strings or integers or comma separated string with or without a prefix: <pre><code>session.holdings_set(\n    oclcNumbers=\"00000000123,00000000124,00000000125,00000000126\")\n\nsession.holdings_unset(oclcNumbers=[123, 124, 125, 126])\n</code></pre> The OCLC web service limits the number of records in a batch operation to 50, but <code>MetadataSession</code> permits larger batches by splitting the batch into chunks of 50 and automatically issuing multiple requests. The return object is a list of returned from server responses.</p> <pre><code>results = session.holdings_unset(oclcNumbers=[123, 124, 125, 126])\n\n# print results of each batch of 50s\nfor r in results:\n    print(r.json())\n</code></pre> <p>A consortium type of organizations that serve multiple libraries can utilize <code>holdings_set_multi_institutions</code> and <code>holdings_unset_multi_institutions</code> methods to set and unset holdings for selected libraries. List of library OCLC codes is passed as a comma separated string to instSymbol parameter.</p> <pre><code>results = session.holdings_set_multi_institutions(oclcNumber=1234, instSymbols=\"BKL,NYP\")\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>Complex search query: <pre><code>from bookops_worldcat import WorldcatAccessToken, MetadataSession\n\n# obtain access token\ntoken = WorldcatAccessToken(\n    key=\"my_WSKey\",\n    secret=\"my_secret\",\n    scopes=[\"WorldCatMetadataAPI\"],\n    principal_id=\"my_principal_id\",\n    principal_idns=\"my_principal_idns\",\n    agent=\"my_app/version 1.0\"\n)\n\n\nwith MetadataSession(authorization=token) as session:\n\n    # search Worlcat\n    response = session.search_brief_bibs(\n        q=\"su:civil war AND (su:antietam OR su:sharpsburg)\",\n        datePublished=\"2000-2020\",\n        inLanguage=\"eng\",\n        inCatalogLanguage=\"eng\",\n        catalogSource=\"dlc\",\n        itemType=\"book\",\n        itemSubType=\"digital\",\n        orderBy=\"mostWidelyHeld\",\n        limit=20)\n    first_bib = response.json()[\"briefRecords\"][0]\n    first_bib_number = first_bib[\"oclcNumber\"]\n\n    # get full bib\n    response = session.get_full_bib(oclcNumber=first_bib_number)\n    print(response.content)\n</code></pre></p>"},{"location":"about/","title":"About BookOps","text":""},{"location":"about/#bookops","title":"BookOps","text":"<p>BookOps is a fully consolidated, shared library technical services organization that serves the Brooklyn Public Library (BPL) and the New York Public Library (NYPL).</p> <p>BookOps-Worldcat was glued together by Tomasz Kalata with contribution by Miriam Gloger.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#050-3112022","title":"[0.5.0] - (3/11/2022)","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>feature to set and unset holdings for individual record for multiple institutions (/ih/institutionlist endpoint)</li> <li><code>__repr__</code> method to <code>WorldcatAccessToken</code> object</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>\"refreshing\" of access tokens moved to <code>_session.WorldcatSession</code> from <code>metadata_api.MetadataSession</code> to allow inheritance of this functionality by future clients</li> <li>refactors some of tests</li> </ul>"},{"location":"changelog/#041-2102022","title":"0.4.1 - (2/10/2022)","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Handling of unexpected 206 HTTP code that is occasionally returned by the MetadataAPI /brief-bibs endpoint</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Introduced a breaking change to exceptions raised on calls to the web service for bibliographic resources: <code>WorldcatSessionError</code> was changed to <code>WorldcatRequestError</code>. </li> <li>Dev dependencies updates (pytest, pytest-cov, pytest-mock, mkdocs, black, mik, mkapi, mypy)</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>requests to OCLC services are now handled by a new <code>query.Query</code> class</li> <li>dependencies update<ul> <li>requests to 2.27.1</li> <li>dev dependencies</li> </ul> </li> </ul>"},{"location":"changelog/#040-6222021","title":"0.4.0 - (6/22/2021)","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Changes to <code>MetadataSession.search_brief_bibs</code> method due to /brief-bibs endpoint changes:<ul> <li>removed deprecated argument <code>heldBy</code></li> <li>added <code>groupVariantRecord</code> and <code>preferredLanuage</code> argument</li> <li>modified <code>groupRelatedEditions</code> to allow boolean arguments</li> </ul> </li> <li>Changes to <code>MetadataSession.search_general_holdings</code> method due to API changes:<ul> <li>added following arguements: <code>holdingsAllVariantRecords</code>, <code>preferredLanguage</code></li> <li>removed deprecated <code>heldBy</code> argument</li> </ul> </li> <li>Changes to <code>MetadataSession.search_brief_bib_other_editions</code>:<ul> <li>added <code>deweyNumber</code>, <code>datePublished</code>, <code>heldByGroup</code>, <code>heldBySymbol</code>,  <code>heldByInstitutionId</code>, <code>inLanguage</code>, <code>inCatalogLanguage</code>, <code>materialType</code>,  <code>catalogSource</code>, <code>itemType</code>, <code>itemSubType</code>, <code>retentionCommitments</code>,  <code>spProgram</code>, <code>topic</code>, <code>subtopic</code>, <code>audience</code>, <code>content</code>, <code>openAccess</code>,  <code>peerReviewed</code>, <code>facets</code>, <code>groupVariantRecords</code>, <code>preferredLanguage</code>,  and <code>orderBy</code>. </li> </ul> </li> </ul>"},{"location":"changelog/#035-622021","title":"0.3.5 - (6/2/2021)","text":""},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Dependencies update<ul> <li>urllib3 from 1.26.4 to 1.26.5</li> </ul> </li> </ul>"},{"location":"changelog/#034-3222021","title":"0.3.4 - (3/22/2021)","text":""},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Dependencies update<ul> <li>certifi to 2020.12.5</li> <li>chardet to 4.0.0</li> <li>requests to 2.25.1</li> <li>urllib3 to 1.26.4</li> </ul> </li> </ul>"},{"location":"changelog/#033-12282020","title":"0.3.3 - (12/28/2020)","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Type hints</li> <li>Default timeout in the MetadataSesssion extended to 5 seconds</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Dependencies:<ul> <li>pytest bump to 6.1.2</li> <li>mypy 0.7.8</li> </ul> </li> </ul>"},{"location":"changelog/#032-11252020","title":"0.3.2 - (11/25/2020)","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>MetadataSession timeout paramerter correctly passed into every session request</li> </ul>"},{"location":"changelog/#031-11242020","title":"0.3.1 - (11/24/2020)","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed auto refreshing of the access token when expired</li> <li>testing: fixed testing for error messages on exceptions &amp; testing of stale tokens</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Dependencies bump<ul> <li>certifi from 2020.6.20 to 2020.11.8</li> <li>requests from 2.24.0 to 2.25.0</li> <li>urlib3 from 1.25.10 to 1.26.2</li> </ul> </li> </ul>"},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Added Python 3.9 testing to CI</li> </ul>"},{"location":"changelog/#030-10032020","title":"0.3.0 - (10/03/2020)","text":""},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Introduces multiple breaking changes compared to the previous version!</li> <li>Dropped features related to the WorldCat Search API</li> <li>Support for Worldcat Metadata API v.1.1 introduced in May 2020</li> <li>Supported Metdata API endpoints:<ul> <li>/bibs-retained-holdings</li> <li>/bibs-summary-holdings</li> <li>/brief-bibs</li> <li>/brief-bibs/{oclcNumber}</li> <li>/brief-bibs/{oclcNumber}/other-editions</li> <li>/bib/data/{oclcNumber}</li> <li>/bib/checkcontrolnumbers</li> <li>/ih/data (POST|DELETE)</li> <li>/ih/checkholdings</li> <li>/ih/datalist (POST|DELETE)</li> </ul> </li> </ul>"},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>API reference added to docs with mkapi</li> </ul>"},{"location":"changelog/#021-9282020","title":"0.2.1 - (9/28/2020)","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>added functionality for docs versioning with mike</li> </ul>"},{"location":"changelog/#020-04302020","title":"0.2.0 - (04/30/2020)","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Expanded and improved documentation</li> <li>Customizable \"user-agent\" in session header and token request</li> <li><code>TokenRequestError</code> exception added on failed access token request</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>SRU/CQL query syntax aligned with OCLC specifications</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>fixed hooks info in docstrings in <code>SearchSession</code> and <code>MetadataSession</code></li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#save-a-full-bib-xml-response-to-a-file-in-marc21-format","title":"Save a full bib XML response to a file in MARC21 format","text":"<p>This recipe shows how to query Worldcat for specific full bibliographic records and save the results to a file in MARC21 format.</p> <p>A conversion from the response to the MARC format is handled by the pymarc library (see more at https://pypi.org/project/pymarc/), specifically its <code>parse_xml_to_array</code> and <code>as_marc</code> methods.</p> <p>The code below requires an access token (<code>WorldcatAccessToken</code> object) to be passed to the MetadataSession for authorization.</p> <pre><code>from io import BytesIO\n\nfrom bookops_worldcat import MetadataSession\nfrom pymarc import parse_xml_to_array\n\noclc_numbers = [850939580, 850939581, 850939582]\n\n# obtain first an access token using the WorldcatAccessToken and \n# your OCLC Metadata API credentials\n\nwith MetadataSession(authorization=token) as session:\n\n    for o in oclc_numbers:\n        response = session.get_full_bib(oclcNumber=o)\n        data = BytesIO(response.content)\n\n        # convert into pymarc Record object\n        bib = parse_xml_to_array(data)[0]\n\n        # manipulate bib to your liking before saving to a file\n\n        # append to a MARC21 file:\n        with open(\"retrieved_bibs.mrc\", \"ab\") as out:\n            out.write(bib.as_marc())\n</code></pre>"},{"location":"api/authorize/","title":"bookops_worldcat.authorize","text":"<p>This module provides means to authenticate and obtain a WorldCat access token.</p>"},{"location":"api/authorize/#bookops_worldcat.authorize.WorldcatAccessToken","title":"WorldcatAccessToken","text":"<pre><code>WorldcatAccessToken(\n    key: str,\n    secret: str,\n    scopes: Union[str, List[str]],\n    principal_id: str,\n    principal_idns: str,\n    agent: Optional[str] = None,\n    timeout: Optional[\n        Union[\n            int, float, Tuple[int, int], Tuple[float, float]\n        ]\n    ] = None,\n)\n</code></pre> <p>Requests Worldcat access token. Authenticates and authorizes using Client Credentials Grant. Does not support Explicit Authorization Code and Refresh Token flows. Token with correctly bonded scopes can then be passed into a session of particular web service to authorize requests for resources. More on OCLC's web services authorization: https://www.oclc.org/developer/develop/authentication/oauth/client-credentials-grant.en.html</p> PARAMETER DESCRIPTION <code>key</code> <p>your WSKey public client_id</p> <p> TYPE: <code>str</code> </p> <code>secret</code> <p>your WSKey secret</p> <p> TYPE: <code>str</code> </p> <code>scopes</code> <p>request scopes for the access token</p> <p> TYPE: <code>Union[str, List[str]]</code> </p> <code>principal_id</code> <p>principalID (required for read/write endpoints)</p> <p> TYPE: <code>str</code> </p> <code>principal_idns</code> <p>principalIDNS (required for read/write endpoints)</p> <p> TYPE: <code>str</code> </p> <code>agent</code> <p>\"User-agent\" parameter to be passed in the request                     header; usage strongly encouraged</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>how long to wait for server to send data before                     giving up; default value is 3 seconds</p> <p> TYPE: <code>Optional[Union[int, float, Tuple[int, int], Tuple[float, float]]]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from bookops_worldcat import WorldcatAccessToken\n&gt;&gt;&gt; token = WorldcatAccessToken(\n        key=\"my_WSKey_client_id\",\n        secret=\"my_WSKey_secret\",\n        scope=\"WorldCatMetadataAPI\",\n        principal_id=\"your principalID here\",\n        principal_idns=\"your principalIDNS here\",\n        agent=\"my_app/1.0.0\")\n&gt;&gt;&gt; token.token_str\n\"tk_Yebz4BpEp9dAsghA7KpWx6dYD1OZKWBlHjqW\"\n&gt;&gt;&gt; token.is_expired()\nFalse\n&gt;&gt;&gt; token.server_response.json()\n{\"token_token\": \"tk_Yebz4BpEp9dAsghA7KpWx6dYD1OZKWBlHjqW\",\n \"token_type\": \"bearer\",\n \"expires_in\": \"1199\",\n \"principalID\": \"\",\n \"principalIDNS\": \"\",\n \"scopes\": \"WorldCatMetadataAPI\",\n \"contextInstitutionId\": \"00001\",\n \"expires_at\": \"2020-08-23 18:45:29Z\"}\n&gt;&gt;&gt; token.server_response.request.headers\n{\"User-Agent\": \"my_app/1.0.0\",\n \"Accept-Encoding\": \"gzip, deflate\",\n \"Accept\": \"application/json\",\n \"Connection\": \"keep-alive\",\n \"Content-Length\": \"67\",\n \"Content-Type\": \"application/x-www-form-urlencoded\",\n \"Authorization\": \"Basic encoded_authorization_here=\"}\n</code></pre> Source code in <code>bookops_worldcat\\authorize.py</code> <pre><code>def __init__(\n    self,\n    key: str,\n    secret: str,\n    scopes: Union[str, List[str]],\n    principal_id: str,\n    principal_idns: str,\n    agent: Optional[str] = None,\n    timeout: Optional[\n        Union[int, float, Tuple[int, int], Tuple[float, float]]\n    ] = None,\n) -&gt; None:\n    \"\"\"Constructor\"\"\"\n\n    self.agent = agent\n    self.grant_type = \"client_credentials\"\n    self.key = key\n    self.oauth_server = \"https://oauth.oclc.org\"\n    self.principal_id = principal_id\n    self.principal_idns = principal_idns\n    self.scopes = scopes\n    self.secret = secret\n    self.server_response = None\n    self.timeout = timeout\n    self.token_expires_at = None\n    self.token_str = None\n    self.token_type = None\n\n    # default bookops-worldcat request header\n    if self.agent is None:\n        self.agent = f\"{__title__}/{__version__}\"\n    else:\n        if type(self.agent) is not str:\n            raise WorldcatAuthorizationError(\"Argument 'agent' must be a string.\")\n\n    # asure passed arguments are valid\n    if not self.key:\n        raise WorldcatAuthorizationError(\"Argument 'key' is required.\")\n    else:\n        if type(self.key) is not str:\n            raise WorldcatAuthorizationError(\"Argument 'key' must be a string.\")\n\n    if not self.secret:\n        raise WorldcatAuthorizationError(\"Argument 'secret' is required.\")\n    else:\n        if type(self.secret) is not str:\n            raise WorldcatAuthorizationError(\"Argument 'secret' must be a string.\")\n\n    if not self.principal_id:\n        raise WorldcatAuthorizationError(\n            \"Argument 'principal_id' is required for read/write endpoint of Metadata API.\"\n        )\n    if not self.principal_idns:\n        raise WorldcatAuthorizationError(\n            \"Argument 'principal_idns' is required for read/write endpoint of Metadata API.\"\n        )\n\n    # validate passed scopes\n    if type(self.scopes) is list:\n        self.scopes = \" \".join(self.scopes)\n    elif type(self.scopes) is not str:\n        raise WorldcatAuthorizationError(\n            \"Argument 'scopes' must a string or a list.\"\n        )\n    self.scopes = self.scopes.strip()  # type: ignore\n    if self.scopes == \"\":\n        raise WorldcatAuthorizationError(\"Argument 'scope' is missing.\")\n\n    # assign default value for timout\n    if not self.timeout:\n        self.timeout = (3, 3)\n\n    # initiate request\n    self._request_token()\n</code></pre>"},{"location":"api/authorize/#bookops_worldcat.authorize.WorldcatAccessToken.is_expired","title":"is_expired","text":"<pre><code>is_expired() -&gt; bool\n</code></pre> <p>Checks if the access token is expired.</p> RETURNS DESCRIPTION <code>bool</code> <p>bool</p> <p>Example:</p> <p>token.is_expired() False</p> Source code in <code>bookops_worldcat\\authorize.py</code> <pre><code>def is_expired(self) -&gt; bool:\n    \"\"\"\n    Checks if the access token is expired.\n\n    Returns:\n        bool\n\n    Example:\n    &gt;&gt;&gt; token.is_expired()\n    False\n    \"\"\"\n    try:\n        if (\n            datetime.datetime.strptime(self.token_expires_at, \"%Y-%m-%d %H:%M:%SZ\")  # type: ignore\n            &lt; datetime.datetime.utcnow()\n        ):\n            return True\n        else:\n            return False\n    except TypeError:\n        raise\n    except ValueError:\n        raise\n</code></pre>"},{"location":"api/errors/","title":"bookops_worldcat.errors","text":"<p>This module contains the set of bookops_worldcat exceptions.</p>"},{"location":"api/errors/#bookops_worldcat.errors.BookopsWorldcatError","title":"BookopsWorldcatError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for exceptions in this module.</p>"},{"location":"api/errors/#bookops_worldcat.errors.InvalidOclcNumber","title":"InvalidOclcNumber","text":"<p>               Bases: <code>BookopsWorldcatError</code></p> <p>Exception raised when an invalid OCLC record number is encountered</p>"},{"location":"api/errors/#bookops_worldcat.errors.WorldcatAuthorizationError","title":"WorldcatAuthorizationError","text":"<p>               Bases: <code>BookopsWorldcatError</code></p> <p>Exception raised when WorldCat access token is not obtained</p>"},{"location":"api/errors/#bookops_worldcat.errors.WorldcatRequestError","title":"WorldcatRequestError","text":"<p>               Bases: <code>WorldcatSessionError</code></p> <p>Exceptions raised on HTTP errors returned by web service</p>"},{"location":"api/errors/#bookops_worldcat.errors.WorldcatSessionError","title":"WorldcatSessionError","text":"<p>               Bases: <code>BookopsWorldcatError</code></p> <p>Exception raised during WorlCat session</p>"},{"location":"api/metadata_api/","title":"bookops_worldcat.metadata_api","text":"<p>This module provides MetadataSession class for requests to WorldCat Metadata API.</p>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession","title":"MetadataSession","text":"<pre><code>MetadataSession(\n    authorization: WorldcatAccessToken,\n    agent: Optional[str] = None,\n    timeout: Optional[\n        Union[\n            int, float, Tuple[int, int], Tuple[float, float]\n        ]\n    ] = None,\n)\n</code></pre> <p>               Bases: <code>WorldcatSession</code></p> <p>OCLC Metadata API wrapper session. Inherits <code>requests.Session</code> methods</p> <pre><code>agent:                  \"User-agent\" parameter to be passed in the request\n                        header; usage strongly encouraged\ntimeout:                how long to wait for server to send data before\n                        giving up; default value is 5 seconds\n</code></pre> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def __init__(\n    self,\n    authorization: WorldcatAccessToken,\n    agent: Optional[str] = None,\n    timeout: Optional[\n        Union[int, float, Tuple[int, int], Tuple[float, float]]\n    ] = None,\n) -&gt; None:\n    \"\"\"\n    Args:\n        authorization:          WorlcatAccessToken object\n        agent:                  \"User-agent\" parameter to be passed in the request\n                                header; usage strongly encouraged\n        timeout:                how long to wait for server to send data before\n                                giving up; default value is 5 seconds\n    \"\"\"\n    super().__init__(authorization, agent=agent, timeout=timeout)\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.get_brief_bib","title":"get_brief_bib","text":"<pre><code>get_brief_bib(\n    oclcNumber: Union[int, str],\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Retrieve specific brief bibliographic resource. Uses /brief-bibs/{oclcNumber} endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number; can be                     an integer, or string that can include                     OCLC # prefix</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>hooks</code> <p>Requests library hook system that can be                     used for signal event handling, see more at:                     https://requests.readthedocs.io/en/master/user/advanced/#event-hooks</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> <p>Returns:     <code>requests.Response</code> instance</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def get_brief_bib(\n    self, oclcNumber: Union[int, str], hooks: Optional[Dict[str, Callable]] = None\n) -&gt; Response:\n    \"\"\"\n    Retrieve specific brief bibliographic resource.\n    Uses /brief-bibs/{oclcNumber} endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be\n                                an integer, or string that can include\n                                OCLC # prefix\n        hooks:                  Requests library hook system that can be\n                                used for signal event handling, see more at:\n                                https://requests.readthedocs.io/en/master/user/advanced/#event-hooks\n    Returns:\n        `requests.Response` instance\n    \"\"\"\n\n    try:\n        oclcNumber = verify_oclc_number(oclcNumber)\n    except InvalidOclcNumber:\n        raise WorldcatSessionError(\"Invalid OCLC # was passed as an argument\")\n\n    header = {\"Accept\": \"application/json\"}\n    url = self._url_brief_bib_oclc_number(oclcNumber)\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.get_full_bib","title":"get_full_bib","text":"<pre><code>get_full_bib(\n    oclcNumber: Union[int, str],\n    response_format: Optional[str] = None,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Send a GET request for a full bibliographic resource. Uses /bib/data/{oclcNumber} endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number; can be an                     integer, or string with or without OCLC # prefix</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>response_format</code> <p>format of returned record</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>hooks</code> <p>Requests library hook system that can be                     used for signal event handling, see more at:                     https://requests.readthedocs.io/en/master/user/advanced/#event-hooks</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> <p>Returns:     <code>requests.Response</code> object</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def get_full_bib(\n    self,\n    oclcNumber: Union[int, str],\n    response_format: Optional[str] = None,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Send a GET request for a full bibliographic resource.\n    Uses /bib/data/{oclcNumber} endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer, or string with or without OCLC # prefix\n        response_format:        format of returned record\n        hooks:                  Requests library hook system that can be\n                                used for signal event handling, see more at:\n                                https://requests.readthedocs.io/en/master/user/advanced/#event-hooks\n    Returns:\n        `requests.Response` object\n    \"\"\"\n    try:\n        oclcNumber = verify_oclc_number(oclcNumber)\n    except InvalidOclcNumber:\n        raise WorldcatSessionError(\"Invalid OCLC # was passed as an argument.\")\n\n    url = self._url_bib_oclc_number(oclcNumber)\n    if not response_format:\n        response_format = (\n            'application/atom+xml;content=\"application/vnd.oclc.marc21+xml\"'\n        )\n    header = {\"Accept\": response_format}\n\n    # prep request\n    req = Request(\"GET\", url, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holding_get_status","title":"holding_get_status","text":"<pre><code>holding_get_status(\n    oclcNumber: Union[int, str],\n    inst: Optional[str] = None,\n    instSymbol: Optional[str] = None,\n    response_format: Optional[\n        str\n    ] = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Retrieves Worlcat holdings status of a record with provided OCLC number. The service automatically recognizes institution based on the issued access token. Uses /ih/checkholdings endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number; can be an                     integer, or string with or without OCLC # prefix</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>inst</code> <p>registry ID of the institution whose holdings                     are being checked</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>instSymbol</code> <p>optional; OCLC symbol of the institution whose                     holdings are being checked</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>response_format</code> <p>'application/atom+json' (default) or                     'application/atom+xml'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'application/atom+json'</code> </p> <code>hooks</code> <p>Requests library hook system that can be                     used for signal event handling, see more at:                     https://requests.readthedocs.io/en/master/user/advanced/#event-hooks</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> object</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def holding_get_status(\n    self,\n    oclcNumber: Union[int, str],\n    inst: Optional[str] = None,\n    instSymbol: Optional[str] = None,\n    response_format: Optional[str] = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Retrieves Worlcat holdings status of a record with provided OCLC number.\n    The service automatically recognizes institution based on the issued access\n    token.\n    Uses /ih/checkholdings endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer, or string with or without OCLC # prefix\n        inst:                   registry ID of the institution whose holdings\n                                are being checked\n        instSymbol:             optional; OCLC symbol of the institution whose\n                                holdings are being checked\n        response_format:        'application/atom+json' (default) or\n                                'application/atom+xml'\n        hooks:                  Requests library hook system that can be\n                                used for signal event handling, see more at:\n                                https://requests.readthedocs.io/en/master/user/advanced/#event-hooks\n\n    Returns:\n        `requests.Response` object\n    \"\"\"\n    try:\n        oclcNumber = verify_oclc_number(oclcNumber)\n    except InvalidOclcNumber as exc:\n        raise WorldcatSessionError(exc)\n\n    url = self._url_bib_holdings_check()\n    header = {\"Accept\": response_format}\n    payload = {\"oclcNumber\": oclcNumber, \"inst\": inst, \"instSymbol\": instSymbol}\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holding_set","title":"holding_set","text":"<pre><code>holding_set(\n    oclcNumber: Union[int, str],\n    inst: Optional[str] = None,\n    instSymbol: Optional[str] = None,\n    holdingLibraryCode: Optional[str] = None,\n    classificationScheme: Optional[str] = None,\n    response_format: str = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Sets institution's Worldcat holding on an individual record. Uses /ih/data endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number; can be an                     integer, or string with or without OCLC # prefix</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>inst</code> <p>registry ID of the institution whose holdings                     are being checked</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>instSymbol</code> <p>optional; OCLC symbol of the institution whose                     holdings are being checked</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>holdingLibraryCode</code> <p>four letter holding code to set the holing on</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>classificationScheme</code> <p>whether or not to return group availability                     information</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>response_format</code> <p>'application/atom+json' (default) or                     'application/atom+xml'</p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/atom+json'</code> </p> <code>hooks</code> <p>Requests library hook system that can be                     used for signal event handling, see more at:                     https://requests.readthedocs.io/en/master/user/advanced/#event-hooks</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> object</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def holding_set(\n    self,\n    oclcNumber: Union[int, str],\n    inst: Optional[str] = None,\n    instSymbol: Optional[str] = None,\n    holdingLibraryCode: Optional[str] = None,\n    classificationScheme: Optional[str] = None,\n    response_format: str = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Sets institution's Worldcat holding on an individual record.\n    Uses /ih/data endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer, or string with or without OCLC # prefix\n        inst:                   registry ID of the institution whose holdings\n                                are being checked\n        instSymbol:             optional; OCLC symbol of the institution whose\n                                holdings are being checked\n        holdingLibraryCode:     four letter holding code to set the holing on\n        classificationScheme:   whether or not to return group availability\n                                information\n        response_format:        'application/atom+json' (default) or\n                                'application/atom+xml'\n        hooks:                  Requests library hook system that can be\n                                used for signal event handling, see more at:\n                                https://requests.readthedocs.io/en/master/user/advanced/#event-hooks\n\n    Returns:\n        `requests.Response` object\n    \"\"\"\n\n    try:\n        oclcNumber = verify_oclc_number(oclcNumber)\n    except InvalidOclcNumber as exc:\n        raise WorldcatSessionError(exc)\n\n    url = self._url_bib_holdings_action()\n    header = {\"Accept\": response_format}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"inst\": inst,\n        \"instSymbol\": instSymbol,\n        \"holdingLibraryCode\": holdingLibraryCode,\n        \"classificationScheme\": classificationScheme,\n    }\n\n    # prep request\n    req = Request(\"POST\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holding_unset","title":"holding_unset","text":"<pre><code>holding_unset(\n    oclcNumber: Union[int, str],\n    cascade: Union[int, str] = \"0\",\n    inst: Optional[str] = None,\n    instSymbol: Optional[str] = None,\n    holdingLibraryCode: Optional[str] = None,\n    classificationScheme: Optional[str] = None,\n    response_format: str = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Deletes institution's Worldcat holding on an individual record. Uses /ih/data endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number; can be an                     integer, or string with or without OCLC # prefix                     if str the numbers must be separated by comma</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>cascade</code> <p>0 or 1, default 0;                     0 - don't remove holdings if local holding                     record or local bibliographic records exists;                     1 - remove holding and delete local holdings                     record and local bibliographic record</p> <p> TYPE: <code>Union[int, str]</code> DEFAULT: <code>'0'</code> </p> <code>inst</code> <p>registry ID of the institution whose holdings                     are being checked</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>instSymbol</code> <p>optional; OCLC symbol of the institution whose                     holdings are being checked</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>holdingLibraryCode</code> <p>four letter holding code to set the holing on</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>classificationScheme</code> <p>whether or not to return group availability                     information</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>response_format</code> <p>'application/atom+json' (default) or                     'application/atom+xml'</p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/atom+json'</code> </p> <code>hooks</code> <p>Requests library hook system that can be                     used for signal event handling, see more at:                     https://requests.readthedocs.io/en/master/user/advanced/#event-hooks</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> object</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def holding_unset(\n    self,\n    oclcNumber: Union[int, str],\n    cascade: Union[int, str] = \"0\",\n    inst: Optional[str] = None,\n    instSymbol: Optional[str] = None,\n    holdingLibraryCode: Optional[str] = None,\n    classificationScheme: Optional[str] = None,\n    response_format: str = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Deletes institution's Worldcat holding on an individual record.\n    Uses /ih/data endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer, or string with or without OCLC # prefix\n                                if str the numbers must be separated by comma\n        cascade:                0 or 1, default 0;\n                                0 - don't remove holdings if local holding\n                                record or local bibliographic records exists;\n                                1 - remove holding and delete local holdings\n                                record and local bibliographic record\n        inst:                   registry ID of the institution whose holdings\n                                are being checked\n        instSymbol:             optional; OCLC symbol of the institution whose\n                                holdings are being checked\n        holdingLibraryCode:     four letter holding code to set the holing on\n        classificationScheme:   whether or not to return group availability\n                                information\n        response_format:        'application/atom+json' (default) or\n                                'application/atom+xml'\n        hooks:                  Requests library hook system that can be\n                                used for signal event handling, see more at:\n                                https://requests.readthedocs.io/en/master/user/advanced/#event-hooks\n\n    Returns:\n        `requests.Response` object\n    \"\"\"\n\n    try:\n        oclcNumber = verify_oclc_number(oclcNumber)\n    except InvalidOclcNumber as exc:\n        raise WorldcatSessionError(exc)\n\n    url = self._url_bib_holdings_action()\n    header = {\"Accept\": response_format}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"cascade\": cascade,\n        \"inst\": inst,\n        \"instSymbol\": instSymbol,\n        \"holdingLibraryCode\": holdingLibraryCode,\n        \"classificationScheme\": classificationScheme,\n    }\n\n    # prep request\n    req = Request(\"DELETE\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_set","title":"holdings_set","text":"<pre><code>holdings_set(\n    oclcNumbers: Union[str, List],\n    inst: Optional[str] = None,\n    instSymbol: Optional[str] = None,\n    response_format: str = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; List[Response]\n</code></pre> <p>Set institution holdings for multiple OCLC numbers Uses /ih/datalist endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumbers</code> <p>list of OCLC control numbers for which holdings                     should be set;                     they can be integers or strings with or                     without OCLC # prefix;                     if str the numbers must be separated by comma</p> <p> TYPE: <code>Union[str, List]</code> </p> <code>inst</code> <p>registry ID of the institution whose holdings                     are being checked</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>instSymbol</code> <p>optional; OCLC symbol of the institution whose                     holdings are being checked</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>response_format</code> <p>'application/atom+json' (default) or                     'application/atom+xml'</p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/atom+json'</code> </p> <code>hooks</code> <p>Requests library hook system that can be                     used for signal event handling, see more at:                     https://requests.readthedocs.io/en/master/user/advanced/#event-hooks</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> <p>Returns:     list of <code>requests.Response</code> objects</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def holdings_set(\n    self,\n    oclcNumbers: Union[str, List],\n    inst: Optional[str] = None,\n    instSymbol: Optional[str] = None,\n    response_format: str = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; List[Response]:\n    \"\"\"\n    Set institution holdings for multiple OCLC numbers\n    Uses /ih/datalist endpoint.\n\n    Args:\n        oclcNumbers:            list of OCLC control numbers for which holdings\n                                should be set;\n                                they can be integers or strings with or\n                                without OCLC # prefix;\n                                if str the numbers must be separated by comma\n        inst:                   registry ID of the institution whose holdings\n                                are being checked\n        instSymbol:             optional; OCLC symbol of the institution whose\n                                holdings are being checked\n        response_format:        'application/atom+json' (default) or\n                                'application/atom+xml'\n        hooks:                  Requests library hook system that can be\n                                used for signal event handling, see more at:\n                                https://requests.readthedocs.io/en/master/user/advanced/#event-hooks\n    Returns:\n        list of `requests.Response` objects\n    \"\"\"\n    responses = []\n\n    try:\n        vetted_numbers = verify_oclc_numbers(oclcNumbers)\n    except InvalidOclcNumber as exc:\n        raise WorldcatSessionError(exc)\n\n    url = self._url_bib_holdings_batch_action()\n    header = {\"Accept\": response_format}\n\n    # split into batches of 50 and issue request for each batch\n    for batch in self._split_into_legal_volume(vetted_numbers):\n        payload = {\n            \"oclcNumbers\": batch,\n            \"inst\": inst,\n            \"instSymbol\": instSymbol,\n        }\n\n        # prep request\n        req = Request(\"POST\", url, params=payload, headers=header, hooks=hooks)\n        prepared_request = self.prepare_request(req)\n\n        # send request\n        query = Query(self, prepared_request, timeout=self.timeout)\n\n        responses.append(query.response)\n\n    return responses\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_set_multi_institutions","title":"holdings_set_multi_institutions","text":"<pre><code>holdings_set_multi_institutions(\n    oclcNumber: Union[int, str],\n    instSymbols: str,\n    response_format: str = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Batch sets intitution holdings for multiple intitutions</p> <p>Uses /ih/institutionlist endpoint</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number; can be an                     integer, or string with or without OCLC # prefix</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>instSymbols</code> <p>a comma-separated list of OCLC symbols of the                     institution whose holdings are being set</p> <p> TYPE: <code>str</code> </p> <code>response_format</code> <p>'application/atom+json' (default) or                     'application/atom+xml'</p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/atom+json'</code> </p> <code>hooks</code> <p>Requests library hook system that can be                     used for signal event handling, see more at:                     https://requests.readthedocs.io/en/master/user/advanced/#event-hooks</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> <p>Returns:     <code>requests.Response</code> object</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def holdings_set_multi_institutions(\n    self,\n    oclcNumber: Union[int, str],\n    instSymbols: str,\n    response_format: str = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Batch sets intitution holdings for multiple intitutions\n\n    Uses /ih/institutionlist endpoint\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer, or string with or without OCLC # prefix\n        instSymbols:            a comma-separated list of OCLC symbols of the\n                                institution whose holdings are being set\n        response_format:        'application/atom+json' (default) or\n                                'application/atom+xml'\n        hooks:                  Requests library hook system that can be\n                                used for signal event handling, see more at:\n                                https://requests.readthedocs.io/en/master/user/advanced/#event-hooks\n    Returns:\n        `requests.Response` object\n    \"\"\"\n    try:\n        oclcNumber = verify_oclc_number(oclcNumber)\n    except InvalidOclcNumber:\n        raise WorldcatSessionError(\"Invalid OCLC # was passed as an argument\")\n\n    url = self._url_bib_holdings_multi_institution_batch_action()\n    header = {\"Accept\": response_format}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"instSymbols\": instSymbols,\n    }\n\n    # prep request\n    req = Request(\"POST\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_unset","title":"holdings_unset","text":"<pre><code>holdings_unset(\n    oclcNumbers: Union[str, List],\n    cascade: str = \"0\",\n    inst: Optional[str] = None,\n    instSymbol: Optional[str] = None,\n    response_format: str = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; List[Response]\n</code></pre> <p>Set institution holdings for multiple OCLC numbers Uses /ih/datalist endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumbers</code> <p>list of OCLC control numbers for which holdings                     should be set;                     they can be integers or strings with or                     without OCLC # prefix;                     if str the numbers must be separated by comma</p> <p> TYPE: <code>Union[str, List]</code> </p> <code>cascade</code> <p>0 or 1, default 0;                     0 - don't remove holdings if local holding                     record or local bibliographic records exists;                     1 - remove holding and delete local holdings                     record and local bibliographic record</p> <p> TYPE: <code>str</code> DEFAULT: <code>'0'</code> </p> <code>inst</code> <p>registry ID of the institution whose holdings                     are being checked</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>instSymbol</code> <p>optional; OCLC symbol of the institution whose                     holdings are being checked</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>response_format</code> <p>'application/atom+json' (default) or                     'application/atom+xml'</p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/atom+json'</code> </p> <code>hooks</code> <p>Requests library hook system that can be                     used for signal event handling, see more at:                     https://requests.readthedocs.io/en/master/user/advanced/#event-hooks</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> <p>Returns:     list of <code>requests.Response</code> objects</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def holdings_unset(\n    self,\n    oclcNumbers: Union[str, List],\n    cascade: str = \"0\",\n    inst: Optional[str] = None,\n    instSymbol: Optional[str] = None,\n    response_format: str = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; List[Response]:\n    \"\"\"\n    Set institution holdings for multiple OCLC numbers\n    Uses /ih/datalist endpoint.\n\n    Args:\n        oclcNumbers:            list of OCLC control numbers for which holdings\n                                should be set;\n                                they can be integers or strings with or\n                                without OCLC # prefix;\n                                if str the numbers must be separated by comma\n        cascade:                0 or 1, default 0;\n                                0 - don't remove holdings if local holding\n                                record or local bibliographic records exists;\n                                1 - remove holding and delete local holdings\n                                record and local bibliographic record\n        inst:                   registry ID of the institution whose holdings\n                                are being checked\n        instSymbol:             optional; OCLC symbol of the institution whose\n                                holdings are being checked\n        response_format:        'application/atom+json' (default) or\n                                'application/atom+xml'\n        hooks:                  Requests library hook system that can be\n                                used for signal event handling, see more at:\n                                https://requests.readthedocs.io/en/master/user/advanced/#event-hooks\n    Returns:\n        list of `requests.Response` objects\n    \"\"\"\n    responses = []\n\n    try:\n        vetted_numbers = verify_oclc_numbers(oclcNumbers)\n    except InvalidOclcNumber as exc:\n        raise WorldcatSessionError(exc)\n\n    url = self._url_bib_holdings_batch_action()\n    header = {\"Accept\": response_format}\n\n    # split into batches of 50 and issue request for each batch\n    for batch in self._split_into_legal_volume(vetted_numbers):\n        payload = {\n            \"oclcNumbers\": batch,\n            \"cascade\": cascade,\n            \"inst\": inst,\n            \"instSymbol\": instSymbol,\n        }\n\n        # prep request\n        req = Request(\"DELETE\", url, params=payload, headers=header, hooks=hooks)\n        prepared_request = self.prepare_request(req)\n\n        # send request\n        query = Query(self, prepared_request, timeout=self.timeout)\n\n        responses.append(query.response)\n\n    return responses\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.holdings_unset_multi_institutions","title":"holdings_unset_multi_institutions","text":"<pre><code>holdings_unset_multi_institutions(\n    oclcNumber: Union[int, str],\n    instSymbols: str,\n    cascade: str = \"0\",\n    response_format: str = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Batch unsets intitution holdings for multiple intitutions</p> <p>Uses /ih/institutionlist endpoint</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number; can be an                     integer, or string with or without OCLC # prefix</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>instSymbols</code> <p>a comma-separated list of OCLC symbols of the                     institution whose holdings are being set</p> <p> TYPE: <code>str</code> </p> <code>cascade</code> <p>0 or 1, default 0;                     0 - don't remove holdings if local holding                     record or local bibliographic records exists;                     1 - remove holding and delete local holdings                     record and local bibliographic record</p> <p> TYPE: <code>str</code> DEFAULT: <code>'0'</code> </p> <code>response_format</code> <p>'application/atom+json' (default) or                     'application/atom+xml'</p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/atom+json'</code> </p> <code>hooks</code> <p>Requests library hook system that can be                     used for signal event handling, see more at:                     https://requests.readthedocs.io/en/master/user/advanced/#event-hooks</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> <p>Returns:     <code>requests.Response</code> object</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def holdings_unset_multi_institutions(\n    self,\n    oclcNumber: Union[int, str],\n    instSymbols: str,\n    cascade: str = \"0\",\n    response_format: str = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Batch unsets intitution holdings for multiple intitutions\n\n    Uses /ih/institutionlist endpoint\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer, or string with or without OCLC # prefix\n        instSymbols:            a comma-separated list of OCLC symbols of the\n                                institution whose holdings are being set\n        cascade:                0 or 1, default 0;\n                                0 - don't remove holdings if local holding\n                                record or local bibliographic records exists;\n                                1 - remove holding and delete local holdings\n                                record and local bibliographic record\n        response_format:        'application/atom+json' (default) or\n                                'application/atom+xml'\n        hooks:                  Requests library hook system that can be\n                                used for signal event handling, see more at:\n                                https://requests.readthedocs.io/en/master/user/advanced/#event-hooks\n    Returns:\n        `requests.Response` object\n    \"\"\"\n    try:\n        oclcNumber = verify_oclc_number(oclcNumber)\n    except InvalidOclcNumber:\n        raise WorldcatSessionError(\"Invalid OCLC # was passed as an argument\")\n\n    url = self._url_bib_holdings_multi_institution_batch_action()\n    header = {\"Accept\": response_format}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"instSymbols\": instSymbols,\n        \"cascade\": cascade,\n    }\n\n    # prep request\n    req = Request(\"DELETE\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.search_brief_bib_other_editions","title":"search_brief_bib_other_editions","text":"<pre><code>search_brief_bib_other_editions(\n    oclcNumber: Union[int, str],\n    deweyNumber: Optional[str] = None,\n    datePublished: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[str] = None,\n    heldByInstitutionID: Optional[Union[str, int]] = None,\n    inLanguage: Optional[str] = None,\n    inCatalogLanguage: Optional[str] = None,\n    materialType: Optional[str] = None,\n    catalogSource: Optional[str] = None,\n    itemType: Optional[str] = None,\n    itemSubType: Optional[str] = None,\n    retentionCommitments: Optional[bool] = None,\n    spProgram: Optional[str] = None,\n    genre: Optional[str] = None,\n    topic: Optional[str] = None,\n    subtopic: Optional[str] = None,\n    audience: Optional[str] = None,\n    content: Optional[str] = None,\n    openAccess: Optional[bool] = None,\n    peerReviewed: Optional[bool] = None,\n    facets: Optional[str] = None,\n    groupVariantRecords: Optional[bool] = None,\n    preferredLanguage: Optional[str] = None,\n    offset: Optional[int] = None,\n    limit: Optional[int] = None,\n    orderBy: Optional[str] = None,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Retrieve other editions related to bibliographic resource with provided OCLC #. Uses /brief-bibs/{oclcNumber}/other-editions endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number; can be an                     integer, or string with or without OCLC # prefix</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>deweyNumber</code> <p>limits the response to the                     specified dewey classification number(s);                     for multiple values repeat the parameter,                     example:                         '794,180'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>datePublished</code> <p>restricts the response to one or                     more dates, or to a range,                     examples:                         '2000'                         '2000-2005'                         '2000,2005'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldByGroup</code> <p>restricts to holdings held by group symbol</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldBySymbol</code> <p>restricts to holdings with specified intitution                     symbol</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldByInstitutionID</code> <p>restrict to specified institution regisgtryId</p> <p> TYPE: <code>Optional[Union[str, int]]</code> DEFAULT: <code>None</code> </p> <code>inLanguage</code> <p>restrics the response to the single                     specified language, example: 'fre'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>inCataloglanguage</code> <p>restrics the response to specified                     cataloging language, example: 'eng';                     default 'eng'</p> <p> </p> <code>materialType</code> <p>restricts responses to specified material type,                     example: 'bks', 'vis'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>catalogSource</code> <p>restrict to responses to single OCLC symbol as                     the cataloging source, example: 'DLC'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>itemType</code> <p>restricts reponses to single specified OCLC                     top-level facet type, example: 'book'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>itemSubType</code> <p>restricts responses to single specified OCLC                     sub facet type, example: 'digital'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>retentionCommitments</code> <p>restricts responses to bibliographic records                     with retention commitment; True or False,                     default False</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>spProgram</code> <p>restricts responses to bibliographic records                     associated with particular shared print                     program</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>genre</code> <p>genre to limit results to</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>topic</code> <p>topic to limit results to</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>subtopic</code> <p>subtopic to limit results to</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>audience</code> <p>audience to limit results to,                     example:                         juv,                         nonJuv</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>content</code> <p>content to limit resutls to,                     example:                         fic,                         nonFic,                         fic,bio</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>openAccess</code> <p>filter to only open access content, False or True</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>peerReviewed</code> <p>filter to only peer reviewed content, False or True</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>facets</code> <p>list of facets to restrict responses</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>groupVariantRecords</code> <p>whether or not to group variant records.                     options: False, True (default False)</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>preferredLanguage</code> <p>language of metadata description,</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>offset</code> <p>start position of bibliographic records to                     return; default 1</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>limit</code> <p>maximum nuber of records to return;                     maximum 50, default 10</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>orderBy</code> <p>sort of restuls;                     available values:                         +date, -date, +language, -language;                     default value: -date</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>hooks</code> <p>Requests library hook system that can be                     used for signal event handling, see more at:                     https://requests.readthedocs.io/en/master/user/advanced/#event-hooks</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> <p>Returns:     <code>requests.Response</code> object</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def search_brief_bib_other_editions(\n    self,\n    oclcNumber: Union[int, str],\n    deweyNumber: Optional[str] = None,\n    datePublished: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldBySymbol: Optional[str] = None,\n    heldByInstitutionID: Optional[Union[str, int]] = None,\n    inLanguage: Optional[str] = None,\n    inCatalogLanguage: Optional[str] = None,\n    materialType: Optional[str] = None,\n    catalogSource: Optional[str] = None,\n    itemType: Optional[str] = None,\n    itemSubType: Optional[str] = None,\n    retentionCommitments: Optional[bool] = None,\n    spProgram: Optional[str] = None,\n    genre: Optional[str] = None,\n    topic: Optional[str] = None,\n    subtopic: Optional[str] = None,\n    audience: Optional[str] = None,\n    content: Optional[str] = None,\n    openAccess: Optional[bool] = None,\n    peerReviewed: Optional[bool] = None,\n    facets: Optional[str] = None,\n    groupVariantRecords: Optional[bool] = None,\n    preferredLanguage: Optional[str] = None,\n    offset: Optional[int] = None,\n    limit: Optional[int] = None,\n    orderBy: Optional[str] = None,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Retrieve other editions related to bibliographic resource with provided\n    OCLC #.\n    Uses /brief-bibs/{oclcNumber}/other-editions endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be an\n                                integer, or string with or without OCLC # prefix\n        deweyNumber:            limits the response to the\n                                specified dewey classification number(s);\n                                for multiple values repeat the parameter,\n                                example:\n                                    '794,180'\n        datePublished:          restricts the response to one or\n                                more dates, or to a range,\n                                examples:\n                                    '2000'\n                                    '2000-2005'\n                                    '2000,2005'\n        heldByGroup:            restricts to holdings held by group symbol\n        heldBySymbol:           restricts to holdings with specified intitution\n                                symbol\n        heldByInstitutionID:    restrict to specified institution regisgtryId\n        inLanguage:             restrics the response to the single\n                                specified language, example: 'fre'\n        inCataloglanguage:      restrics the response to specified\n                                cataloging language, example: 'eng';\n                                default 'eng'\n        materialType:           restricts responses to specified material type,\n                                example: 'bks', 'vis'\n        catalogSource:          restrict to responses to single OCLC symbol as\n                                the cataloging source, example: 'DLC'\n        itemType:               restricts reponses to single specified OCLC\n                                top-level facet type, example: 'book'\n        itemSubType:            restricts responses to single specified OCLC\n                                sub facet type, example: 'digital'\n        retentionCommitments:   restricts responses to bibliographic records\n                                with retention commitment; True or False,\n                                default False\n        spProgram:              restricts responses to bibliographic records\n                                associated with particular shared print\n                                program\n        genre:                  genre to limit results to\n        topic:                  topic to limit results to\n        subtopic:               subtopic to limit results to\n        audience:               audience to limit results to,\n                                example:\n                                    juv,\n                                    nonJuv\n        content:                content to limit resutls to,\n                                example:\n                                    fic,\n                                    nonFic,\n                                    fic,bio\n        openAccess:             filter to only open access content, False or True\n        peerReviewed:           filter to only peer reviewed content, False or True\n        facets:                 list of facets to restrict responses\n        groupVariantRecords:    whether or not to group variant records.\n                                options: False, True (default False)\n        preferredLanguage:      language of metadata description,\n        offset:                 start position of bibliographic records to\n                                return; default 1\n        limit:                  maximum nuber of records to return;\n                                maximum 50, default 10\n        orderBy:                sort of restuls;\n                                available values:\n                                    +date, -date, +language, -language;\n                                default value: -date\n        hooks:                  Requests library hook system that can be\n                                used for signal event handling, see more at:\n                                https://requests.readthedocs.io/en/master/user/advanced/#event-hooks\n    Returns:\n        `requests.Response` object\n    \"\"\"\n    try:\n        oclcNumber = verify_oclc_number(oclcNumber)\n    except InvalidOclcNumber:\n        raise WorldcatSessionError(\"Invalid OCLC # was passed as an argument\")\n\n    url = self._url_brief_bib_other_editions(oclcNumber)\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"deweyNumber\": deweyNumber,\n        \"datePublished\": datePublished,\n        \"heldByGroup\": heldByGroup,\n        \"heldBySymbol\": heldBySymbol,\n        \"heldByInstitutionID\": heldByInstitutionID,\n        \"inLanguage\": inLanguage,\n        \"inCatalogLanguage\": inCatalogLanguage,\n        \"catalogSource\": catalogSource,\n        \"itemType\": itemType,\n        \"itemSubType\": itemSubType,\n        \"retentionCommitments\": retentionCommitments,\n        \"spProgram\": spProgram,\n        \"genre\": genre,\n        \"topic\": topic,\n        \"subtopic\": subtopic,\n        \"audience\": audience,\n        \"content\": content,\n        \"openAccess\": openAccess,\n        \"peerReviewed\": peerReviewed,\n        \"facets\": facets,\n        \"groupVariantRecords\": groupVariantRecords,\n        \"preferredLanguage\": preferredLanguage,\n        \"offset\": offset,\n        \"limit\": limit,\n        \"orderBy\": orderBy,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.search_brief_bibs","title":"search_brief_bibs","text":"<pre><code>search_brief_bibs(\n    q: str,\n    deweyNumber: Optional[str] = None,\n    datePublished: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    inLanguage: Optional[str] = None,\n    inCatalogLanguage: Optional[str] = \"eng\",\n    materialType: Optional[str] = None,\n    catalogSource: Optional[str] = None,\n    itemType: Optional[str] = None,\n    itemSubType: Optional[str] = None,\n    retentionCommitments: Optional[bool] = None,\n    spProgram: Optional[str] = None,\n    facets: Optional[str] = None,\n    groupRelatedEditions: Optional[bool] = None,\n    groupVariantRecords: Optional[bool] = None,\n    preferredLanguage: Optional[str] = None,\n    orderBy: Optional[str] = \"mostWidelyHeld\",\n    offset: Optional[int] = None,\n    limit: Optional[int] = None,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Send a GET request for brief bibliographic resources. Uses /brief-bibs endpoint.</p> PARAMETER DESCRIPTION <code>q</code> <p>query in the form of a keyword search or                     fielded search;                     examples:                         ti:Zendegi                         ti:\"Czarne oceany\"                         bn:9781680502404                         kw:python databases                         ti:Zendegi AND au:greg egan                         (au:Okken OR au:Myers) AND su:python</p> <p> TYPE: <code>str</code> </p> <code>deweyNumber</code> <p>limits the response to the                     specified dewey classification number(s);                     for multiple values repeat the parameter,                     example:                         '794,180'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>datePublished</code> <p>restricts the response to one or                     more dates, or to a range,                     examples:                         '2000'                         '2000-2005'                         '2000,2005'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldByGroup</code> <p>restricts to holdings held by group symbol</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>inLanguage</code> <p>restrics the response to the single                     specified language, example: 'fre'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>inCataloglanguage</code> <p>restrics the response to specified                     cataloging language, example: 'eng';                     default 'eng'</p> <p> </p> <code>materialType</code> <p>restricts responses to specified material type,                     example: 'bks', 'vis'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>catalogSource</code> <p>restrict to responses to single OCLC symbol as                     the cataloging source, example: 'DLC'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>itemType</code> <p>restricts reponses to single specified OCLC                     top-level facet type, example: 'book'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>itemSubType</code> <p>restricts responses to single specified OCLC                     sub facet type, example: 'digital'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>retentionCommitments</code> <p>restricts responses to bibliographic records                     with retention commitment; True or False</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>spProgram</code> <p>restricts responses to bibliographic records                     associated with particular shared print                     program</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>facets</code> <p>list of facets to restrict responses</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>groupRelatedEditions</code> <p>whether or not use FRBR grouping,                     options: False, True (default is False)</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>groupVariantRecords</code> <p>whether or not to group variant records.                     options: False, True (default False)</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>preferredLanguage</code> <p>language of metadata description,                     default value \"en\" (English)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>orderBy</code> <p>results sort key;                     options:                         'recency'                         'bestMatch'                         'creator'                         'library'                         'publicationDateAsc'                         'publicationDateDesc'                         'mostWidelyHeld'                         'title'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'mostWidelyHeld'</code> </p> <code>offset</code> <p>start position of bibliographic records to                     return; default 1</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>limit</code> <p>maximum nuber of records to return;                     maximum 50, default 10</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>hooks</code> <p>Requests library hook system that can be                     used for signal event handling, see more at:                     https://requests.readthedocs.io/en/master/user/advanced/#event-hooks</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> object</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def search_brief_bibs(\n    self,\n    q: str,\n    deweyNumber: Optional[str] = None,\n    datePublished: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    inLanguage: Optional[str] = None,\n    inCatalogLanguage: Optional[str] = \"eng\",\n    materialType: Optional[str] = None,\n    catalogSource: Optional[str] = None,\n    itemType: Optional[str] = None,\n    itemSubType: Optional[str] = None,\n    retentionCommitments: Optional[bool] = None,\n    spProgram: Optional[str] = None,\n    facets: Optional[str] = None,\n    groupRelatedEditions: Optional[bool] = None,\n    groupVariantRecords: Optional[bool] = None,\n    preferredLanguage: Optional[str] = None,\n    orderBy: Optional[str] = \"mostWidelyHeld\",\n    offset: Optional[int] = None,\n    limit: Optional[int] = None,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Send a GET request for brief bibliographic resources.\n    Uses /brief-bibs endpoint.\n\n    Args:\n        q:                      query in the form of a keyword search or\n                                fielded search;\n                                examples:\n                                    ti:Zendegi\n                                    ti:\"Czarne oceany\"\n                                    bn:9781680502404\n                                    kw:python databases\n                                    ti:Zendegi AND au:greg egan\n                                    (au:Okken OR au:Myers) AND su:python\n        deweyNumber:            limits the response to the\n                                specified dewey classification number(s);\n                                for multiple values repeat the parameter,\n                                example:\n                                    '794,180'\n        datePublished:          restricts the response to one or\n                                more dates, or to a range,\n                                examples:\n                                    '2000'\n                                    '2000-2005'\n                                    '2000,2005'\n        heldByGroup:            restricts to holdings held by group symbol\n        inLanguage:             restrics the response to the single\n                                specified language, example: 'fre'\n        inCataloglanguage:      restrics the response to specified\n                                cataloging language, example: 'eng';\n                                default 'eng'\n        materialType:           restricts responses to specified material type,\n                                example: 'bks', 'vis'\n        catalogSource:          restrict to responses to single OCLC symbol as\n                                the cataloging source, example: 'DLC'\n        itemType:               restricts reponses to single specified OCLC\n                                top-level facet type, example: 'book'\n        itemSubType:            restricts responses to single specified OCLC\n                                sub facet type, example: 'digital'\n        retentionCommitments:   restricts responses to bibliographic records\n                                with retention commitment; True or False\n        spProgram:              restricts responses to bibliographic records\n                                associated with particular shared print\n                                program\n        facets:                 list of facets to restrict responses\n        groupRelatedEditions:   whether or not use FRBR grouping,\n                                options: False, True (default is False)\n        groupVariantRecords:    whether or not to group variant records.\n                                options: False, True (default False)\n        preferredLanguage:      language of metadata description,\n                                default value \"en\" (English)\n        orderBy:                results sort key;\n                                options:\n                                    'recency'\n                                    'bestMatch'\n                                    'creator'\n                                    'library'\n                                    'publicationDateAsc'\n                                    'publicationDateDesc'\n                                    'mostWidelyHeld'\n                                    'title'\n        offset:                 start position of bibliographic records to\n                                return; default 1\n        limit:                  maximum nuber of records to return;\n                                maximum 50, default 10\n        hooks:                  Requests library hook system that can be\n                                used for signal event handling, see more at:\n                                https://requests.readthedocs.io/en/master/user/advanced/#event-hooks\n\n    Returns:\n        `requests.Response` object\n\n    \"\"\"\n    if not q:\n        raise WorldcatSessionError(\"Argument 'q' is requried to construct query.\")\n\n    url = self._url_brief_bib_search()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"q\": q,\n        \"deweyNumber\": deweyNumber,\n        \"datePublished\": datePublished,\n        \"heldByGroup\": heldByGroup,\n        \"inLanguage\": inLanguage,\n        \"inCatalogLanguage\": inCatalogLanguage,\n        \"materialType\": materialType,\n        \"catalogSource\": catalogSource,\n        \"itemType\": itemType,\n        \"itemSubType\": itemSubType,\n        \"retentionCommitments\": retentionCommitments,\n        \"spProgram\": spProgram,\n        \"facets\": facets,\n        \"groupRelatedEditions\": groupRelatedEditions,\n        \"groupVariantRecords\": groupVariantRecords,\n        \"preferredLanguage\": preferredLanguage,\n        \"orderBy\": orderBy,\n        \"offset\": offset,\n        \"limit\": limit,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.search_current_control_numbers","title":"search_current_control_numbers","text":"<pre><code>search_current_control_numbers(\n    oclcNumbers: Union[str, List[Union[str, int]]],\n    response_format: str = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Retrieve current OCLC control numbers Uses /bib/checkcontrolnumbers endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumbers</code> <p>list of OCLC control numbers to be checked;                     they can be integers or strings with or                     without OCLC # prefix;                     if str the numbers must be separated by comma</p> <p> TYPE: <code>Union[str, List[Union[str, int]]]</code> </p> <code>response_format</code> <p>'application/atom+json' (default) or                     'application/atom+xml'</p> <p> TYPE: <code>str</code> DEFAULT: <code>'application/atom+json'</code> </p> <code>hooks</code> <p>Requests library hook system that can be                     used for signal event handling, see more at:                     https://requests.readthedocs.io/en/master/user/advanced/#event-hooks</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Response</code> <p><code>requests.Response</code> object</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def search_current_control_numbers(\n    self,\n    oclcNumbers: Union[str, List[Union[str, int]]],\n    response_format: str = \"application/atom+json\",\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Retrieve current OCLC control numbers\n    Uses /bib/checkcontrolnumbers endpoint.\n\n    Args:\n        oclcNumbers:            list of OCLC control numbers to be checked;\n                                they can be integers or strings with or\n                                without OCLC # prefix;\n                                if str the numbers must be separated by comma\n        response_format:        'application/atom+json' (default) or\n                                'application/atom+xml'\n        hooks:                  Requests library hook system that can be\n                                used for signal event handling, see more at:\n                                https://requests.readthedocs.io/en/master/user/advanced/#event-hooks\n\n    Returns:\n        `requests.Response` object\n    \"\"\"\n\n    try:\n        vetted_numbers = verify_oclc_numbers(oclcNumbers)\n    except InvalidOclcNumber as exc:\n        raise WorldcatSessionError(exc)\n\n    header = {\"Accept\": response_format}\n    url = self._url_bib_check_oclc_numbers()\n    payload = {\"oclcNumbers\": \",\".join(vetted_numbers)}\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.search_general_holdings","title":"search_general_holdings","text":"<pre><code>search_general_holdings(\n    oclcNumber: Union[int, str] = None,\n    isbn: Optional[str] = None,\n    issn: Optional[str] = None,\n    holdingsAllEditions: Optional[bool] = None,\n    holdingsAllVariantRecords: Optional[bool] = None,\n    preferredLanguage: Optional[str] = None,\n    heldInCountry: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    lat: Optional[float] = None,\n    lon: Optional[float] = None,\n    distance: Optional[int] = None,\n    unit: Optional[str] = None,\n    offset: Optional[int] = None,\n    limit: Optional[int] = None,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Given a known item gets summary of holdings. Uses /bibs-summary-holdings endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number; can be                         an integer, or string that can include                         OCLC # prefix</p> <p> TYPE: <code>Union[int, str]</code> DEFAULT: <code>None</code> </p> <code>isbn</code> <p>ISBN without any dashes,                         example: '978149191646x'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>issn</code> <p>ISSN (hyphenated, example: '0099-1234')</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>holdingsAllEditions</code> <p>get holdings for all editions;                         options: True or False</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>holdingsAllVariantRecords</code> <p>get holdings for specific edition across variant                         records; options: False, True</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>preferredLanguage</code> <p>language of metadata description;                         default 'en' (English)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldInCountry</code> <p>restricts to holdings held by institutions                         in requested country</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldByGroup</code> <p>limits to holdings held by indicated by                         symbol group</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>lat</code> <p>limit to latitude, example: 37.502508</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>lon</code> <p>limit to longitute, example: -122.22702</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>distance</code> <p>distance from latitude and longitude</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>unit</code> <p>unit of distance param; options:                         'M' (miles) or 'K' (kilometers)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>offset</code> <p>start position of bibliographic records to                         return; default 1</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>limit</code> <p>maximum nuber of records to return;                         maximum 50, default 10</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>hooks</code> <p>Requests library hook system that can be                         used for signal event handling, see more at:                         https://requests.readthedocs.io/en/master/user/advanced/#event-hooks</p> <p> TYPE: <code>Optional[Dict[str, Callable]]</code> DEFAULT: <code>None</code> </p> <p>Returns:     <code>requests.Response</code> object</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def search_general_holdings(\n    self,\n    oclcNumber: Union[int, str] = None,\n    isbn: Optional[str] = None,\n    issn: Optional[str] = None,\n    holdingsAllEditions: Optional[bool] = None,\n    holdingsAllVariantRecords: Optional[bool] = None,\n    preferredLanguage: Optional[str] = None,\n    heldInCountry: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    lat: Optional[float] = None,\n    lon: Optional[float] = None,\n    distance: Optional[int] = None,\n    unit: Optional[str] = None,\n    offset: Optional[int] = None,\n    limit: Optional[int] = None,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Given a known item gets summary of holdings.\n    Uses /bibs-summary-holdings endpoint.\n\n    Args:\n        oclcNumber:                 OCLC bibliographic record number; can be\n                                    an integer, or string that can include\n                                    OCLC # prefix\n        isbn:                       ISBN without any dashes,\n                                    example: '978149191646x'\n        issn:                       ISSN (hyphenated, example: '0099-1234')\n        holdingsAllEditions:        get holdings for all editions;\n                                    options: True or False\n        holdingsAllVariantRecords:  get holdings for specific edition across variant\n                                    records; options: False, True\n        preferredLanguage:          language of metadata description;\n                                    default 'en' (English)\n        heldInCountry:              restricts to holdings held by institutions\n                                    in requested country\n        heldByGroup:                limits to holdings held by indicated by\n                                    symbol group\n        lat:                        limit to latitude, example: 37.502508\n        lon:                        limit to longitute, example: -122.22702\n        distance:                   distance from latitude and longitude\n        unit:                       unit of distance param; options:\n                                    'M' (miles) or 'K' (kilometers)\n        offset:                     start position of bibliographic records to\n                                    return; default 1\n        limit:                      maximum nuber of records to return;\n                                    maximum 50, default 10\n        hooks:                      Requests library hook system that can be\n                                    used for signal event handling, see more at:\n                                    https://requests.readthedocs.io/en/master/user/advanced/#event-hooks\n    Returns:\n        `requests.Response` object\n    \"\"\"\n    if not any([oclcNumber, isbn, issn]):\n        raise WorldcatSessionError(\n            \"Missing required argument. \"\n            \"One of the following args are required: oclcNumber, issn, isbn\"\n        )\n    if oclcNumber is not None:\n        try:\n            oclcNumber = verify_oclc_number(oclcNumber)\n        except InvalidOclcNumber:\n            raise WorldcatSessionError(\"Invalid OCLC # was passed as an argument\")\n\n    url = self._url_member_general_holdings()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"isbn\": isbn,\n        \"issn\": issn,\n        \"holdingsAllEditions\": holdingsAllEditions,\n        \"holdingsAllVariantRecords\": holdingsAllVariantRecords,\n        \"preferredLanguage\": preferredLanguage,\n        \"heldInCountry\": heldInCountry,\n        \"heldByGroup\": heldByGroup,\n        \"lat\": lat,\n        \"lon\": lon,\n        \"distance\": distance,\n        \"unit\": unit,\n        \"offset\": offset,\n        \"limit\": limit,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/metadata_api/#bookops_worldcat.metadata_api.MetadataSession.search_shared_print_holdings","title":"search_shared_print_holdings","text":"<pre><code>search_shared_print_holdings(\n    oclcNumber: Union[int, str] = None,\n    isbn: Optional[str] = None,\n    issn: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldInState: Optional[str] = None,\n    itemType: Optional[str] = None,\n    itemSubType: Optional[str] = None,\n    offset: Optional[int] = None,\n    limit: Optional[int] = None,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response\n</code></pre> <p>Finds member shared print holdings for specified item. Uses /bibs-retained-holdings endpoint.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC bibliographic record number; can be                     an integer, or string that can include                     OCLC # prefix</p> <p> TYPE: <code>Union[int, str]</code> DEFAULT: <code>None</code> </p> <code>isbn</code> <p>ISBN without any dashes,                     example: '978149191646x'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>issn</code> <p>ISSN (hyphenated, example: '0099-1234')</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldByGroup</code> <p>restricts to holdings held by group symbol</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>heldInState</code> <p>restricts to holings held by institutions                     in requested state, example: \"NY\"</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>itemType</code> <p>restricts results to specified item type (example                     'book' or 'vis')</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>itemSubType</code> <p>restricts results to specified item sub type                     examples: 'book-digital' or 'audiobook-cd'</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>offset</code> <p>start position of bibliographic records to                     return; default 1</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>limit</code> <p>maximum nuber of records to return;                     maximum 50, default 10</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <p>Returns:     <code>requests.Response</code> object</p> Source code in <code>bookops_worldcat\\metadata_api.py</code> <pre><code>def search_shared_print_holdings(\n    self,\n    oclcNumber: Union[int, str] = None,\n    isbn: Optional[str] = None,\n    issn: Optional[str] = None,\n    heldByGroup: Optional[str] = None,\n    heldInState: Optional[str] = None,\n    itemType: Optional[str] = None,\n    itemSubType: Optional[str] = None,\n    offset: Optional[int] = None,\n    limit: Optional[int] = None,\n    hooks: Optional[Dict[str, Callable]] = None,\n) -&gt; Response:\n    \"\"\"\n    Finds member shared print holdings for specified item.\n    Uses /bibs-retained-holdings endpoint.\n\n    Args:\n        oclcNumber:             OCLC bibliographic record number; can be\n                                an integer, or string that can include\n                                OCLC # prefix\n        isbn:                   ISBN without any dashes,\n                                example: '978149191646x'\n        issn:                   ISSN (hyphenated, example: '0099-1234')\n        heldByGroup:            restricts to holdings held by group symbol\n        heldInState:            restricts to holings held by institutions\n                                in requested state, example: \"NY\"\n        itemType:               restricts results to specified item type (example\n                                'book' or 'vis')\n        itemSubType:            restricts results to specified item sub type\n                                examples: 'book-digital' or 'audiobook-cd'\n        offset:                 start position of bibliographic records to\n                                return; default 1\n        limit:                  maximum nuber of records to return;\n                                maximum 50, default 10\n        \"\"\n    Returns:\n        `requests.Response` object\n    \"\"\"\n    if not any([oclcNumber, isbn, issn]):\n        raise WorldcatSessionError(\n            \"Missing required argument. \"\n            \"One of the following args are required: oclcNumber, issn, isbn\"\n        )\n\n    if oclcNumber is not None:\n        try:\n            oclcNumber = verify_oclc_number(oclcNumber)\n        except InvalidOclcNumber:\n            raise WorldcatSessionError(\"Invalid OCLC # was passed as an argument\")\n\n    url = self._url_member_shared_print_holdings()\n    header = {\"Accept\": \"application/json\"}\n    payload = {\n        \"oclcNumber\": oclcNumber,\n        \"isbn\": isbn,\n        \"issn\": issn,\n        \"heldByGroup\": heldByGroup,\n        \"heldInState\": heldInState,\n        \"offset\": offset,\n        \"limit\": limit,\n    }\n\n    # prep request\n    req = Request(\"GET\", url, params=payload, headers=header, hooks=hooks)\n    prepared_request = self.prepare_request(req)\n\n    # send request\n    query = Query(self, prepared_request, timeout=self.timeout)\n\n    return query.response\n</code></pre>"},{"location":"api/query/","title":"bookops_worldcat.query","text":"<p>Handles actual requests to OCLC services</p>"},{"location":"api/query/#bookops_worldcat.query.Query","title":"Query","text":"<pre><code>Query(\n    session: MetadataSession,\n    prepared_request: PreparedRequest,\n    timeout: Optional[\n        Union[\n            int, float, Tuple[int, int], Tuple[float, float]\n        ]\n    ] = None,\n)\n</code></pre> <p>Sends a request to OClC service and unifies received exceptions Query object handles refreshing expired token before request is made to the web service.</p> <p><code>Query.response</code> attribute is <code>requests.Response</code> instance that can be parsed to exctract received information from the web service.</p> <pre><code>prepared_request:               `requests.models.PreparedRequest` instance\ntimeout:                        how long to wait for server to send data\n                                before giving up\n</code></pre> Source code in <code>bookops_worldcat\\query.py</code> <pre><code>def __init__(\n    self,\n    session: MetadataSession,\n    prepared_request: PreparedRequest,\n    timeout: Optional[\n        Union[int, float, Tuple[int, int], Tuple[float, float]]\n    ] = None,\n) -&gt; None:\n    \"\"\"\n    Args:\n        session:                        `metadata_api.MetadataSession` instance\n        prepared_request:               `requests.models.PreparedRequest` instance\n        timeout:                        how long to wait for server to send data\n                                        before giving up\n\n    Raises:\n        WorldcatRequestError\n\n    \"\"\"\n    if not isinstance(prepared_request, PreparedRequest):\n        raise AttributeError(\"Invalid type for argument 'prepared_request'.\")\n\n    # make sure access token is still valid and if not request a new one\n    if session.authorization.is_expired():\n        session._get_new_access_token()\n\n    self.response = None\n\n    try:\n        self.response = session.send(prepared_request, timeout=timeout)\n\n        if \"/ih/data\" in prepared_request.url:\n            if self.response.status_code == 409:\n                # HTTP 409 code returns when trying to set/unset\n                # holdings on already set/unset record\n                # It is reasonable not to raise any exceptions\n                # in this case\n                pass  # pragma: no cover\n            else:\n                self.response.raise_for_status()\n        else:\n            self.response.raise_for_status()\n\n    except HTTPError as exc:\n        raise WorldcatRequestError(\n            f\"{exc}. Server response: {self.response.content}\"\n        )\n    except (Timeout, ConnectionError):\n        raise WorldcatRequestError(f\"Connection Error: {sys.exc_info()[0]}\")\n    except:\n        raise WorldcatRequestError(f\"Unexpected request error: {sys.exc_info()[0]}\")\n</code></pre>"},{"location":"api/utils/","title":"bookops_worldcat.utils","text":"<p>Shared utilities module.</p>"},{"location":"api/utils/#bookops_worldcat.utils.prep_oclc_number_str","title":"prep_oclc_number_str","text":"<pre><code>prep_oclc_number_str(oclcNumber: str) -&gt; str\n</code></pre> <p>Checks for OCLC prefixes and removes them.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC record as string</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>oclcNumber as int</p> Source code in <code>bookops_worldcat\\utils.py</code> <pre><code>def prep_oclc_number_str(oclcNumber: str) -&gt; str:\n    \"\"\"\n    Checks for OCLC prefixes and removes them.\n\n    Args:\n        oclcNumber:                OCLC record as string\n\n    Returns:\n        oclcNumber as int\n    \"\"\"\n    if \"ocm\" in oclcNumber or \"ocn\" in oclcNumber:\n        oclcNumber = oclcNumber.strip()[3:]\n    elif \"on\" in oclcNumber:\n        oclcNumber = oclcNumber.strip()[2:]\n\n    try:\n        oclcNumber = str(int(oclcNumber))\n        return oclcNumber\n    except ValueError:\n        raise InvalidOclcNumber(\"Argument 'oclcNumber' does not look like real OCLC #.\")\n</code></pre>"},{"location":"api/utils/#bookops_worldcat.utils.verify_oclc_number","title":"verify_oclc_number","text":"<pre><code>verify_oclc_number(oclcNumber: Union[int, str]) -&gt; str\n</code></pre> <p>Verifies a valid looking OCLC number is passed and normalize it as integer.</p> PARAMETER DESCRIPTION <code>oclcNumber</code> <p>OCLC record number</p> <p> TYPE: <code>Union[int, str]</code> </p> RETURNS DESCRIPTION <code>str</code> <p>oclcNumber</p> Source code in <code>bookops_worldcat\\utils.py</code> <pre><code>def verify_oclc_number(oclcNumber: Union[int, str]) -&gt; str:\n    \"\"\"\n    Verifies a valid looking OCLC number is passed and normalize it as integer.\n\n    Args:\n        oclcNumber:                OCLC record number\n\n    Returns:\n        oclcNumber\n\n    \"\"\"\n    if oclcNumber is None:\n        raise InvalidOclcNumber(\"Argument 'oclcNumber' is missing.\")\n\n    elif type(oclcNumber) is int:\n        return str(oclcNumber)\n\n    elif type(oclcNumber) is str:\n        return prep_oclc_number_str(oclcNumber)  # type: ignore\n\n    else:\n        raise InvalidOclcNumber(\"Argument 'oclc_number' is of invalid type.\")\n</code></pre>"},{"location":"api/utils/#bookops_worldcat.utils.verify_oclc_numbers","title":"verify_oclc_numbers","text":"<pre><code>verify_oclc_numbers(\n    oclcNumbers: Union[str, List[Union[str, int]]]\n) -&gt; List[str]\n</code></pre> <p>Parses and verifies list of oclcNumbers</p> PARAMETER DESCRIPTION <code>oclcNumbers</code> <p>list of OCLC control numbers for which holdings                     should be set;                     they can be integers or strings with or without                     OCLC # prefix;                     if str the numbers must be separated by comma</p> <p> TYPE: <code>Union[str, List[Union[str, int]]]</code> </p> <p>Returns:     vetted_numbers:         list of vetted oclcNumbers</p> Source code in <code>bookops_worldcat\\utils.py</code> <pre><code>def verify_oclc_numbers(oclcNumbers: Union[str, List[Union[str, int]]]) -&gt; List[str]:\n    \"\"\"\n    Parses and verifies list of oclcNumbers\n\n    Args:\n        oclcNumbers:            list of OCLC control numbers for which holdings\n                                should be set;\n                                they can be integers or strings with or without\n                                OCLC # prefix;\n                                if str the numbers must be separated by comma\n    Returns:\n        vetted_numbers:         list of vetted oclcNumbers\n    \"\"\"\n\n    # change to list if comma separated string\n    if type(oclcNumbers) is str and oclcNumbers != \"\":\n        oclcNumbers = _str2list(oclcNumbers)  # type: ignore\n\n    if not oclcNumbers or type(oclcNumbers) is not list:\n        raise InvalidOclcNumber(\n            \"Argument 'oclcNumbers' must be a list or comma separated string of valid OCLC #.\"\n        )\n\n    try:\n        vetted_numbers = [str(verify_oclc_number(n)) for n in oclcNumbers]\n        return vetted_numbers\n    except InvalidOclcNumber:\n        raise InvalidOclcNumber(\"One of passed OCLC #s is invalid.\")\n</code></pre>"}]}