<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../../img/favicon.ico">
  <title>bookops_worldcat.metadata_api - BookOps-Worldcat Documentation</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../../css/theme.css" />
  <link rel="stylesheet" href="../../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  <link href="//use.fontawesome.com/releases/v5.8.1/css/all.css" rel="stylesheet" />
  <link href="//use.fontawesome.com/releases/v5.8.1/css/v4-shims.css" rel="stylesheet" />
  <link href="../../../css/mkapi-common.css" rel="stylesheet" />
  <link href="../../../css/mkapi-readthedocs.css" rel="stylesheet" />
  <link href="../../../css/version-select.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "bookops_worldcat.metadata_api";
    var mkdocs_page_input_path = "api\\source\\bookops_worldcat.metadata_api.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../../.." class="icon icon-home"> BookOps-Worldcat Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../..">Home</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../changelog/">Changelog</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="" href="https://github.com/BookOps-CAT/bookops-worldcat">Source Code</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="" href="https://github.com/BookOps-CAT/bookops-worldcat/issues">Issue Tracker</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../about/">About</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">API</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="#">bookops_worldcat</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../bookops_worldcat/">bookops_worldcat</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../bookops_worldcat.authorize/">bookops_worldcat.authorize</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../bookops_worldcat.errors/">bookops_worldcat.errors</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../bookops_worldcat.metadata_api/">bookops_worldcat.metadata_api</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../bookops_worldcat.utils/">bookops_worldcat.utils</a>
                </li>
    </ul>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../..">BookOps-Worldcat Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../..">Docs</a> &raquo;</li>
    
      
    
    <li>bookops_worldcat.metadata_api</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <div class="mkapi-node">
<h1 id="" class="mkapi-object mkapi-object-code plain">
<span class="mkapi-object-kind mkapi-object-kind-code">SOURCE CODE</span>
<span class="mkapi-object-prefix">bookops_worldcat.</span><span class="mkapi-object-name">metadata_api</span>
<span id="bookops_worldcat.metadata_api"></span><a class="mkapi-docs-link" href="../../bookops_worldcat.metadata_api">DOCS</a>
</h1>

<div class="mkapi-code">
<pre class="codehilite"><code class="language-python"># -*- coding: utf-8 -*-

&quot;&quot;&quot;
This module provides MetadataSession class for requests to WorldCat Metadata API.
&quot;&quot;&quot;

import sys
from typing import Callable, Dict, List, Optional, Tuple, Union

import requests
from requests import Response

from ._session import WorldcatSession
from .authorize import WorldcatAccessToken
from .errors import (
    WorldcatSessionError,
    WorldcatRequestError,
    InvalidOclcNumber,
    WorldcatAuthorizationError,
)
from .utils import verify_oclc_number, verify_oclc_numbers, _parse_error_response


class MetadataSession(WorldcatSession):
# __mkapi__:bookops_worldcat.metadata_api:bookops_worldcat.metadata_api.MetadataSession
    &quot;&quot;&quot;OCLC Metadata API wrapper session. Inherits `requests.Session` methods&quot;&quot;&quot;

    def __init__(
        self,
        authorization: WorldcatAccessToken,
        agent: Optional[str] = None,
        timeout: Optional[
            Union[int, float, Tuple[int, int], Tuple[float, float]]
        ] = None,
    ) -&gt; None:
        &quot;&quot;&quot;
        Args:
            authorization:          WorlcatAccessToken object
            agent:                  &quot;User-agent&quot; parameter to be passed in the request
                                    header; usage strongly encouraged
            timeout:                how long to wait for server to send data before
                                    giving up; default value is 3 seconds
        &quot;&quot;&quot;
        WorldcatSession.__init__(self, agent=agent, timeout=timeout)

        self.authorization = authorization

        if type(self.authorization).__name__ != &quot;WorldcatAccessToken&quot;:
            raise WorldcatSessionError(
                &quot;Argument 'authorization' must include 'WorldcatAccessToken' object.&quot;
            )

        self._update_authorization()

    def _update_authorization(self) -&gt; None:
        self.headers.update({&quot;Authorization&quot;: f&quot;Bearer {self.authorization.token_str}&quot;})

    def _get_new_access_token(self) -&gt; None:
        &quot;&quot;&quot;
        Allows to continue sending request with new access token after
        the previous one expired
        &quot;&quot;&quot;
        try:
            self.authorization._request_token()
            self._update_authorization()
        except WorldcatAuthorizationError as exc:
            raise WorldcatSessionError(exc)

    def _split_into_legal_volume(self, oclc_numbers: List[str] = []) -&gt; List[str]:
        &quot;&quot;&quot;
        OCLC requries that no more than 50 numbers are passed for batch processing
        &quot;&quot;&quot;
        incomplete = True
        batches = []
        start = 0
        end = 50
        while incomplete:
            batch = oclc_numbers[start:end]
            if not batch:
                incomplete = False
            elif len(batch) &lt; 50:
                batches.append(&quot;,&quot;.join([str(x) for x in batch]))
                incomplete = False
            else:
                batches.append(&quot;,&quot;.join([str(x) for x in batch]))
                start += 50
                end += 50

        return batches

    def _url_base(self) -&gt; str:
        return &quot;https://worldcat.org&quot;

    def _url_search_base(self) -&gt; str:
        return &quot;https://americas.metadata.api.oclc.org/worldcat/search/v1&quot;

    def _url_member_shared_print_holdings(self) -&gt; str:
        base_url = self._url_search_base()
        return f&quot;{base_url}/bibs-retained-holdings&quot;

    def _url_member_general_holdings(self) -&gt; str:
        base_url = self._url_search_base()
        return f&quot;{base_url}/bibs-summary-holdings&quot;

    def _url_brief_bib_search(self) -&gt; str:
        base_url = self._url_search_base()
        return f&quot;{base_url}/brief-bibs&quot;

    def _url_brief_bib_oclc_number(self, oclcNumber: str) -&gt; str:
        base_url = self._url_search_base()
        return f&quot;{base_url}/brief-bibs/{oclcNumber}&quot;

    def _url_brief_bib_other_editions(self, oclcNumber: str) -&gt; str:
        base_url = self._url_search_base()
        return f&quot;{base_url}/brief-bibs/{oclcNumber}/other-editions&quot;

    def _url_lhr_control_number(self, controlNumber: str) -&gt; str:
        base_url = self._url_search_base()
        return f&quot;{base_url}/my-holdings/{controlNumber}&quot;

    def _url_lhr_search(self) -&gt; str:
        base_url = self._url_search_base()
        return f&quot;{base_url}/my-holdings&quot;

    def _url_lhr_shared_print(self) -&gt; str:
        base_url = self._url_search_base()
        return f&quot;{base_url}/retained-holdings&quot;

    def _url_bib_oclc_number(self, oclcNumber: str) -&gt; str:
        base_url = self._url_base()
        return f&quot;{base_url}/bib/data/{oclcNumber}&quot;

    def _url_bib_check_oclc_numbers(self) -&gt; str:
        base_url = self._url_base()
        return f&quot;{base_url}/bib/checkcontrolnumbers&quot;

    def _url_bib_holding_libraries(self) -&gt; str:
        base_url = self._url_base()
        return f&quot;{base_url}/bib/holdinglibraries&quot;

    def _url_bib_holdings_action(self) -&gt; str:
        base_url = self._url_base()
        return f&quot;{base_url}/ih/data&quot;

    def _url_bib_holdings_check(self) -&gt; str:
        base_url = self._url_base()
        return f&quot;{base_url}/ih/checkholdings&quot;

    def _url_bib_holdings_batch_action(self) -&gt; str:
        base_url = self._url_base()
        return f&quot;{base_url}/ih/datalist&quot;

    def _url_bib_holdings_multi_institution_batch_action(self) -&gt; str:
        base_url = self._url_base()
        return f&quot;{base_url}/ih/institutionlist&quot;

    def get_brief_bib(
# __mkapi__:bookops_worldcat.metadata_api:bookops_worldcat.metadata_api.MetadataSession.get_brief_bib
        self, oclcNumber: Union[int, str], hooks: Optional[Dict[str, Callable]] = None
    ) -&gt; Response:
        &quot;&quot;&quot;
        Retrieve specific brief bibliographic resource.

        Args:
            oclcNumber:             OCLC bibliographic record number; can be
                                    an integer, or string that can include
                                    OCLC # prefix
            hooks:                  Requests library hook system that can be
                                    used for signal event handling, see more at:
                                    https://requests.readthedocs.io/en/master/user/advanced/#event-hooks
        Returns:
            `requests.models.Response` object
        &quot;&quot;&quot;

        try:
            oclcNumber = verify_oclc_number(oclcNumber)
        except InvalidOclcNumber:
            raise WorldcatSessionError(&quot;Invalid OCLC # was passed as an argument&quot;)

        # make sure access token is still valid and if not request a new one
        if self.authorization.is_expired():
            self._get_new_access_token()

        header = {&quot;Accept&quot;: &quot;application/json&quot;}
        url = self._url_brief_bib_oclc_number(oclcNumber)

        # send request
        try:
            response = self.get(url, headers=header, hooks=hooks, timeout=self.timeout)
            if response.status_code == requests.codes.ok:
                return response
            else:
                error_msg = _parse_error_response(response)
                raise WorldcatRequestError(error_msg)
        except WorldcatRequestError as exc:
            raise WorldcatSessionError(exc)
        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
            raise WorldcatSessionError(f&quot;Connection error: {sys.exc_info()[0]}&quot;)
        except:
            raise WorldcatSessionError(f&quot;Unexpected request error: {sys.exc_info()[0]}&quot;)

    def get_full_bib(
# __mkapi__:bookops_worldcat.metadata_api:bookops_worldcat.metadata_api.MetadataSession.get_full_bib
        self,
        oclcNumber: Union[int, str],
        response_format: Optional[str] = None,
        hooks: Optional[Dict[str, Callable]] = None,
    ) -&gt; Response:
        &quot;&quot;&quot;
        Send a GET request for a full bibliographic resource.

        Args:
            oclcNumber:             OCLC bibliographic record number; can be an
                                    integer, or string with or without OCLC # prefix
            response_format:        format of returned record
            hooks:                  Requests library hook system that can be
                                    used for signal event handling, see more at:
                                    https://requests.readthedocs.io/en/master/user/advanced/#event-hooks
        Returns:
            `requests.Response` object
        &quot;&quot;&quot;
        try:
            oclcNumber = verify_oclc_number(oclcNumber)
        except InvalidOclcNumber:
            raise WorldcatSessionError(&quot;Invalid OCLC # was passed as an argument.&quot;)

        # make sure access token is still valid and if not request a new one
        if self.authorization.is_expired():
            self._get_new_access_token()

        url = self._url_bib_oclc_number(oclcNumber)
        if not response_format:
            response_format = (
                'application/atom+xml;content=&quot;application/vnd.oclc.marc21+xml&quot;'
            )
        header = {&quot;Accept&quot;: response_format}

        # send request
        try:
            response = self.get(url, headers=header, hooks=hooks, timeout=self.timeout)
            if response.status_code == requests.codes.ok:
                return response
            else:
                error_msg = _parse_error_response(response)
                raise WorldcatRequestError(error_msg)
        except WorldcatRequestError as exc:
            raise WorldcatSessionError(exc)
        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
            raise WorldcatSessionError(f&quot;Connection error: {sys.exc_info()[0]}&quot;)
        except:
            raise WorldcatSessionError(f&quot;Unexpected request error: {sys.exc_info()[0]}&quot;)

    def holding_get_status(
# __mkapi__:bookops_worldcat.metadata_api:bookops_worldcat.metadata_api.MetadataSession.holding_get_status
        self,
        oclcNumber: Union[int, str],
        inst: Optional[str] = None,
        instSymbol: Optional[str] = None,
        response_format: Optional[str] = &quot;application/atom+json&quot;,
        hooks: Optional[Dict[str, Callable]] = None,
    ) -&gt; Response:
        &quot;&quot;&quot;
        Retrieves Worlcat holdings status of a record with provided OCLC number.
        The service automatically recognizes institution based on the issued access
        token.

        Args:
            oclcNumber:             OCLC bibliographic record number; can be an
                                    integer, or string with or without OCLC # prefix
            inst:                   registry ID of the institution whose holdings
                                    are being checked
            instSymbol:             optional; OCLC symbol of the institution whose
                                    holdings are being checked
            response_format:        'application/atom+json' (default) or
                                    'application/atom+xml'
            hooks:                  Requests library hook system that can be
                                    used for signal event handling, see more at:
                                    https://requests.readthedocs.io/en/master/user/advanced/#event-hooks

        Returns:
            `requests.Response` object
        &quot;&quot;&quot;
        try:
            oclcNumber = verify_oclc_number(oclcNumber)
        except InvalidOclcNumber as exc:
            raise WorldcatSessionError(exc)

        # make sure access token is still valid and if not request a new one
        if self.authorization.is_expired():
            self._get_new_access_token()

        url = self._url_bib_holdings_check()
        header = {&quot;Accept&quot;: response_format}
        payload = {&quot;oclcNumber&quot;: oclcNumber, &quot;inst&quot;: inst, &quot;instSymbol&quot;: instSymbol}

        # send request
        try:
            response = self.get(
                url, headers=header, params=payload, hooks=hooks, timeout=self.timeout
            )
            if response.status_code == requests.codes.ok:
                return response
            else:
                error_msg = _parse_error_response(response)
                raise WorldcatRequestError(error_msg)
        except WorldcatRequestError as exc:
            raise WorldcatSessionError(exc)
        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
            raise WorldcatSessionError(f&quot;Connection error: {sys.exc_info()[0]}&quot;)
        except:
            raise WorldcatSessionError(f&quot;Unexpected request error: {sys.exc_info()[0]}&quot;)

    def holding_set(
# __mkapi__:bookops_worldcat.metadata_api:bookops_worldcat.metadata_api.MetadataSession.holding_set
        self,
        oclcNumber: Union[int, str],
        inst: Optional[str] = None,
        instSymbol: Optional[str] = None,
        holdingLibraryCode: Optional[str] = None,
        classificationScheme: Optional[str] = None,
        response_format: str = &quot;application/atom+json&quot;,
        hooks: Optional[Dict[str, Callable]] = None,
    ) -&gt; Response:
        &quot;&quot;&quot;
        Sets institution's Worldcat holding on an individual record.

        Args:
            oclcNumber:             OCLC bibliographic record number; can be an
                                    integer, or string with or without OCLC # prefix
            inst:                   registry ID of the institution whose holdings
                                    are being checked
            instSymbol:             optional; OCLC symbol of the institution whose
                                    holdings are being checked
            holdingLibraryCode:     four letter holding code to set the holing on
            classificationScheme:   whether or not to return group availability
                                    information
            response_format:        'application/atom+json' (default) or
                                    'application/atom+xml'
            hooks:                  Requests library hook system that can be
                                    used for signal event handling, see more at:
                                    https://requests.readthedocs.io/en/master/user/advanced/#event-hooks

        Returns:
            `requests.Response` object
        &quot;&quot;&quot;

        try:
            oclcNumber = verify_oclc_number(oclcNumber)
        except InvalidOclcNumber as exc:
            raise WorldcatSessionError(exc)

        # make sure access token is still valid and if not request a new one
        if self.authorization.is_expired():
            self._get_new_access_token()

        url = self._url_bib_holdings_action()
        header = {&quot;Accept&quot;: response_format}
        payload = {
            &quot;oclcNumber&quot;: oclcNumber,
            &quot;inst&quot;: inst,
            &quot;instSymbol&quot;: instSymbol,
            &quot;holdingLibraryCode&quot;: holdingLibraryCode,
            &quot;classificationScheme&quot;: classificationScheme,
        }

        # send request
        try:
            response = self.post(
                url, headers=header, params=payload, hooks=hooks, timeout=self.timeout
            )
            if response.status_code == 201:
                # the service does not return any meaningful response
                # when holdings are succesfully set
                return response
            elif response.status_code == 409:
                # holdings already set
                # it seems resonable to simply ignore this response
                return response
            else:
                error_msg = _parse_error_response(response)
                raise WorldcatRequestError(error_msg)
        except WorldcatRequestError as exc:
            raise WorldcatSessionError(exc)
        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
            raise WorldcatSessionError(f&quot;Connection error: {sys.exc_info()[0]}&quot;)
        except:
            raise WorldcatSessionError(f&quot;Unexpected request error: {sys.exc_info()[0]}&quot;)

    def holding_unset(
# __mkapi__:bookops_worldcat.metadata_api:bookops_worldcat.metadata_api.MetadataSession.holding_unset
        self,
        oclcNumber: Union[int, str],
        cascade: Union[int, str] = &quot;0&quot;,
        inst: Optional[str] = None,
        instSymbol: Optional[str] = None,
        holdingLibraryCode: Optional[str] = None,
        classificationScheme: Optional[str] = None,
        response_format: str = &quot;application/atom+json&quot;,
        hooks: Optional[Dict[str, Callable]] = None,
    ) -&gt; Response:
        &quot;&quot;&quot;
        Deletes institution's Worldcat holding on an individual record.

        Args:
            oclcNumber:             OCLC bibliographic record number; can be an
                                    integer, or string with or without OCLC # prefix
                                    if str the numbers must be separated by comma
            cascade:                0 or 1, default 0;
                                    0 - don't remove holdings if local holding
                                    record or local bibliographic records exists;
                                    1 - remove holding and delete local holdings
                                    record and local bibliographic record
            inst:                   registry ID of the institution whose holdings
                                    are being checked
            instSymbol:             optional; OCLC symbol of the institution whose
                                    holdings are being checked
            holdingLibraryCode:     four letter holding code to set the holing on
            classificationScheme:   whether or not to return group availability
                                    information
            response_format:        'application/atom+json' (default) or
                                    'application/atom+xml'
            hooks:                  Requests library hook system that can be
                                    used for signal event handling, see more at:
                                    https://requests.readthedocs.io/en/master/user/advanced/#event-hooks

        Returns:
            `requests.Response` object
        &quot;&quot;&quot;

        try:
            oclcNumber = verify_oclc_number(oclcNumber)
        except InvalidOclcNumber as exc:
            raise WorldcatSessionError(exc)

        # make sure access token is still valid and if not request a new one
        if self.authorization.is_expired():
            self._get_new_access_token()

        url = self._url_bib_holdings_action()
        header = {&quot;Accept&quot;: response_format}
        payload = {
            &quot;oclcNumber&quot;: oclcNumber,
            &quot;cascade&quot;: cascade,
            &quot;inst&quot;: inst,
            &quot;instSymbol&quot;: instSymbol,
            &quot;holdingLibraryCode&quot;: holdingLibraryCode,
            &quot;classificationScheme&quot;: classificationScheme,
        }

        # send request
        try:
            response = self.delete(
                url, headers=header, params=payload, hooks=hooks, timeout=self.timeout
            )
            if response.status_code == requests.codes.ok:
                # the service does not return any meaningful response
                # when holdings are succesfully deleted
                return response
            elif response.status_code == 409:
                # holdings already set
                # it seems resonable to simply ignore this response
                return response
            else:
                error_msg = _parse_error_response(response)
                raise WorldcatRequestError(error_msg)
        except WorldcatRequestError as exc:
            raise WorldcatSessionError(exc)
        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
            raise WorldcatSessionError(f&quot;Connection error: {sys.exc_info()[0]}&quot;)
        except:
            raise WorldcatSessionError(f&quot;Unexpected request error: {sys.exc_info()[0]}&quot;)

    def holdings_set(
# __mkapi__:bookops_worldcat.metadata_api:bookops_worldcat.metadata_api.MetadataSession.holdings_set
        self,
        oclcNumbers: Union[str, List],
        inst: Optional[str] = None,
        instSymbol: Optional[str] = None,
        response_format: str = &quot;application/atom+json&quot;,
        hooks: Optional[Dict[str, Callable]] = None,
    ) -&gt; List[Response]:
        &quot;&quot;&quot;
        Set institution holdings for multiple OCLC numbers

        Args:
            oclcNumbers:            list of OCLC control numbers for which holdings
                                    should be set;
                                    they can be integers or strings with or
                                    without OCLC # prefix;
                                    if str the numbers must be separated by comma
            inst:                   registry ID of the institution whose holdings
                                    are being checked
            instSymbol:             optional; OCLC symbol of the institution whose
                                    holdings are being checked
            response_format:        'application/atom+json' (default) or
                                    'application/atom+xml'
            hooks:                  Requests library hook system that can be
                                    used for signal event handling, see more at:
                                    https://requests.readthedocs.io/en/master/user/advanced/#event-hooks
        Returns:
            `requests.Response` object
        &quot;&quot;&quot;
        responses = []

        try:
            vetted_numbers = verify_oclc_numbers(oclcNumbers)
        except InvalidOclcNumber as exc:
            raise WorldcatSessionError(exc)

        url = self._url_bib_holdings_batch_action()
        header = {&quot;Accept&quot;: response_format}

        # split into batches of 50 and issue request for each batch
        for batch in self._split_into_legal_volume(vetted_numbers):
            payload = {
                &quot;oclcNumbers&quot;: batch,
                &quot;inst&quot;: inst,
                &quot;instSymbol&quot;: instSymbol,
            }

            # make sure access token is still valid and if not request a new one
            if self.authorization.is_expired():
                self._get_new_access_token()

            # send request
            try:
                response = self.post(
                    url,
                    headers=header,
                    params=payload,
                    hooks=hooks,
                    timeout=self.timeout,
                )

                if response.status_code == 207:
                    # the service returns multi-status response
                    responses.append(response)
                else:
                    error_msg = _parse_error_response(response)
                    raise WorldcatRequestError(error_msg)
            except WorldcatRequestError as exc:
                raise WorldcatSessionError(exc)
            except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                raise WorldcatSessionError(f&quot;Connection error: {sys.exc_info()[0]}&quot;)
            except:
                raise WorldcatSessionError(
                    f&quot;Unexpected request error: {sys.exc_info()[0]}&quot;
                )
        return responses

    def holdings_unset(
# __mkapi__:bookops_worldcat.metadata_api:bookops_worldcat.metadata_api.MetadataSession.holdings_unset
        self,
        oclcNumbers: Union[str, List],
        cascade: str = &quot;0&quot;,
        inst: Optional[str] = None,
        instSymbol: Optional[str] = None,
        response_format: str = &quot;application/atom+json&quot;,
        hooks: Optional[Dict[str, Callable]] = None,
    ) -&gt; List[Response]:
        &quot;&quot;&quot;
        Set institution holdings for multiple OCLC numbers

        Args:
            oclcNumbers:            list of OCLC control numbers for which holdings
                                    should be set;
                                    they can be integers or strings with or
                                    without OCLC # prefix;
                                    if str the numbers must be separated by comma
            cascade:                0 or 1, default 0;
                                    0 - don't remove holdings if local holding
                                    record or local bibliographic records exists;
                                    1 - remove holding and delete local holdings
                                    record and local bibliographic record
            inst:                   registry ID of the institution whose holdings
                                    are being checked
            instSymbol:             optional; OCLC symbol of the institution whose
                                    holdings are being checked
            response_format:        'application/atom+json' (default) or
                                    'application/atom+xml'
            hooks:                  Requests library hook system that can be
                                    used for signal event handling, see more at:
                                    https://requests.readthedocs.io/en/master/user/advanced/#event-hooks
        Returns:
            `requests.Response` object
        &quot;&quot;&quot;
        responses = []

        try:
            vetted_numbers = verify_oclc_numbers(oclcNumbers)
        except InvalidOclcNumber as exc:
            raise WorldcatSessionError(exc)

        url = self._url_bib_holdings_batch_action()
        header = {&quot;Accept&quot;: response_format}

        # split into batches of 50 and issue request for each batch
        for batch in self._split_into_legal_volume(vetted_numbers):
            payload = {
                &quot;oclcNumbers&quot;: batch,
                &quot;cascade&quot;: cascade,
                &quot;inst&quot;: inst,
                &quot;instSymbol&quot;: instSymbol,
            }

            # make sure access token is still valid and if not request a new one
            if self.authorization.is_expired():
                self._get_new_access_token()

            # send request
            try:
                response = self.delete(
                    url,
                    headers=header,
                    params=payload,
                    hooks=hooks,
                    timeout=self.timeout,
                )

                if response.status_code == 207:
                    # the service returns multi-status response
                    responses.append(response)
                else:
                    error_msg = _parse_error_response(response)
                    raise WorldcatRequestError(error_msg)
            except WorldcatRequestError as exc:
                raise WorldcatSessionError(exc)
            except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                raise WorldcatSessionError(f&quot;Connection error: {sys.exc_info()[0]}&quot;)
            except:
                raise WorldcatSessionError(
                    f&quot;Unexpected request error: {sys.exc_info()[0]}&quot;
                )
        return responses

    def search_brief_bib_other_editions(
# __mkapi__:bookops_worldcat.metadata_api:bookops_worldcat.metadata_api.MetadataSession.search_brief_bib_other_editions
        self,
        oclcNumber: Union[int, str],
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        hooks: Optional[Dict[str, Callable]] = None,
    ) -&gt; Response:
        &quot;&quot;&quot;
        Retrieve other editions related to bibliographic resource with provided
        OCLC #.

        Args:
            oclcNumber:             OCLC bibliographic record number; can be an
                                    integer, or string with or without OCLC # prefix
            offset:                 start position of bibliographic records to
                                    return; default 1
            limit:                  maximum nuber of records to return;
                                    maximum 50, default 10
            hooks:                  Requests library hook system that can be
                                    used for signal event handling, see more at:
                                    https://requests.readthedocs.io/en/master/user/advanced/#event-hooks
        Returns:
            `requests.Response` object
        &quot;&quot;&quot;
        try:
            oclcNumber = verify_oclc_number(oclcNumber)
        except InvalidOclcNumber:
            raise WorldcatSessionError(&quot;Invalid OCLC # was passed as an argument&quot;)

        # make sure access token is still valid and if not request a new one
        if self.authorization.is_expired():
            self._get_new_access_token()

        url = self._url_brief_bib_other_editions(oclcNumber)
        header = {&quot;Accept&quot;: &quot;application/json&quot;}
        payload = {&quot;offset&quot;: offset, &quot;limit&quot;: limit}

        # send request
        try:
            response = self.get(
                url, headers=header, params=payload, hooks=hooks, timeout=self.timeout
            )
            if response.status_code == requests.codes.ok:
                return response
            else:
                error_msg = _parse_error_response(response)
                raise WorldcatRequestError(error_msg)
        except WorldcatRequestError as exc:
            raise WorldcatSessionError(exc)
        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
            raise WorldcatSessionError(f&quot;Connection error: {sys.exc_info()[0]}&quot;)
        except:
            raise WorldcatSessionError(f&quot;Unexpected request error: {sys.exc_info()[0]}&quot;)

    def search_brief_bibs(
# __mkapi__:bookops_worldcat.metadata_api:bookops_worldcat.metadata_api.MetadataSession.search_brief_bibs
        self,
        q: str,
        deweyNumber: Optional[str] = None,
        datePublished: Optional[str] = None,
        heldBy: Optional[str] = None,
        heldByGroup: Optional[str] = None,
        inLanguage: Optional[str] = None,
        inCatalogLanguage: Optional[str] = &quot;eng&quot;,
        materialType: Optional[str] = None,
        catalogSource: Optional[str] = None,
        itemType: Optional[str] = None,
        itemSubType: Optional[str] = None,
        retentionCommitments: Optional[bool] = None,
        spProgram: Optional[str] = None,
        facets: Optional[str] = None,
        groupRelatedEditions: Optional[str] = None,
        orderBy: Optional[str] = &quot;mostWidelyHeld&quot;,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        hooks: Optional[Dict[str, Callable]] = None,
    ) -&gt; Response:
        &quot;&quot;&quot;
        Send a GET request for brief bibliographic resources.

        Args:
            q:                      query in the form of a keyword search or
                                    fielded search;
                                    examples:
                                        ti:Zendegi
                                        ti:&quot;Czarne oceany&quot;
                                        bn:9781680502404
                                        kw:python databases
                                        ti:Zendegi AND au:greg egan
                                        (au:Okken OR au:Myers) AND su:python
            deweyNumber:            limits the response to the
                                    specified dewey classification number(s);
                                    for multiple values repeat the parameter,
                                    example:
                                        '794,180'
            datePublished:          restricts the response to one or
                                    more dates, or to a range,
                                    examples:
                                        '2000'
                                        '2000-2005'
                                        '2000,2005'
            heldBy:                 institution symbol; restricts to records
                                    held by indicated institution
            heldByGroup:            restricts to holdings held by group symbol
            inLanguage:             restrics the response to the single
                                    specified language, example: 'fre'
            inCataloglanguage:      restrics the response to specified
                                    cataloging language, example: 'eng';
                                    default 'eng'
            materialType:           restricts responses to specified material type,
                                    example: 'bks', 'vis'
            catalogSource:          restrict to responses to single OCLC symbol as
                                    the cataloging source, example: 'DLC'
            itemType:               restricts reponses to single specified OCLC
                                    top-level facet type, example: 'book'
            itemSubType:            restricts responses to single specified OCLC
                                    sub facet type, example: 'digital'
            retentionCommitments:   restricts responses to bibliographic records
                                    with retention commitment; True or False
            spProgram:              restricts responses to bibliographic records
                                    associated with particular shared print
                                    program
            facets:                 list of facets to restrict responses
            groupRelatedEditions:   whether or not use FRBR grouping,
                                    options: 'Y' (yes) or 'N' (no);
                                    server's default 'N'
            orderBy:                results sort key;
                                    options:
                                        'recency'
                                        'bestMatch'
                                        'creator'
                                        'publicationDateAsc'
                                        'publicationDateDesc'
                                        'mostWidelyHeld'
                                        'title'
            offset:                 start position of bibliographic records to
                                    return; default 1
            limit:                  maximum nuber of records to return;
                                    maximum 50, default 10
            hooks:                  Requests library hook system that can be
                                    used for signal event handling, see more at:
                                    https://requests.readthedocs.io/en/master/user/advanced/#event-hooks

        Returns:
            `requests.Response` object

        &quot;&quot;&quot;
        if not q:
            raise WorldcatSessionError(&quot;Argument 'q' is requried to construct query.&quot;)

        # make sure access token is still valid and if not request a new one
        if self.authorization.is_expired():
            self._get_new_access_token()

        url = self._url_brief_bib_search()
        header = {&quot;Accept&quot;: &quot;application/json&quot;}
        payload = {
            &quot;q&quot;: q,
            &quot;deweyNumber&quot;: deweyNumber,
            &quot;datePublished&quot;: datePublished,
            &quot;heldBy&quot;: heldBy,
            &quot;heldByGroup&quot;: heldByGroup,
            &quot;inLanguage&quot;: inLanguage,
            &quot;inCatalogLanguage&quot;: inCatalogLanguage,
            &quot;materialType&quot;: materialType,
            &quot;catalogSource&quot;: catalogSource,
            &quot;itemType&quot;: itemType,
            &quot;itemSubType&quot;: itemSubType,
            &quot;retentionCommitments&quot;: retentionCommitments,
            &quot;spProgram&quot;: spProgram,
            &quot;facets&quot;: facets,
            &quot;groupRelatedEditions&quot;: groupRelatedEditions,
            &quot;orderBy&quot;: orderBy,
            &quot;offset&quot;: offset,
            &quot;limit&quot;: limit,
        }

        # send request
        try:
            response = self.get(
                url, headers=header, params=payload, hooks=hooks, timeout=self.timeout
            )
            if response.status_code == requests.codes.ok:
                return response
            else:
                error_msg = _parse_error_response(response)
                raise WorldcatRequestError(error_msg)
        except WorldcatRequestError as exc:
            raise WorldcatRequestError(exc)
        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
            raise WorldcatSessionError(f&quot;Connection error: {sys.exc_info()[0]}&quot;)
        except:
            raise WorldcatSessionError(f&quot;Unexpected request error: {sys.exc_info()[0]}&quot;)

    def search_current_control_numbers(
# __mkapi__:bookops_worldcat.metadata_api:bookops_worldcat.metadata_api.MetadataSession.search_current_control_numbers
        self,
        oclcNumbers: Union[str, List[Union[str, int]]],
        response_format: str = &quot;application/atom+json&quot;,
        hooks: Optional[Dict[str, Callable]] = None,
    ) -&gt; Response:
        &quot;&quot;&quot;
        Retrieve current OCLC control numbers

        Args:
            oclcNumbers:            list of OCLC control numbers to be checked;
                                    they can be integers or strings with or
                                    without OCLC # prefix;
                                    if str the numbers must be separated by comma
            response_format:        'application/atom+json' (default) or
                                    'application/atom+xml'
            hooks:                  Requests library hook system that can be
                                    used for signal event handling, see more at:
                                    https://requests.readthedocs.io/en/master/user/advanced/#event-hooks

        Returns:
            `requests.Response` object
        &quot;&quot;&quot;

        try:
            vetted_numbers = verify_oclc_numbers(oclcNumbers)
        except InvalidOclcNumber as exc:
            raise WorldcatSessionError(exc)

        # make sure access token is still valid and if not request a new one
        if self.authorization.is_expired():
            self._get_new_access_token()

        header = {&quot;Accept&quot;: response_format}
        url = self._url_bib_check_oclc_numbers()
        payload = {&quot;oclcNumbers&quot;: &quot;,&quot;.join(vetted_numbers)}

        # send request
        try:
            response = self.get(
                url, headers=header, params=payload, hooks=hooks, timeout=self.timeout
            )
            if response.status_code == 207:  # multi-status response
                return response
            else:
                error_msg = _parse_error_response(response)
                raise WorldcatRequestError(error_msg)
        except WorldcatRequestError as exc:
            raise WorldcatSessionError(exc)
        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
            raise WorldcatSessionError(f&quot;Connection error: {sys.exc_info()[0]}&quot;)
        except:
            raise WorldcatSessionError(f&quot;Unexpected request error: {sys.exc_info()[0]}&quot;)

    def search_general_holdings(
# __mkapi__:bookops_worldcat.metadata_api:bookops_worldcat.metadata_api.MetadataSession.search_general_holdings
        self,
        oclcNumber: Union[int, str] = None,
        isbn: Optional[str] = None,
        issn: Optional[str] = None,
        holdingsAllEditions: Optional[bool] = None,
        heldInCountry: Optional[str] = None,
        heldByGroup: Optional[str] = None,
        heldBy: Optional[str] = None,
        lat: Optional[float] = None,
        lon: Optional[float] = None,
        distance: Optional[int] = None,
        unit: Optional[str] = None,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        hooks: Optional[Dict[str, Callable]] = None,
    ) -&gt; Response:
        &quot;&quot;&quot;
        Given a known item gets summary of holdings.

        Args:
            oclcNumber:             OCLC bibliographic record number; can be
                                    an integer, or string that can include
                                    OCLC # prefix
            isbn:                   ISBN without any dashes,
                                    example: '978149191646x'
            issn:                   ISSN (hyphenated, example: '0099-1234')
            holdingsAllEditions:    get holdings for all editions;
                                    options: True or False
            heldInCountry:          restricts to holdings held by institutions
                                    in requested country
            heldByGroup:            limits to holdings held by indicated by
                                    symbol group
            heldBy:                 limits to holdings of single institution,
                                    use institution OCLC symbol
            lat:                    limit to latitude, example: 37.502508
            lon:                    limit to longitute, example: -122.22702
            distance:               distance from latitude and longitude
            unit:                   unit of distance param; options:
                                    'M' (miles) or 'K' (kilometers)
            offset:                 start position of bibliographic records to
                                    return; default 1
            limit:                  maximum nuber of records to return;
                                    maximum 50, default 10
        Returns:
            `requests.Response` object
        &quot;&quot;&quot;
        if not any([oclcNumber, isbn, issn]):
            raise WorldcatSessionError(
                &quot;Missing required argument. &quot;
                &quot;One of the following args are required: oclcNumber, issn, isbn&quot;
            )
        if oclcNumber is not None:
            try:
                oclcNumber = verify_oclc_number(oclcNumber)
            except InvalidOclcNumber:
                raise WorldcatSessionError(&quot;Invalid OCLC # was passed as an argument&quot;)

        # make sure access token is still valid and if not request a new one
        if self.authorization.is_expired():
            self._get_new_access_token()

        url = self._url_member_general_holdings()
        header = {&quot;Accept&quot;: &quot;application/json&quot;}
        payload = {
            &quot;oclcNumber&quot;: oclcNumber,
            &quot;isbn&quot;: isbn,
            &quot;issn&quot;: issn,
            &quot;holdingsAllEditions&quot;: holdingsAllEditions,
            &quot;heldInCountry&quot;: heldInCountry,
            &quot;heldByGroup&quot;: heldByGroup,
            &quot;heldBy&quot;: heldBy,
            &quot;lat&quot;: lat,
            &quot;lon&quot;: lon,
            &quot;distance&quot;: distance,
            &quot;unit&quot;: unit,
            &quot;offset&quot;: offset,
            &quot;limit&quot;: limit,
        }

        # send request
        try:
            response = self.get(
                url, headers=header, params=payload, hooks=hooks, timeout=self.timeout
            )
            if response.status_code == requests.codes.ok:
                return response
            else:
                error_msg = _parse_error_response(response)
                raise WorldcatRequestError(error_msg)
        except WorldcatRequestError as exc:
            raise WorldcatSessionError(exc)
        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
            raise WorldcatSessionError(f&quot;Connection error: {sys.exc_info()[0]}&quot;)
        except:
            raise WorldcatSessionError(f&quot;Unexpected request error: {sys.exc_info()[0]}&quot;)

    def search_shared_print_holdings(
# __mkapi__:bookops_worldcat.metadata_api:bookops_worldcat.metadata_api.MetadataSession.search_shared_print_holdings
        self,
        oclcNumber: Union[int, str] = None,
        isbn: Optional[str] = None,
        issn: Optional[str] = None,
        heldByGroup: Optional[str] = None,
        heldInState: Optional[str] = None,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        hooks: Optional[Dict[str, Callable]] = None,
    ) -&gt; Response:
        &quot;&quot;&quot;
        Finds member shared print holdings for specified item.

        Args:
            oclcNumber:             OCLC bibliographic record number; can be
                                    an integer, or string that can include
                                    OCLC # prefix
            isbn:                   ISBN without any dashes,
                                    example: '978149191646x'
            issn:                   ISSN (hyphenated, example: '0099-1234')
            heldByGroup:            restricts to holdings held by group symbol
            heldInState:            restricts to holings held by institutions
                                    in requested state, example: &quot;NY&quot;
            offset:                 start position of bibliographic records to
                                    return; default 1
            limit:                  maximum nuber of records to return;
                                    maximum 50, default 10
            &quot;&quot;
        Returns:
            `requests.Response` object
        &quot;&quot;&quot;
        if not any([oclcNumber, isbn, issn]):
            raise WorldcatSessionError(
                &quot;Missing required argument. &quot;
                &quot;One of the following args are required: oclcNumber, issn, isbn&quot;
            )

        if oclcNumber is not None:
            try:
                oclcNumber = verify_oclc_number(oclcNumber)
            except InvalidOclcNumber:
                raise WorldcatSessionError(&quot;Invalid OCLC # was passed as an argument&quot;)

        # make sure access token is still valid and if not request a new one
        if self.authorization.is_expired():
            self._get_new_access_token()

        url = self._url_member_shared_print_holdings()
        header = {&quot;Accept&quot;: &quot;application/json&quot;}
        payload = {
            &quot;oclcNumber&quot;: oclcNumber,
            &quot;isbn&quot;: isbn,
            &quot;issn&quot;: issn,
            &quot;heldByGroup&quot;: heldByGroup,
            &quot;heldInState&quot;: heldInState,
            &quot;offset&quot;: offset,
            &quot;limit&quot;: limit,
        }

        # send request
        try:
            response = self.get(
                url, headers=header, params=payload, hooks=hooks, timeout=self.timeout
            )
            if response.status_code == requests.codes.ok:
                return response
            else:
                error_msg = _parse_error_response(response)
                raise WorldcatRequestError(error_msg)
        except WorldcatRequestError as exc:
            raise WorldcatSessionError(exc)
        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
            raise WorldcatSessionError(f&quot;Request error: {sys.exc_info()[0]}&quot;)
        except:
            raise WorldcatSessionError(f&quot;Unexpected request error: {sys.exc_info()[0]}&quot;)</code></pre>
</div>
</div>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
      
    </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme.js" defer></script>
      <script src="../../../js/mkapi.js" defer></script>
      <script src="../../../js/version-select.js" defer></script>
      <script src="../../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
